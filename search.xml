<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis(十二) lua脚本</title>
      <link href="2021/03/04/Redis-lua%E8%84%9A%E6%9C%AC/"/>
      <url>2021/03/04/Redis-lua%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Lua简介"><a href="#1-Lua简介" class="headerlink" title="1.Lua简介"></a>1.Lua简介</h2><p>Lua是一个<span class="p red">轻量级的</span>、<span class="p red">可嵌入的</span>脚本语言，并且每次的执行都是作为一个原子命令来执行。Lua的体积很小，是因为自身并没有像其他语言那样提供强大的库，因此Lua不适合用来开发独立应用。但是Lua脚本由标准C编写而成，可以很容易实现和C/C++代码的互相调用，因此常嵌入其他语言开发的应用程序(例如Redis)中，从而为应用程序提供灵活的扩展和定制功能。</p><p>Redis在2.6版本后支持Lua脚本功能，嵌入Lua脚本的原因无非就是利用其原子执行的特性，开发者可以定制一套命令满足某个业务场景。虽然Redis自身的事务机制也能提供原子操作，但对于分布式锁、秒杀扣库存(一个用户只能抢购一次)等高并发的应用场景，执行效率远低于Lua脚本。</p><h2 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h2><table><thead><tr><th>名称</th><th>版本</th><th>描述</th></tr></thead><tbody><tr><td>EVAL</td><td>2.6.0</td><td>执行一段Lua脚本字符串，每次都需要将完整的lua脚本传递给redis服务器</td></tr><tr><td>SCRIPT LOAD</td><td>2.6.0</td><td>将一段lua脚本缓存到redis中并返回一个sha1校验码，仅仅存储并不会执行</td></tr><tr><td>EVALSHA</td><td>2.6.0</td><td>传递tag字符串到redis服务器，执行对应脚本(逻辑复用、减少网络带宽)</td></tr><tr><td>SCRIPT EXISTS</td><td>2.6.0</td><td>传递一个sha1校验码串redis服务器，判断服务器中是否存在</td></tr><tr><td>SCRIPT FLUSH</td><td>2.6.0</td><td>清除服务器上的所有缓存的脚本</td></tr><tr><td>SCRIPT KILL</td><td>2.6.0</td><td>杀死正在运行的脚本</td></tr><tr><td>SCRIPT DEBUG</td><td>3.2.0</td><td>设置调试模式，可设置同步、异步、关闭，同步会阻塞所有请求</td></tr></tbody></table><h3 id="2-1-EVAL"><a href="#2-1-EVAL" class="headerlink" title="2.1 EVAL"></a>2.1 EVAL</h3><span class="p blue">命令格式: EVAL script numkeys key [key …] arg [arg …]</span><ul><li>script: 一段Lua脚本字符串，要传具体的命令内容，不能传tag字符串</li><li>numkeys: 指定Lua脚本需要处理键的数量，其实就是key数组的长度(必填,没数组填0)</li><li>key [key …]: 表示脚本命令中用到了哪些Redis的键(非必传)</li><li>arg [arg …]: 附带参数(非必传)，在script中可以通过ARGV[index]获取</li></ul><p>例如对一个键为name1的字符串，设置值为疾风剑豪，使用Lua命令实现:<br><img src="/2021/03/04/Redis-lua%E8%84%9A%E6%9C%AC/EVAL%E5%91%BD%E4%BB%A4%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/2021/03/04/Redis-lua%E8%84%9A%E6%9C%AC/EVAL%E5%91%BD%E4%BB%A4%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>更多时候我们希望借助Lua脚本实现多条命令的原子操作，下面举几个执行多条命令的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同时设置俩个String键值对，并且key的值通过附带参数传入(不需要返回值)</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;EVAL <span class="string">&quot;redis.call(&#x27;set&#x27;,KEYS[1],ARGV[1]);redis.call(&#x27;set&#x27;,KEYS[2],ARGV[2])&quot;</span> <span class="number">2</span> <span class="string">&quot;name1&quot;</span> <span class="string">&quot;name2&quot;</span> <span class="string">&quot;疾风剑豪&quot;</span> <span class="string">&quot;快乐风男&quot;</span></span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个String键值对，并对另一个键值对递增，然后返回递增后的值</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;EVAL <span class="string">&quot;redis.call(&#x27;set&#x27;,KEYS[1],ARGV[1]);return redis.call(&#x27;incr&#x27;,KEYS[2])&quot;</span> <span class="number">2</span> <span class="string">&quot;name1&quot;</span> <span class="string">&quot;clickCount&quot;</span> <span class="string">&quot;疾风剑豪&quot;</span></span><br><span class="line">(integer) <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时修改某个hash结构的俩个属性(name、age)</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;EVAL <span class="string">&quot;redis.call(&#x27;hset&#x27;,KEYS[1], ARGV[1], ARGV[2]);redis.call(&#x27;hset&#x27;,KEYS[1], ARGV[3], ARGV[4])&quot;</span> <span class="number">1</span> <span class="string">&quot;user&quot;</span> <span class="string">&quot;name&quot;</span> <span class="string">&quot;张三&quot;</span> <span class="string">&quot;age&quot;</span> <span class="string">&quot;18&quot;</span></span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对某个值为数字的字符串，值+3</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;EVAL <span class="string">&quot;redis.call(&#x27;set&#x27;,KEYS[1], redis.call(&#x27;get&#x27;, KEYS[1]) + ARGV[1])&quot;</span> <span class="number">1</span> <span class="string">&quot;quantity&quot;</span> <span class="string">&quot;3&quot;</span></span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对某个值为数字的字符串，值+3，并返回增加后的值</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;EVAL <span class="string">&quot;redis.call(&#x27;set&#x27;,KEYS[1], redis.call(&#x27;get&#x27;, KEYS[1]) + ARGV[1]);return redis.call(&#x27;get&#x27;, KEYS[1])&quot;</span> <span class="number">1</span> <span class="string">&quot;quantity&quot;</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="string">&quot;7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个字符串，并对key2的值递增，如果key2的值并非数字，执行报错，但第一条命令仍然执行成功</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;EVAL <span class="string">&quot;redis.call(&#x27;set&#x27;,KEYS[1],ARGV[1]);redis.call(&#x27;incr&#x27;,KEYS[2])&quot;</span> <span class="number">2</span> <span class="string">&quot;key1&quot;</span> <span class="string">&quot;key2&quot;</span> <span class="string">&quot;二桃杀三士&quot;</span></span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述命令后面再加一个正常命令，执行仍然报错，但是第一条命令生效，第三条不生效，可以判定遇到异常命令直接终止脚本执行</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;EVAL <span class="string">&quot;redis.call(&#x27;set&#x27;,KEYS[1],ARGV[1]);redis.call(&#x27;incr&#x27;,KEYS[2]);redis.call(&#x27;set&#x27;,KEYS[3],ARGV[1])&quot;</span> <span class="number">3</span> <span class="string">&quot;key1&quot;</span> <span class="string">&quot;key2&quot;</span> <span class="string">&quot;key3&quot;</span> <span class="string">&quot;二桃杀三士&quot;</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p class="p red">注: script中的每个call都可以替换为pcall，如果Redis命令调用发生了错误，call将抛出一个Lua类型的错误，再强制EVAL命令把错误返回给命令的调用者，而pcall将捕获错误并返回表示错误的Lua表类型。</p><h3 id="2-2-SCRIPT-LOAD"><a href="#2-2-SCRIPT-LOAD" class="headerlink" title="2.2 SCRIPT LOAD"></a>2.2 SCRIPT LOAD</h3><p>将Lua脚本内容存储到Redis服务器，然后返回sha1校验码，但不会执行脚本内容。应用程序可以将sha1保存起来，后续需要执行此命令，只需要传sha1字符串即可。</p><p class="p blue">命令格式: EVAL LOAD script</p><h3 id="2-3-EVALSHA"><a href="#2-3-EVALSHA" class="headerlink" title="2.3 EVALSHA"></a>2.3 EVALSHA</h3><p>与EVAL命令几乎一致，只是将Lua脚本内容换成sha1校验码了。这么做一方面是提高Lua脚本的复用性，保证一个脚本逻辑可以在应用程序的多个地方调用，另一方面是减少网络带宽(特别是并发时)，毕竟多数场景Lua脚本内容的长度是远大于sha1校验码长度的，这种方式可以减少网络传输的消耗。</p><span class="p blue">命令格式: EVALSHA sha1 numkeys key [key …] arg [arg …]</span><h3 id="2-4-SCRIPT-EXISTS"><a href="#2-4-SCRIPT-EXISTS" class="headerlink" title="2.4 SCRIPT EXISTS"></a>2.4 SCRIPT EXISTS</h3><p>检查一或多个sha1校验码在redis服务器的缓存中是否存在，返回一个元素内容为0或1的有序列表，列表长度和传入的sha1校验码数组长度一致，通过返回列表的下坐标判断传入的sha1校验码是否存在。</p><p class="p blue">命令格式: SCRIPT EXISTS sha1 [sha1 ...]</p><h3 id="2-5-SCRIPT-FLUSH"><a href="#2-5-SCRIPT-FLUSH" class="headerlink" title="2.5 SCRIPT FLUSH"></a>2.5 SCRIPT FLUSH</h3><p>清空Redis服务器的所有Lua脚本缓存，此命令不需要任何参数，并且返回值永远是OK。</p><p class="p blue">命令格式: SCRIPT FLUSH</p><h3 id="2-6-SCRIPT-KILL"><a href="#2-6-SCRIPT-KILL" class="headerlink" title="2.6 SCRIPT KILL"></a>2.6 SCRIPT KILL</h3><p>杀死Redis服务器当前正在执行的脚本，也不需要任何参数，当且仅当脚本没有执行过写操作，这个命令才生效。此命令主要用于终止运行时间过长的脚本，或因为编写不当导致无限循环的脚本。如果当前脚本已经执行了写操作，则kill命令执行失败并报错，这主要为了保证脚本命令的原子性。</p><p class="p blue">命令格式: SCRIPT KILL</p><h2 id="3-复杂命令"><a href="#3-复杂命令" class="headerlink" title="3.复杂命令"></a>3.复杂命令</h2><p>上述的EVAL命令仅仅是将多个Redis原生命令打包并原子执行，但实际开发中我们可能会遇到更复杂的需求，比如涉及到一些if、boolean、运算符等判断，或者迭代器遍历等逻辑处理，这就需要去了解Lua的数据类型以及语法，才可以编写出业务复杂的脚本。具体的可以参考菜鸟教程:</p><p><a href="https://www.runoob.com/lua/lua-iterators.html">https://www.runoob.com/lua/lua-iterators.html</a></p><h3 id="3-1-弹出list多个元素"><a href="#3-1-弹出list多个元素" class="headerlink" title="3.1 弹出list多个元素"></a>3.1 弹出list多个元素</h3><p>利用list的lpop命令，一次请求弹出多个元素，直到获取到n个元素或list为空，在Lua脚本中可以将list的键、指定数量n设置为参数，然后编写一个脚本:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-- 返回结果集合</span><br><span class="line">local list = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">-- 元素数量参数转化为lua数据类型</span><br><span class="line">local num = tonumber(ARGV[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">-- 循环</span><br><span class="line"><span class="keyword">while</span> (num &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">-- 弹出第一个元素(如果为空返回nil)</span><br><span class="line">local item = redis.call(<span class="string">&#x27;LPOP&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">-- 如果为空，终止循环(虽然命令返回nil，但逻辑判断要用布尔)</span><br><span class="line"><span class="keyword">if</span> item == <span class="keyword">false</span> then</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- 将元素添加到返回结果集</span><br><span class="line">table.insert(list, item);</span><br><span class="line"></span><br><span class="line">-- 元素数量递减<span class="number">1</span></span><br><span class="line">num = num -<span class="number">1</span>;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list;</span><br></pre></td></tr></table></figure><h3 id="3-2-DDOS防护"><a href="#3-2-DDOS防护" class="headerlink" title="3.2 DDOS防护"></a>3.2 DDOS防护</h3><p>防止DDOS攻击的一个简单方法就是限制n秒内同IP的访问次数，在Lua脚本中可以将n秒、ip地址、访问限制数设置为参数，然后编写一个防御脚本:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- ip地址对应value递增，并返回给局部变量cnt</span><br><span class="line">local cnt = redis.call(<span class="string">&#x27;INCR&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">-- 如果递增后的值大于访问限制数,返回<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> cnt &gt; tonumber(ARGV[<span class="number">1</span>])</span><br><span class="line">then</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 如果递增后的值等于<span class="number">1</span>，说明key之前不存在。要么之前没有访问，要么正好到下一个时间窗，设置key的过期时间(参数n秒)</span><br><span class="line"><span class="keyword">if</span> cnt == <span class="number">1</span></span><br><span class="line">then</span><br><span class="line">redis.call(<span class="string">&#x27;PEXPIRE&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>])</span><br><span class="line">end</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p class="p red">Lua不支持精度数据类型，如果返回值可能携带小数，一定要使用toString()函数转化为字符串返回，否则小数部分会丢失!</p><!-- getway令牌桶: https://zhuanlan.zhihu.com/p/61661082?utm_source=wechat_timeline --><h2 id="4-客户端实现"><a href="#4-客户端实现" class="headerlink" title="4.客户端实现"></a>4.客户端实现</h2><h3 id="4-1-RedisTemplate"><a href="#4-1-RedisTemplate" class="headerlink" title="4.1 RedisTemplate"></a>4.1 RedisTemplate</h3><p>RedisTemplate客户端的execute重载方法支持Lua脚本的执行，但方法仅支持EVAL命令，并且集群模式调用会抛出不支持异常，因此只能通过redis的原始connection对象来执行脚本命令，并且底层使用Jedis、Lettuce，调用的api也有所不同。</p><figure class="highlight java"><figcaption><span>底层依赖Jedis客户端</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lua脚本</span></span><br><span class="line">String lua = <span class="string">&quot;redis.call(&#x27;set&#x27;,KEYS[1],ARGV[1]);redis.call(&#x27;set&#x27;,KEYS[2],ARGV[2])&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// keys数组</span></span><br><span class="line">List&lt;String&gt; keys = Arrays.asList(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;key2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// args数组</span></span><br><span class="line">List&lt;String&gt; args = Arrays.asList(<span class="string">&quot;aaaaa&quot;</span>, <span class="string">&quot;bbbbb&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过connection执行EVAL命令</span></span><br><span class="line">Object evalResult = redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection redisConnection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取connection</span></span><br><span class="line">Object nativeConnection = redisConnection.getNativeConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单机模式(jedis)</span></span><br><span class="line"><span class="keyword">if</span> (nativeConnection <span class="keyword">instanceof</span> Jedis) &#123;</span><br><span class="line"><span class="keyword">return</span> (Object) ((Jedis) nativeConnection).eval(lua, keys, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集群模式(jedis)</span></span><br><span class="line"><span class="keyword">if</span> (nativeConnection <span class="keyword">instanceof</span> JedisCluster) &#123;</span><br><span class="line"><span class="keyword">return</span> (Object) ((JedisCluster) nativeConnection).eval(lua, keys, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><figcaption><span>底层依赖Lettuce客户端</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lua脚本</span></span><br><span class="line">String lua = <span class="string">&quot;redis.call(&#x27;set&#x27;,KEYS[1],ARGV[1]);redis.call(&#x27;set&#x27;,KEYS[2],ARGV[2])&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// keys、args字节数组的数组(前2个字节数组为keys，后俩个为args)</span></span><br><span class="line"><span class="keyword">byte</span>[][] keysAndArgsBytesArray = <span class="keyword">new</span> <span class="keyword">byte</span>[][]&#123;<span class="string">&quot;key1&quot;</span>.getBytes(), <span class="string">&quot;key2&quot;</span>.getBytes(), <span class="string">&quot;aaaaa&quot;</span>.getBytes(), <span class="string">&quot;bbbbb&quot;</span>.getBytes()&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过connection执行EVAL命令</span></span><br><span class="line">Object evalResult = redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection redisConnection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取connection</span></span><br><span class="line">Object nativeConnection = redisConnection.getNativeConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单机模式(lettuce)</span></span><br><span class="line"><span class="keyword">if</span> (nativeConnection <span class="keyword">instanceof</span> LettuceConnection) &#123;</span><br><span class="line">RedisScriptingCommands commands = ((LettuceConnection) nativeConnection).scriptingCommands();</span><br><span class="line"><span class="keyword">return</span> (Object) commands.eval(lua.getBytes(), ReturnType.BOOLEAN, <span class="number">2</span>, keysAndArgsBytesArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集群模式(lettuce)</span></span><br><span class="line"><span class="keyword">if</span> (nativeConnection <span class="keyword">instanceof</span> LettuceClusterConnection) &#123;</span><br><span class="line">RedisScriptingCommands commands = ((LettuceConnection) nativeConnection).scriptingCommands();</span><br><span class="line"><span class="keyword">return</span> (Object) commands.eval(lua.getBytes(), ReturnType.BOOLEAN, <span class="number">2</span>, keysAndArgsBytesArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-2-Redisson"><a href="#4-2-Redisson" class="headerlink" title="4.2 Redisson"></a>4.2 Redisson</h3><p>Redisson客户端执行Lua脚本代码就简洁多了，也不需要考虑单机/集群模式，支持同步和异步两种形式调用，并且可以通过RScript.Mode枚举参数控制请求发送到主节点还是从节点(如果存在):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lua脚本</span></span><br><span class="line">String lua = <span class="string">&quot;redis.call(&#x27;set&#x27;,KEYS[1],ARGV[1]);redis.call(&#x27;set&#x27;,KEYS[2],ARGV[2])&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行EVAL命令，READ_ONLY优先发送到从节点，READ_WRITE发送到主节点</span></span><br><span class="line">Object evalResult = redissonClient.getScript().eval(RScript.Mode.READ_ONLY, lua, RScript.ReturnType.INTEGER, keys, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Lua脚本内容上传到Redis服务器</span></span><br><span class="line">String sha1 = redissonClient.getScript().scriptLoad(lua);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行sha1脚本</span></span><br><span class="line">Object evalShaResult = redissonClient.getScript().evalSha(RScript.Mode.READ_ONLY, sha1, RScript.ReturnType.INTEGER, keys, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一或多个sha1是否存在</span></span><br><span class="line">String sha1Test = <span class="string">&quot;asdasdasdasdasd&quot;</span>;</span><br><span class="line">List&lt;Boolean&gt; exist = redissonClient.getScript().scriptExists(sha1, sha1Test);</span><br></pre></td></tr></table></figure><h2 id="5-其他细节"><a href="#5-其他细节" class="headerlink" title="5.其他细节"></a>5.其他细节</h2><h3 id="5-1-主从复制"><a href="#5-1-主从复制" class="headerlink" title="5.1 主从复制"></a>5.1 主从复制</h3><p>如果Redis的持久化策略是AOF，那么每一条Lua脚本执行完毕后，都会将整个脚本内容发送到从节点，但由于主从节点的操作系统环境存在差异(特别是时间)，因此Redis脚本禁用了Lua语言库中与<span class="p red">文件</span>、<span class="p red">系统调用(例如获取当前时间)</span>相关函数，确保主节点与从节点的数据一致性。</p><p>在确保主从节点的数据一致性上，Redis还对Lua的随机函数做了特殊处理，替换了Lua的math.random和math.randomseed函数，使得每次执行脚本生成的随机值都是相同的(根据参数)。</p><h3 id="5-2-脚本超时-amp-死循环"><a href="#5-2-脚本超时-amp-死循环" class="headerlink" title="5.2 脚本超时&amp;死循环"></a>5.2 脚本超时&amp;死循环</h3><p>为了防止Lua脚本执行时间过长，导致其他命令阻塞，Redis提供了一个超时时间的参数<span class="p red">lua-time-limit(单位毫秒)</span>，来控制脚本的执行时间。但是这个参数并没有啥卵用，Redis不会因为超时就中断脚本的运行，仅仅在日志中打印警告，这是因为必须保证Lua脚本执行的原子性。</p><p>Lua脚本执行超时后，Redis服务器开始允许其他客户端的请求，但是仅仅处理<span class="p red">SCRIPT KILL</span>和<span class="p red">SHUTDOWN NOSAVE</span>命令，其他请求返回busy错误。另外如果脚本内容涉及并已执行过写操作，SCRIPT KILL命令是无法杀死的，只能采用SHUTDOWN NOSAVE命令强制关闭服务器。</p><h2 id="6-与事务区别"><a href="#6-与事务区别" class="headerlink" title="6.与事务区别"></a>6.与事务区别</h2><p class="p "></p><span class="p red">在原子执行方面</span>，两者均可保证执行的原子性，不会被CPU的线程上下文切换机制中断，因此编写Lua脚本时要控制执行时间，避免长时间阻塞影响其他命令的处理。另外事务在执行过程中某条命令出现异常会记录下来继续向下执行，Lua脚本遇到错误命令则停止执行。因此俩者都不能严格的保证原子性。<p class="p "></p><span class="p red">在网络开销方面</span>，事务中的每一条命令(包括开启、提交、回滚)都需要向Redis服务器发送一次网络请求，而Lua脚本一组命令仅需要一次请求，并且可以通过sha1校验码减少请求携带的内容，网络开销更小。对于Redis来说相当一大部分开销都来自网络传输，因此Lua脚本的效率更高。<p class="p "></p><span class="p red">在代码维护方面</span>，事务的命令是写在应用程序中，阅读起来简洁易懂，修改起来也比较容易。Lua脚本在维护方面的优势在于可以热部署，业务逻辑发生改变不需要像事务那样重新编译、启动，只需要修改Lua脚本内容即可，前提是Lua脚本写在文件或缓存中，而不是硬编码在程序中。<p class="p "></p><span class="p red">在功能支持方面</span>，Lua脚本仅仅支持命令的原子执行，事务不仅支持命令的原子执行，还可以设定监听、回滚的功能(我真觉得没啥卵用)。]]></content>
      
      
      <categories>
          
          <category> 缓存中间件 </category>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis(十一) 布隆过滤器</title>
      <link href="2021/02/20/Redis-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>2021/02/20/Redis-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>布隆过滤器由二进制向量(位数组)和一系列随机映射函数组成，用于快速定位某个元素是否存在。如果你需要判断的元素都是数字，那么Redis提供的BitMap结构完全可以胜任，但很多场景我们需要对字符串进行判断，这就必须运用随机映射(哈希)函数将字符串转化为数字放入BitMap中，考虑到哈希值碰撞的情况，就需要多个随机映射函数来减少误判率。</p><h2 id="2-二进制向量"><a href="#2-二进制向量" class="headerlink" title="2.二进制向量"></a>2.二进制向量</h2><p>BitMap也称为位图，实质上是一个二进制形式的字节数组，由0和1俩个数组构成，如图所示:<br><img src="/2021/02/20/Redis-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/BitMap%E5%88%9D%E5%A7%8B%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/2021/02/20/Redis-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/BitMap%E5%88%9D%E5%A7%8B%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>现在往创建的BitMap中添加7、15、24三个数字，看看bit结构的变化:<br><img src="/2021/02/20/Redis-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/BitMap%E8%B5%8B%E5%80%BC%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/2021/02/20/Redis-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/BitMap%E8%B5%8B%E5%80%BC%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p class="p red">BitMap添加、查询元素的本质是对二进制数组的位与运算，并且这种结构并不直接存储元素本身，而是以偏移量的形式记录，每个元素在BitMap中仅占有一个bit空间(1亿个bit也仅占有12MB内存空间)。</p><h2 id="3-基本原理"><a href="#3-基本原理" class="headerlink" title="3.基本原理"></a>3.基本原理</h2><p>如果存储的元素为字符串或者复杂对象，那么BitMap是无法通过一个bit表示的，这时候需要随机散列函数转化为数字，假设某个布隆过滤器有三个哈希函数，然后往该布隆过滤器中添加<span class="p red">张三</span>、<span class="p blue">李四</span>俩个字符串:<br><img src="/2021/02/20/Redis-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/BloomFilter%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0.png" class="lazyload" data-srcset="/2021/02/20/Redis-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/BloomFilter%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>图中可以看出布隆过滤器并没有存储元素本身，只是记录对应的多个随机映射函数值，这样大大节省了存储空间。在判断某个元素是否存在时，会将计算出该元素的所有随机映射函数值，<span class="p red">如果返回不存在，那么元素必定是不存在的。</span></p><p>另外图中也能看出随机映射函数的数量、BitMap的容量，直接影响到随机散列函数值碰撞的几率，也就是我们最关心的误判几率。在判断某个元素是否存在时，<span class="p red">如果返回存在，有可能真的存在，也可能只是随机散列函数值发生碰撞造成的假象，实际元素是不存在的。</span></p><h2 id="4-Redisson实现"><a href="#4-Redisson实现" class="headerlink" title="4.Redisson实现"></a>4.Redisson实现</h2><p>RedisTemplate客户端实现布隆过滤器比较麻烦，需要借助google的guava框架提供的功能，然后实现对BitMap的操作达到布隆过滤器的效果。而Redisson客户端对布隆过滤器进行了封装，可以直接调用API。</p><p>创建一个普通的布隆过滤器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line">RBloomFilter&lt;SomeObject&gt; bloomFilter = redisson.getBloomFilter(<span class="string">&quot;sample&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化布隆过滤器，预计统计元素数量为55000000，期望误差率为0.03(误差率必须小于1大于0，否则报错)</span></span><br><span class="line">bloomFilter.tryInit(<span class="number">55000000L</span>,<span class="number">0.03</span>);</span><br><span class="line">bloomFilter.add(newSomeObject(<span class="string">&quot;field1Value&quot;</span>,<span class="string">&quot;field2Value&quot;</span>));</span><br><span class="line">bloomFilter.add(newSomeObject(<span class="string">&quot;field5Value&quot;</span>,<span class="string">&quot;field8Value&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断元素是否存在</span></span><br><span class="line">bloomFilter.contains(newSomeObject(<span class="string">&quot;field1Value&quot;</span>,<span class="string">&quot;field8Value&quot;</span>));</span><br></pre></td></tr></table></figure><p>创建一个分布式布隆过滤器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建分布式对象</span></span><br><span class="line">RClusteredBloomFilter&lt;SomeObject&gt; bloomFilter = redisson.getClusteredBloomFilter(<span class="string">&quot;sample&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化布隆过滤器，预计统计元素数量为255000000，期望误差率为0.03</span></span><br><span class="line">bloomFilter.tryInit(<span class="number">255000000L</span>,<span class="number">0.03</span>);</span><br><span class="line">bloomFilter.add(newSomeObject(<span class="string">&quot;field1Value&quot;</span>,<span class="string">&quot;field2Value&quot;</span>));</span><br><span class="line">bloomFilter.add(newSomeObject(<span class="string">&quot;field5Value&quot;</span>,<span class="string">&quot;field8Value&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断元素是否存在</span></span><br><span class="line">bloomFilter.contains(newSomeObject(<span class="string">&quot;field1Value&quot;</span>,<span class="string">&quot;field8Value&quot;</span>));</span><br></pre></td></tr></table></figure><p class="p red">注: Redisson客户端创建的布隆过滤器，不支持删除元素操作。</p><h2 id="5-删除元素"><a href="#5-删除元素" class="headerlink" title="5.删除元素"></a>5.删除元素</h2><p>布隆过滤器在初始化时，期望误差率是无法设置为0的，也就是说无论怎么设置都会出现哈希碰撞，这就导致了元素无法删除，因为你不能确定某个bit位到底被几个元素映射，也就无法删除某个元素映射的bit值。</p><p>第一个解决方案是定时重构BitMap结构，首先无论怎么设置都会出现哈希碰撞，因此必然会考虑到误判的处理逻辑，元素在删除后重构前这段时间被查询时，可以直接按误判处理。这种方案适合数据量不高、修改频率小的场景。</p><p>第二种方案是参考guava的设计，为BitMap结构中的每个bit设置一个计数器，添加元素后映射的位置计数+1，删除元素时计数-1，计数减少到0时将bit位的值设置为0，达到删除元素的效果。这种方案相对定时重构要灵活很多，并且在大数据量的情况下同步数据也不会占用多少CPU，缺点是占用空间过多，并且Redisson客户端没有支持这种功能，需要手动去实现(用到这种场景在更新)。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存中间件 </category>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis(九) 事务机制</title>
      <link href="2021/02/10/Redis-%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/"/>
      <url>2021/02/10/Redis-%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>Redis的事务的本质是将一组命令进行打包，然后按照顺序执行命令，并且执行过程不会被其他客户端发送的命令打断插入，执行过程中若出现失败的命令也不会导致事务终止，而是跳过并执行下一条命令。</p><h2 id="2-执行过程"><a href="#2-执行过程" class="headerlink" title="2.执行过程"></a>2.执行过程</h2><p>事务相关命令:</p><ul><li>MULTI: 开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。</li><li>EXEC: 执行事务中的所有操作命令。</li><li>DISCARD: 取消事务，放弃执行事务块中的所有命令。</li><li>WATCH: 监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。</li><li>UNWATCH: 取消WATCH对所有key的监视。</li></ul><p><img src="/2021/02/10/Redis-%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" class="lazyload" data-srcset="/2021/02/10/Redis-%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6/%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><br><p class="p red">Redis事务提供的watch监控，必须在事务开启前执行。这个很容易理解，因为事务一旦开始执行就不会被上下文切换打断，那么执行期间也不可能执行其他命令，也就没有监控的意义。另外考虑到并发问题，事务在执行命令队列前会通过CAS进行检查，一旦发现修改记录，会阻止命令队列的执行。最后watch的监控是一次性的，无论执行是否成功，都会释放监控。</p><h2 id="3-客户端命令"><a href="#3-客户端命令" class="headerlink" title="3.客户端命令"></a>3.客户端命令</h2><p>RedisTemplate默认不支持事务操作，并且每次执行命令都会从连接池获取资源，使用完毕后归还。如果开启事务需要将enableTransactionSupport属性设置为true，这种情况下会将连接池获取的资源绑定到当前线程，直到事务提交后归还，以减少频繁的获取资源带来的消耗。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template.setEnableTransactionSupport(<span class="keyword">true</span>); <span class="comment">// 开启事务支持</span></span><br></pre></td></tr></table></figure><br>如果在@Transactional修饰的方法中使用Redis事务，Spring会自动帮我们开启、提交/回滚事务，在没有被@Transactional修饰的方法中，就需要手动调用API控制事务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 监控，一定要在事务开启前执行，不然会报错！</span></span><br><span class="line">redisTemplate.watch(<span class="string">&quot;testKey3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">template..multi();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行命令</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;testKey1&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">redisTemplate.opsForValue().increment(<span class="string">&quot;testKey2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">List&lt;Object&gt; execResultList = template.exec();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果集合为空，说明watch监控的key被修改过</span></span><br><span class="line"><span class="keyword">if</span>(execResultList.isEmpty())&#123;</span><br><span class="line"><span class="comment">// 逻辑处理...</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 逻辑处理...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-与关系型数据库事务的区别"><a href="#4-与关系型数据库事务的区别" class="headerlink" title="4.与关系型数据库事务的区别"></a>4.与关系型数据库事务的区别</h2><h3 id="4-1-原子性"><a href="#4-1-原子性" class="headerlink" title="4.1 原子性"></a>4.1 原子性</h3><p>原子性是指一个事务内的SQL或命令集是不可分割的，要么都执行要么都不执行。关系型数据库以Mysql为例，事务内的多条SQL执行会先写入redolog中，直到事务提交才会执行磁盘IO进行持久化，如果执行过程中断电、异常、手动回滚事务则不会将SQL的执行效果刷回磁盘，达到要么都执行要么都不执行的效果。</p><p>Redis的事务原子性属于弱原子性，我们都知道Redis执行命令是单线程执行，Redis仅仅保证某个事务的命令集执行过程中不会被CPU的上下文切换打断，并且不支持异常回滚，出现异常的命令会跳过继续往下执行。<span class="p red">所以说Redis事务不是严格意义上的原子性，因为达不到要么都执行，要么都不执行的效果。</span></p><p>在原子性这方面Redis也增加一些机制减少命令执行错误带来的影响，比如命令总是发送到服务端的命令池里，这样服务端就可以对命令进行一些名称、格式之类的校验，以减少事务执行过程中的异常几率，如果在测试环境前做了充足的测试，出现命令异常的可能性很小，在这种理论前提下，Redis的原子性与关系型数据库也不会有太大差距，但是断电的情况就无法做任何保证。</p><h3 id="4-2-一致性"><a href="#4-2-一致性" class="headerlink" title="4.2 一致性"></a>4.2 一致性</h3><p>关系型数据库的一致性是事务执行成功后，涉及到的数据从一个一致状态转移到另一个一致状态，但完整性约束没有被破坏，比如经典的转账，先扣钱A账户的钱，在添加B账号的钱，在事务执行完毕后两者的钱总合不应该发生变化(不考虑扣手续费情况)，这就是完整性约束，关系型数据的一致性是由其他三大特性和应用程序来保证的，而Redis并不满足原子性和持久性，所以一致性也无法保证。</p><h3 id="4-3-隔离性"><a href="#4-3-隔离性" class="headerlink" title="4.3 隔离性"></a>4.3 隔离性</h3><p>这个没啥好说的，Redis以单线程模式处理所有命令，并且执行过程中不会被上下文切换打断，因此Redis的事务总是串行化执行，不存在隔离性这种问题。</p><h3 id="4-4-持久性"><a href="#4-4-持久性" class="headerlink" title="4.4 持久性"></a>4.4 持久性</h3><p>关系型数据库每次事务提交后就会进行持久化，Redis的持久化并不与事务的提交挂钩，因此Redis的事务是没有持久化这个特性的。</p><h2 id="5-为什么不支持异常回滚"><a href="#5-为什么不支持异常回滚" class="headerlink" title="5.为什么不支持异常回滚?"></a>5.为什么不支持异常回滚?</h2><p>通常我们应用程序都是通过各种客户端连接Redis服务，执行命令也都是调用API，最终客户端帮我们生成命令并发送，不会出现语法错误，其次客户端在真正执行事务前也会对命令进行校验，比如对某个HashMap类型的key使用了add，或者对value非数字的String类型key，使用了increment命令，这些服务端都会检测出来并拒绝执行，另外还有watch来提高事务的原子性。再加上开发过程中的测试，几乎不会存在命令执行异常的情况。</p><p>对于事务执行过程中出现宕机、断电情况，也不是没法保证，只是这种保证会让整个Redis的设计更加复杂，命令的处理效率变低，而Redis设计的首要目的是让程序快速运行，事务操作会让整个服务阻塞点增多，降低命令处理的吞吐量，为了这种小概率发生的场景提高设计复杂度和性能，似乎不划算。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存中间件 </category>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis(八) 管道机制</title>
      <link href="2021/02/07/Redis-%E7%AE%A1%E9%81%93%E6%9C%BA%E5%88%B6/"/>
      <url>2021/02/07/Redis-%E7%AE%A1%E9%81%93%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-工作原理"><a href="#1-工作原理" class="headerlink" title="1.工作原理"></a>1.工作原理</h2><p>在使用Redis客户端发送请求命令时，每条命令都会与Redis服务端进行一次socket通信，那么每次请求的耗时等于服务端处理时间+网络传输时间(三次握手、四次挥手)。服务端的操作都是在内存中进行，不会耗费太多的时间，因此一个请求的耗时很大程度取决于网络开销。管道技术就是为了批量操作场景下，通过减少服务端与客户端的通信次数，减少请求耗时的一种优化。</p><p><img src="/2021/02/07/Redis-%E7%AE%A1%E9%81%93%E6%9C%BA%E5%88%B6/%E7%AE%A1%E9%81%93%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C.png" class="lazyload" data-srcset="/2021/02/07/Redis-%E7%AE%A1%E9%81%93%E6%9C%BA%E5%88%B6/%E7%AE%A1%E9%81%93%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"><br>图中可以看出pipeline就是为了批量操作而设计的，三条命令使用管道没什么直观效果，但随着命令数量的增加或网络延迟变高，管道操作的优势会越来越明显。</p><h2 id="2-客户端命令"><a href="#2-客户端命令" class="headerlink" title="2.客户端命令"></a>2.客户端命令</h2><p>对于服务端来说就没有pipeline相关概念，这完全属于客户端支持的功能，服务端无法区分请求是否为pipeline请求，只是支持一次通信多条命令的的接收，最终还是单条执行完后汇总返回。<span class="p red">另外pipeline请求会独占链接，期间不能进行非pipeline请求，因此使用pipeline需要单独分配连接对象。</span></p><p>客户端代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Long&gt; List = redisTemplate.executePipelined(<span class="keyword">new</span> RedisCallback&lt;Long&gt;() &#123;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">connection.openPipeline();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">String key = <span class="string">&quot;PIPLINE_KEY_&quot;</span> + i;</span><br><span class="line">connection.zCount(key.getBytes(), <span class="number">0</span>,Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-命令行限制"><a href="#3-命令行限制" class="headerlink" title="3.命令行限制"></a>3.命令行限制</h2><p>虽然pipeline是为批量操作而设计的，明面上没有任何数量限制，但这并不代表你可以在请求中无限制添加命令，每个socket在操作系统内核中都有一个发送缓冲区和一个接收缓冲区，pipeline命令处理完毕后将数据发送到接收缓冲区一直保存，直到应用程序(客户端)读走为止。如果pipeline命令返回的数据过多导致接收缓冲区存满，根据TCP socket原理会发送信息给服务端告知接收窗口关闭，保证TCP套接口接收缓冲区不会溢出，从而保证了TCP是可靠传输。那么剩余未发送的结果数据会直接丢弃。</p><p class="p red">注: 官方建议每次pipeline请求不要超过1W条命令</p><h2 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4.适用场景"></a>4.适用场景</h2><ul><li>pipeline请求发送后客户端需同步阻塞等待结果，适用对响应实时性要求不高的场景</li><li>pipeline请求不可能保证所有的命令都执行成功，适用那些允许一定比例失败的场景</li><li>pipeline请求不能保证多条命令的原子性，适用没有执行关系的命令集场景</li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存中间件 </category>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis(七) 发布订阅</title>
      <link href="2021/02/06/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"/>
      <url>2021/02/06/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
      
        <content type="html"><![CDATA[<h2 id="1-工作原理"><a href="#1-工作原理" class="headerlink" title="1.工作原理"></a>1.工作原理</h2><p>Redis的发布订阅(pub/sub)是一种消息通信模式，客户端指定某个频道(channel)进行消息的发布和订阅，向channel发送消息的客户端称为发布者(pub)，订阅并接收消息的客户端称为订阅者(sub)。<br><img src="/2021/02/06/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB.png" class="lazyload" data-srcset="/2021/02/06/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h2 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2.存储结构"></a>2.存储结构</h2><p><img src="/2021/02/06/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/2021/02/06/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>图中可看出结构与Java的HashMap类似，并且关系结构中并没有涉及到发布者，可以断定客户端可以通过命令随意向channel发送消息。当消息发送到channel后，会遍历所有订阅此channel的客户端，逐个进行消息的推送。</p><h2 id="3-终端命令"><a href="#3-终端命令" class="headerlink" title="3.终端命令"></a>3.终端命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">publish [channel] [message] &#x2F;&#x2F; 向某个频道发布消息</span><br><span class="line"></span><br><span class="line">subscribe [channel-0] [channel-1] &#x2F;&#x2F; 订阅一个或多个频道消息</span><br><span class="line"></span><br><span class="line">unsubscribe [channel] &#x2F;&#x2F; 退订某频道消息</span><br></pre></td></tr></table></figure><h2 id="4-客户端命令"><a href="#4-客户端命令" class="headerlink" title="4.客户端命令"></a>4.客户端命令</h2><h3 id="4-1-发布消息"><a href="#4-1-发布消息" class="headerlink" title="4.1 发布消息"></a>4.1 发布消息</h3><p>RedisTemplate客户端提供了发布消息的API:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.convertAndSend(<span class="string">&quot;频道名称&quot;</span>, <span class="string">&quot;消息Object&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="4-2-接受消息"><a href="#4-2-接受消息" class="headerlink" title="4.2 接受消息"></a>4.2 接受消息</h3><p>关于订阅的配置类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis消息监听器容器</span></span><br><span class="line"><span class="comment">     * 这个容器加载了RedisConnectionFactory和消息监听器</span></span><br><span class="line"><span class="comment">     * 可以添加多个监听不同话题的redis监听器，只需要把消息监听器和相应的消息订阅处理器绑定，该消息监听器</span></span><br><span class="line"><span class="comment">     * 通过反射技术调用消息订阅处理器的相关方法进行一些业务处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory 链接工厂</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> adapter 适配器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> redis消息监听容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisMessageListenerContainer <span class="title">container</span><span class="params">(RedisConnectionFactory connectionFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        MessageListenerAdapter adapter)</span> </span>&#123;</span><br><span class="line">        RedisMessageListenerContainer container = <span class="keyword">new</span> RedisMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">//可以添加多个 messageListener</span></span><br><span class="line">        container.addMessageListener(adapter, <span class="keyword">new</span> PatternTopic(<span class="string">&quot;频道名称1&quot;</span>));</span><br><span class="line">        container.addMessageListener(adapter, <span class="keyword">new</span> PatternTopic(<span class="string">&quot;频道名称2&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息监听器适配器，绑定消息处理器，利用反射技术调用消息处理器的业务方法</span></span><br><span class="line"><span class="comment">     * 将MessageReceiver注册为一个消息监听器，可以自定义消息接收的方法（handleMessage）</span></span><br><span class="line"><span class="comment">     * 如果不指定消息接收的方法，消息监听器会默认的寻找MessageReceiver中的onMessage这个方法作为消息接收的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageReceiver 消息接受</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 适配器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageListenerAdapter <span class="title">adapter</span><span class="params">(MessageReceiverSupport messageReceiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageListenerAdapter(messageReceiver, <span class="string">&quot;onMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageReceiverSupport</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = redisTemplate.getStringSerializer();</span><br><span class="line">        String msg= redisSerializer.deserialize(message.getBody());</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的消息是：&quot;</span>+ msg);</span><br><span class="line">        log.info(<span class="string">&quot;Received &lt;&quot;</span> + msg + <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-与MQ的区别"><a href="#5-与MQ的区别" class="headerlink" title="5.与MQ的区别"></a>5.与MQ的区别</h2><p>Redis仅仅提供了最基础的发布订阅功能，无法做到消息的持久化、重试等可靠机制，消息丢失概率较大，不适用消息密集或者可靠性要求很高的场景，甚至说有些鸡肋。另外各种MQ提供的负载均衡、消费模式、消息延迟、消息过滤、事务等可以满足各种复杂的业务场景，也是Redis无法实现的。</p><p>最后Redis的发布订阅完全基于内存操作，不过目前流行的MQ都会尽可能的将磁盘IO进行顺序读写，性能不会拉开太多差距，另外还可以通过增加队列来均摊压力，不考虑运维成本的情况下，性能也是优于Redis的。总体上说Redis发布订阅可以满足的场景，各种MQ都可以满足，因此在已经有MQ中间件的前提下，尽量不要考虑Redis的发布订阅。</p><h2 id="6-应用场景"><a href="#6-应用场景" class="headerlink" title="6.应用场景"></a>6.应用场景</h2><p>Redis内部的哨兵集群模式在相互监控的时候使用了此功能进行通信。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存中间件 </category>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis(六) RedisTemplate客户端</title>
      <link href="2021/02/05/Redis-RedisTemplate%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>2021/02/05/Redis-RedisTemplate%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RedisTemplate客户端是spring对底层依赖Jedis、Lettuce的高度封装，在Springboot1.X版本默认使用Jedis进行自动装配，在Springboot2.X版本默认使用Lettuce进行自动装配。</p><h2 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1.依赖"></a>1.依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-序列化"><a href="#2-序列化" class="headerlink" title="2.序列化"></a>2.序列化</h2><h3 id="2-1-序列化对象"><a href="#2-1-序列化对象" class="headerlink" title="2.1 序列化对象"></a>2.1 序列化对象</h3><p>RedisTemplate客户端在存取数据时，并不需要像Jedis、Lettuce那样通过硬代码手动序列化(比如json、java serialization等)，spring提供了多种序列化对象，然后通过代码配置的方式制定序列化器:</p><ul><li>GenericToStringSerializer(可以将任何对象泛化为字符串并序列化)</li><li>JacksonJsonRedisSerializer(序列化object对象为json字符串)</li><li>Jackson2JsonRedisSerializer(和JacksonJsonRedisSerializer一样)</li><li>JdkSerializationRedisSerializer(序列化java对象，需要实现Serializable接口)</li><li>StringRedisSerializer(简单的字符串序列化)</li></ul><h3 id="2-2-性能对比"><a href="#2-2-性能对比" class="headerlink" title="2.2 性能对比"></a>2.2 性能对比</h3><p>JdkSerializationRedisSerializer属于JDK原生序列化对象，效率自然是最快的，缺点是序列化后的结果字符串最长，也就意味着占用内存相对多点。Jackson2JsonRedisSerializer是将数据转化为json字符串，需要解析结构因此最慢，但生成的字符串结果较为紧凑。</p><h2 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3.配置文件"></a>3.配置文件</h2><p>由于Redis依赖基于springboot的自动装配，所以只需要配置文件参数即可。</p><h3 id="3-1-单机版"><a href="#3-1-单机版" class="headerlink" title="3.1 单机版"></a>3.1 单机版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># redis数据库索引</span><br><span class="line">spring.redis.database&#x3D;0</span><br><span class="line"></span><br><span class="line"># redis服务器IP</span><br><span class="line">spring.redis.host&#x3D;127.0.0.1</span><br><span class="line"></span><br><span class="line"># redis服务器端口</span><br><span class="line">spring.redis.port&#x3D;6379</span><br><span class="line"></span><br><span class="line"># redis服务器密码</span><br><span class="line">spring.redis.password&#x3D;abcdef</span><br><span class="line"></span><br><span class="line">#连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">jedis.pool.max-active&#x3D;8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">jedis.pool.max-wait&#x3D;-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">jedis.pool.max-idle&#x3D;8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">jedis.pool.min-idle&#x3D;8</span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">jedis.pool.timeout&#x3D;10000</span><br></pre></td></tr></table></figure><h3 id="3-2-主从版"><a href="#3-2-主从版" class="headerlink" title="3.2 主从版"></a>3.2 主从版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># redis数据库索引</span><br><span class="line">spring.redis.database&#x3D;0</span><br><span class="line"></span><br><span class="line"># redis服务器IP</span><br><span class="line">spring.redis.host&#x3D;127.0.0.1</span><br><span class="line"></span><br><span class="line"># redis服务器端口</span><br><span class="line">spring.redis.port&#x3D;6379</span><br><span class="line"></span><br><span class="line"># redis服务器密码</span><br><span class="line">spring.redis.password&#x3D;abcdef</span><br><span class="line"></span><br><span class="line">#连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">jedis.pool.max-active&#x3D;8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">jedis.pool.max-wait&#x3D;-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">jedis.pool.max-idle&#x3D;8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">jedis.pool.min-idle&#x3D;8</span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">jedis.pool.timeout&#x3D;10000</span><br></pre></td></tr></table></figure><h3 id="3-3-哨兵版"><a href="#3-3-哨兵版" class="headerlink" title="3.3 哨兵版"></a>3.3 哨兵版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># redis数据库索引</span><br><span class="line">spring.redis.database&#x3D;0</span><br><span class="line"></span><br><span class="line"># redis服务器IP</span><br><span class="line">spring.redis.host&#x3D;127.0.0.1</span><br><span class="line"></span><br><span class="line"># redis服务器端口</span><br><span class="line">spring.redis.port&#x3D;6379</span><br><span class="line"></span><br><span class="line"># redis服务器密码</span><br><span class="line">spring.redis.password&#x3D;abcdef</span><br><span class="line"></span><br><span class="line">#连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">jedis.pool.max-active&#x3D;8</span><br><span class="line"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">jedis.pool.max-wait&#x3D;-1</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">jedis.pool.max-idle&#x3D;8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">jedis.pool.min-idle&#x3D;8</span><br><span class="line"># 连接超时时间（毫秒）</span><br><span class="line">jedis.pool.timeout&#x3D;10000</span><br></pre></td></tr></table></figure><h3 id="3-4-集群版"><a href="#3-4-集群版" class="headerlink" title="3.4 集群版"></a>3.4 集群版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># redis数据库索引</span><br><span class="line">spring.redis.database&#x3D;0</span><br><span class="line"></span><br><span class="line"># redis集群节点</span><br><span class="line">spring.redis.cluster.nodes&#x3D;175.24.30.43:7000,175.24.30.43:7001,175.24.30.43:7002</span><br><span class="line"></span><br><span class="line"># 最大重定向次数(默认5)</span><br><span class="line">spring.redis.cluster.max-redirects&#x3D;3</span><br><span class="line"></span><br><span class="line"># redis服务器密码</span><br><span class="line">spring.redis.password&#x3D;paxos1990..</span><br><span class="line"></span><br><span class="line"># 连接池最大连接数(默认8)</span><br><span class="line">spring.redis.jedis.pool.max-active&#x3D;8</span><br><span class="line"></span><br><span class="line"># 连接池最大空闲连接(默认8)</span><br><span class="line">spring.redis.jedis.pool.max-idle&#x3D;8</span><br><span class="line"></span><br><span class="line"># 连接池的最小空闲连接(默认0)</span><br><span class="line">spring.redis.jedis.pool.min-idle&#x3D;0</span><br><span class="line"></span><br><span class="line"># 连接池最大阻塞等待时间(默认-1，表示没有限制)</span><br><span class="line">spring.redis.jedis.pool.max-wait&#x3D;-1</span><br></pre></td></tr></table></figure><h2 id="4-客户端对象"><a href="#4-客户端对象" class="headerlink" title="4.客户端对象"></a>4.客户端对象</h2><h3 id="4-1-StringRedisTemplate"><a href="#4-1-StringRedisTemplate" class="headerlink" title="4.1 StringRedisTemplate"></a>4.1 StringRedisTemplate</h3><p>如果你对redis的操作仅涉及到字符串类型，那么直接使用Spring提供的StringRedisTemplate类即可，此类内部使用StringRedisSerializer序列化，代码方面直接注入:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> StringRedisTemplate stringRedisTemplate;</span><br></pre></td></tr></table></figure><h3 id="4-2-自定义RedisTemplate"><a href="#4-2-自定义RedisTemplate" class="headerlink" title="4.2 自定义RedisTemplate"></a>4.2 自定义RedisTemplate</h3><p>通常的项目中不可能只用Redis来存储字符串，也不可能把所有对象一股脑转成Json字符串存储，因此需要额外注入一个RedisTemplate用于对象的存储，并且可以针对不同的数据结构设置不同的序列化规则，配置如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对hash类型的数据操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> hash操作对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HashOperations&lt;String, String, Object&gt; <span class="title">hashOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对redis字符串类型数据操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字符串操作对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ValueOperations&lt;String, Object&gt; <span class="title">valueOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对链表类型的数据操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> list操作对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListOperations&lt;String, Object&gt; <span class="title">listOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对无序集合类型的数据操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> set操作对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SetOperations&lt;String, Object&gt; <span class="title">setOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对有序集合类型的数据操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> zset操作对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ZSetOperations&lt;String, Object&gt; <span class="title">zSetOperations</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Springboot自动装配"><a href="#5-Springboot自动装配" class="headerlink" title="5.Springboot自动装配"></a>5.Springboot自动装配</h2><h3 id="5-1-自动装配类"><a href="#5-1-自动装配类" class="headerlink" title="5.1 自动装配类"></a>5.1 自动装配类</h3><p><img src="/2021/02/05/Redis-RedisTemplate%E5%AE%A2%E6%88%B7%E7%AB%AF/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%B1%BB.jpeg" class="lazyload" data-srcset="/2021/02/05/Redis-RedisTemplate%E5%AE%A2%E6%88%B7%E7%AB%AF/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%B1%BB.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>从RedisTemplate的自动装配类可以看出来，Springboot会自动向IOC注入RedisTemplate、StringRedisTemplate俩个类，但都是有前提条件且注入的操作都比较粗糙，很多属性都没有设置，<span class="p red">所以这俩个类的注入只会在你没有手动注入的情况下生效。</span></p><p>另外RedisTemplate底层依赖Lettuce或Jedis，至于使用哪个完全依赖配置方法中的参数RedisConnectionFactory，这个类有<span class="p blue">LettuceConnectionConfiguration</span>、<span class="p blue">JedisConnectionConfiguration</span>俩个实现类，分别对应Lettuce和Jedis俩个客户端。</p><h3 id="5-2-默认底层依赖"><a href="#5-2-默认底层依赖" class="headerlink" title="5.2 默认底层依赖"></a>5.2 默认底层依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lettuce客户端 连接配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;RedisClient.class&#125;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LettuceConnectionConfiguration</span> <span class="keyword">extends</span> <span class="title">RedisConnectionConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(&#123;RedisConnectionFactory.class&#125;)</span></span><br><span class="line">    <span class="function">LettuceConnectionFactory <span class="title">redisConnectionFactory</span><span class="params">(ObjectProvider&lt;LettuceClientConfigurationBuilderCustomizer&gt; builderCustomizers, ClientResources clientResources)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        LettuceClientConfiguration clientConfig = <span class="keyword">this</span>.getLettuceClientConfiguration(builderCustomizers, clientResources, <span class="keyword">this</span>.getProperties().getLettuce().getPool());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.createLettuceConnectionFactory(clientConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Jedis客户端 连接配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;GenericObjectPool.class, JedisConnection.class, Jedis.class&#125;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JedisConnectionConfiguration</span> <span class="keyword">extends</span> <span class="title">RedisConnectionConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(&#123;RedisConnectionFactory.class&#125;)</span></span><br><span class="line">    <span class="function">JedisConnectionFactory <span class="title">redisConnectionFactory</span><span class="params">(ObjectProvider&lt;JedisClientConfigurationBuilderCustomizer&gt; builderCustomizers)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.createJedisConnectionFactory(builderCustomizers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，Springboot会将这俩个客户端的配置类都尝试注册IOC(包括包含的RedisConnectionFactory)，但是在Springboot2.X版本里默认只包含Lettuce的依赖，所以在<span class="p blue">@ConditionalOnClass</span>的注入限制条件下，默认使用的是Lettuce客户端。</p><h3 id="5-3-Springboot2-X使用Jedis"><a href="#5-3-Springboot2-X使用Jedis" class="headerlink" title="5.3 Springboot2.X使用Jedis"></a>5.3 Springboot2.X使用Jedis</h3><p>如果想要在Springboot2.X的RedisTemplate使用Jedis客户端实现，就需要对依赖进行处理，排除包含的Lettuce依赖，再添加Jedis依赖。这样Lettuce注入时，就无法满足@ConditionalOnClass的条件，而Jedis正好满足。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">    &lt;!-- 排除lettuce依赖 --&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p class="p red">注:Springboot1.X版本仅支持Jedis底层依赖，有兴趣可以自己看源码。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存中间件 </category>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis(五) Lettuce客户端</title>
      <link href="2021/02/05/Redis-Lettuce%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>2021/02/05/Redis-Lettuce%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Lettuce客户端是一个线程安全的客户端，通信方式上基于netty，保证多个线程共享一个连接对象也不会存在线程安全问题，并且连接实例数量上支持可伸缩设计，一个连接达到上限后会按需增加连接实例。另外Lettuce客户端还支持异步请求方式、全局命令超时设置等特性。</p><p class="p red">注意: 使用Lettuce客户端，Redis的版本至少2.6</p><h2 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1.依赖"></a>1.依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.lettuce&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lettuce-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.8.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.4.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p class="p red">Lettuce客户端因为不存在单个连接对象的线程安全问题，因此在连接池使用方面没有强制要求。如果请求频率不是很高，完全可以创建单个连接对象，毕竟Redis服务端处理命令是单线程执行，创建多个物理连接也是无意义的消耗资源。</p><h2 id="2-单机版配置"><a href="#2-单机版配置" class="headerlink" title="2.单机版配置"></a>2.单机版配置</h2><h3 id="2-1-配置文件"><a href="#2-1-配置文件" class="headerlink" title="2.1 配置文件"></a>2.1 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># IP地址</span><br><span class="line">spring.lettuce.host&#x3D;127.0.0.1</span><br><span class="line"></span><br><span class="line"># 端口</span><br><span class="line">spring.lettuce.port&#x3D;6379</span><br><span class="line"></span><br><span class="line"># 连接密码</span><br><span class="line">spring.lettuce.password&#x3D;123456</span><br><span class="line"></span><br><span class="line"># 连接超时时间</span><br><span class="line">spring.lettuce.timeout&#x3D;2000</span><br><span class="line"></span><br><span class="line"># 连接池最大连接数(使用负值表示没有限制)</span><br><span class="line">spring.lettuce.pool.max-total&#x3D;200</span><br><span class="line"></span><br><span class="line"># 连接池最大空闲连接</span><br><span class="line">spring.lettuce.pool.max-idle&#x3D;10</span><br><span class="line"></span><br><span class="line"># 连接池最小空闲连接</span><br><span class="line">spring.lettuce.max-idle&#x3D;5</span><br></pre></td></tr></table></figure><h3 id="2-2-Java配置类"><a href="#2-2-Java配置类" class="headerlink" title="2.2 Java配置类"></a>2.2 Java配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LettuceConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.lettuce.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.pool.min-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.pool.max-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.pool.max-total&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatefulRedisConnection&lt;String, String&gt; <span class="title">statefulRedisConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要连接的服务器信息</span></span><br><span class="line">RedisURI redisUri = RedisURI.builder()</span><br><span class="line">.withHost(host)</span><br><span class="line">.withPort(port)</span><br><span class="line">.withPassword(password)</span><br><span class="line">.withTimeout(Duration.of(timeout, ChronoUnit.SECONDS))</span><br><span class="line">.build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建客户端对象</span></span><br><span class="line">RedisClient redisClient = RedisClient.create(redisUri);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接池对象</span></span><br><span class="line"><span class="keyword">return</span> client.connect();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> GenericObjectPool&lt;StatefulRedisConnection&lt;String, String&gt;&gt; genericObjectPool()&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要连接的服务器信息</span></span><br><span class="line">RedisURI redisUri = RedisURI.builder()</span><br><span class="line">            .withHost(host)</span><br><span class="line">            .withPort(port)</span><br><span class="line">            .withPassword(password)</span><br><span class="line">            .withTimeout(Duration.of(timeout, ChronoUnit.SECONDS))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接池配置信息</span></span><br><span class="line">        GenericObjectPoolConfig poolConfig = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line">        genericObjectPoolConfig.setMinIdle(minIdle);</span><br><span class="line">        genericObjectPoolConfig.setMaxIdle(maxIdle);</span><br><span class="line">        genericObjectPoolConfig.setMaxTotal(maxTotal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">RedisClient redisClient = RedisClient.create(redisUri);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接对象pool</span></span><br><span class="line"><span class="keyword">return</span> ConnectionPoolSupport.createGenericObjectPool(() -&gt; client.connect(), poolConfig);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-主从版配置"><a href="#3-主从版配置" class="headerlink" title="3.主从版配置"></a>3.主从版配置</h2><h3 id="3-1-配置文件"><a href="#3-1-配置文件" class="headerlink" title="3.1 配置文件"></a>3.1 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># IP地址</span><br><span class="line">spring.lettuce.host&#x3D;127.0.0.1</span><br><span class="line"></span><br><span class="line"># 端口</span><br><span class="line">spring.lettuce.port&#x3D;6379</span><br><span class="line"></span><br><span class="line"># 连接密码</span><br><span class="line">spring.lettuce.password&#x3D;123456</span><br><span class="line"></span><br><span class="line"># 连接超时时间</span><br><span class="line">spring.lettuce.timeout&#x3D;2000</span><br><span class="line"></span><br><span class="line"># 连接池最大连接数(使用负值表示没有限制)</span><br><span class="line">spring.lettuce.pool.max-total&#x3D;200</span><br><span class="line"></span><br><span class="line"># 连接池最大空闲连接</span><br><span class="line">spring.lettuce.pool.max-idle&#x3D;10</span><br><span class="line"></span><br><span class="line"># 连接池最小空闲连接</span><br><span class="line">spring.lettuce.max-idle&#x3D;5</span><br></pre></td></tr></table></figure><h3 id="3-2-Java配置类"><a href="#3-2-Java配置类" class="headerlink" title="3.2 Java配置类"></a>3.2 Java配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LettuceConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.lettuce.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.pool.min-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.pool.max-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.pool.max-total&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatefulRedisMasterSlaveConnection&lt;String, String&gt; <span class="title">statefulRedisConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要连接的服务器信息, 主节点、从节点都可以 </span></span><br><span class="line">RedisURI redisUri = RedisURI.builder()</span><br><span class="line">            .withHost(host)</span><br><span class="line">            .withPort(port)</span><br><span class="line">            .withPassword(password)</span><br><span class="line">            .withTimeout(Duration.of(timeout, ChronoUnit.SECONDS))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        RedisClient redisClient = RedisClient.create(redisUri); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意节点最终都能获取到，涉及的所有相关节点信息</span></span><br><span class="line">StatefulRedisMasterSlaveConnection&lt;String, String&gt; connection = MasterSlave.connect(redisClient, <span class="keyword">new</span> Utf8StringCodec(), redisUri);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只从主节点读取数据(读写分离设置成ReadFrom.SLAVE即可)</span></span><br><span class="line">connection.setReadFrom(ReadFrom.MASTER);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> GenericObjectPool&lt;StatefulRedisMasterSlaveConnection&lt;String, String&gt;&gt; genericObjectPool()&#123;</span><br><span class="line"><span class="comment">// 参考单机模式连接池配置...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不想通过任意节点获取所有主从节点信息，可以通过代码固定设置要连接的节点集合:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatefulRedisMasterSlaveConnection&lt;String, String&gt; <span class="title">statefulRedisConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 固定节点集合</span></span><br><span class="line">List&lt;RedisURI&gt; uris = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">uris.add(RedisURI.builder().withHost(host1).withPort(port1).build());</span><br><span class="line">uris.add(RedisURI.builder().withHost(host2).withPort(port2).build());</span><br><span class="line">uris.add(RedisURI.builder().withHost(host3).withPort(port3).build());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建客户端 </span></span><br><span class="line">RedisClient redisClient = RedisClient.create();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建连接对象</span></span><br><span class="line">StatefulRedisMasterSlaveConnection&lt;String, String&gt; connection = MasterSlave.connect(redisClient,</span><br><span class="line">            <span class="keyword">new</span> Utf8StringCodec(), uris);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置读写分离</span></span><br><span class="line">connection.setReadFrom(ReadFrom.MASTER);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-哨兵版配置"><a href="#4-哨兵版配置" class="headerlink" title="4.哨兵版配置"></a>4.哨兵版配置</h2><h3 id="4-1-配置文件"><a href="#4-1-配置文件" class="headerlink" title="4.1 配置文件"></a>4.1 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 哨兵IP地址</span><br><span class="line">spring.lettuce.sentinel.host&#x3D;127.0.0.1</span><br><span class="line"></span><br><span class="line"># 哨兵端口</span><br><span class="line">spring.lettuce.sentinel.port&#x3D;26379</span><br><span class="line"></span><br><span class="line"># masterId</span><br><span class="line">spring.lettuce.sentinel.master.id&#x3D;master</span><br><span class="line"></span><br><span class="line"># 连接密码</span><br><span class="line">spring.lettuce.password&#x3D;123456</span><br><span class="line"></span><br><span class="line"># 连接超时时间</span><br><span class="line">spring.lettuce.timeout&#x3D;2000</span><br><span class="line"></span><br><span class="line"># 连接池最大连接数(使用负值表示没有限制)</span><br><span class="line">spring.lettuce.pool.max-total&#x3D;200</span><br><span class="line"></span><br><span class="line"># 连接池最大空闲连接</span><br><span class="line">spring.lettuce.pool.max-idle&#x3D;10</span><br><span class="line"></span><br><span class="line"># 连接池最小空闲连接</span><br><span class="line">spring.lettuce.max-idle&#x3D;5</span><br></pre></td></tr></table></figure><h3 id="4-2-Java配置类"><a href="#4-2-Java配置类" class="headerlink" title="4.2 Java配置类"></a>4.2 Java配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LettuceConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.lettuce.sentinel.host&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String sentinelHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.sentinel.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sentinelPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.pool.min-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.pool.max-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.pool.max-total&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatefulRedisMasterSlaveConnection&lt;String, String&gt; <span class="title">statefulRedisConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lettuce提供了哨兵的拓扑发现机制，仅需要配置一个哨兵节点即可得到所有相关节点信息</span></span><br><span class="line">RedisURI redisUri = RedisURI.builder()</span><br><span class="line">.withPassword(password)</span><br><span class="line">.withSentinel(sentinelHost, sentinelPort);</span><br><span class="line">.withSentinelMasterId(masterId);</span><br><span class="line">.build();</span><br><span class="line"></span><br><span class="line">RedisClient redisClient = RedisClient.create();</span><br><span class="line">StatefulRedisMasterSlaveConnection&lt;String, String&gt; connection = MasterSlave.connect(redisClient, <span class="keyword">new</span> Utf8StringCodec(), redisUri);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写分离设置</span></span><br><span class="line">    connection.setReadFrom(ReadFrom.SLAVE);</span><br><span class="line"><span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> GenericObjectPool&lt;StatefulRedisMasterSlaveConnection&lt;String, String&gt;&gt; genericObjectPool()&#123;</span><br><span class="line"><span class="comment">// 参考单机模式连接池配置...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-集群版配置"><a href="#5-集群版配置" class="headerlink" title="5.集群版配置"></a>5.集群版配置</h2><h3 id="5-1-配置文件"><a href="#5-1-配置文件" class="headerlink" title="5.1 配置文件"></a>5.1 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 集群节点</span><br><span class="line">spring.lettuce.cluster.nodes&#x3D;127.0.0.1:7001,127.0.0.2:7001,127.0.0.3:7001</span><br><span class="line"></span><br><span class="line"># 连接密码</span><br><span class="line">spring.lettuce.password&#x3D;123456</span><br><span class="line"></span><br><span class="line"># 连接超时时间</span><br><span class="line">spring.lettuce.timeout&#x3D;2000</span><br><span class="line"></span><br><span class="line"># 连接池最大连接数(使用负值表示没有限制)</span><br><span class="line">spring.lettuce.pool.max-total&#x3D;200</span><br><span class="line"></span><br><span class="line"># 连接池最大空闲连接</span><br><span class="line">spring.lettuce.pool.max-idle&#x3D;10</span><br><span class="line"></span><br><span class="line"># 连接池最小空闲连接</span><br><span class="line">spring.lettuce.max-idle&#x3D;5</span><br></pre></td></tr></table></figure><h3 id="5-2-Java配置类"><a href="#5-2-Java配置类" class="headerlink" title="5.2 Java配置类"></a>5.2 Java配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LettuceConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;#&#123;&#x27;$&#123;spring.lettuce.cluster.nodes&#125;&#x27;.split(&#x27;,&#x27;)&#125;&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; clusterList;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.lettuce.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.pool.min-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.pool.max-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.lettuce.pool.max-total&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatefulRedisClusterConnection&lt;String, String&gt; <span class="title">statefulRedisConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定所有主节点，也可以随便指定一个节点，lettuce会通过拓扑机制发现所有节点</span></span><br><span class="line">ArrayList&lt;RedisURI&gt; redisUriList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(String cluster : clusterList)&#123;</span><br><span class="line">String[] hostPort = cluster.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">String host = hostPort[<span class="number">0</span>];</span><br><span class="line">Integer port = Integer.valueOf(hostPort[<span class="number">1</span>]);</span><br><span class="line">redisUriList.add(RedisURI.builder().withHost(host).withPort(port).withPassword(password).build());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立客户端</span></span><br><span class="line">RedisClusterClient redisClusterClient = RedisClusterClient.create(redisUriList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时更新集群的拓扑信息，这里设置10分钟更新一次</span></span><br><span class="line">ClusterTopologyRefreshOptions options = ClusterTopologyRefreshOptions</span><br><span class="line">            .builder()</span><br><span class="line">            .enablePeriodicRefresh(Duration.of(<span class="number">10</span>, ChronoUnit.MINUTES))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将更新规则设置到客户端对象</span></span><br><span class="line">    redisClusterClient.setOptions(ClusterClientOptions.builder().topologyRefreshOptions(options).build());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立连接      </span></span><br><span class="line">StatefulRedisClusterConnection&lt;String, String&gt; connection = redisClusterClient.connect();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写分离设置</span></span><br><span class="line">    connection.setReadFrom(ReadFrom.SLAVE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> GenericObjectPool&lt;StatefulRedisClusterConnection&lt;String, String&gt;&gt; genericObjectPool()&#123;</span><br><span class="line"><span class="comment">// 参考单机模式连接池配置...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-基本使用"><a href="#6-基本使用" class="headerlink" title="6.基本使用"></a>6.基本使用</h2><h3 id="6-1-同步使用"><a href="#6-1-同步使用" class="headerlink" title="6.1 同步使用"></a>6.1 同步使用</h3><p>同步的使用方式就和普通的方法调用一样:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LettuceCommands</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StatefulRedisClusterConnection clusterConnection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RedisAdvancedClusterCommands&lt;String, String&gt; commands;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRedisCommands</span><span class="params">()</span></span>&#123;</span><br><span class="line">commands = clusterConnection.sync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String value)</span></span>&#123;</span><br><span class="line">commands.set(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String value)</span></span>&#123;</span><br><span class="line"><span class="comment">// nx()代表键不存在才会设置，xx()代表键存在才会设置；ex()代表过期时间单位为秒，px代表毫秒</span></span><br><span class="line">SetArgs setArgs = SetArgs.Builder.nx().ex(<span class="number">5</span>);</span><br><span class="line">commands.set(key, value, setArgs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> commands.get(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-异步使用"><a href="#6-2-异步使用" class="headerlink" title="6.2 异步使用"></a>6.2 异步使用</h3><p>异步调用就像使用Java自带的线程FutureTask一样，调用后立即返回RedisFuture对象，并通过调用get()方法阻塞获取返回值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LettuceCommands</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StatefulRedisClusterConnection clusterConnection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RedisAdvancedClusterAsyncCommands&lt;String, String&gt; commands;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initRedisCommands</span><span class="params">()</span></span>&#123;</span><br><span class="line">commands = clusterConnection.async();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisFuture&lt;String&gt; <span class="title">set</span><span class="params">(String key, String value)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> commands.set(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisFuture&lt;String&gt; <span class="title">set</span><span class="params">(String key, String value)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> commands.set(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisFuture&lt;String&gt; <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commands.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-反应式使用"><a href="#6-3-反应式使用" class="headerlink" title="6.3 反应式使用"></a>6.3 反应式使用</h3><p>Lettuce的反应式基于编程框架Project Reactor，暂时没看懂。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存中间件 </category>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis(四) Jedis客户端</title>
      <link href="2021/02/05/Redis-Jedis%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>2021/02/05/Redis-Jedis%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Jedis客户端提供的API比较全面，方法名与redis的命令名非常相似，了解redis的命令也就能熟练使用Jedis客户端。由于提供的功能偏低层，springboot不支持依赖自动装配，且存取对象需要自己手动组装或转化，因此很少有直接使用jedis。</p><h2 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1.依赖"></a>1.依赖</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-单机版配置"><a href="#2-单机版配置" class="headerlink" title="2.单机版配置"></a>2.单机版配置</h2><h3 id="1-1-配置文件"><a href="#1-1-配置文件" class="headerlink" title="1.1 配置文件"></a>1.1 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># IP地址</span><br><span class="line">spring.jedis.host&#x3D;127.0.0.1</span><br><span class="line"></span><br><span class="line"># 端口</span><br><span class="line">spring.jedis.port&#x3D;6379</span><br><span class="line"></span><br><span class="line"># 连接密码</span><br><span class="line">spring.jedis.password&#x3D;123456</span><br><span class="line"></span><br><span class="line"># 连接超时时间</span><br><span class="line">spring.jedis.timeout&#x3D;2000</span><br><span class="line"></span><br><span class="line"># 连接池最大连接数(使用负值表示没有限制)</span><br><span class="line">spring.jedis.pool.max-total&#x3D;200</span><br><span class="line"></span><br><span class="line"># 连接池最大空闲连接</span><br><span class="line">spring.jedis.pool.max-idle&#x3D;10</span><br><span class="line"></span><br><span class="line"># 连接池最小空闲连接</span><br><span class="line">spring.jedis.max-idle&#x3D;5</span><br><span class="line"></span><br><span class="line"># 获取连接最大等待时间</span><br><span class="line">spring.jedis.max-wait-millis&#x3D;10000</span><br></pre></td></tr></table></figure><h3 id="1-2-Java配置类"><a href="#1-2-Java配置类" class="headerlink" title="1.2 Java配置类"></a>1.2 Java配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisConfig</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.pool.max-total&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.pool.max-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.pool.min-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.max-wait-millis&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxWaitMillis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisPool <span class="title">jedisPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(maxTotal);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(maxIdle);</span><br><span class="line">        jedisPoolConfig.setMinIdle(minIdle);</span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JedisPool(jedisPoolConfig,host,port,timeout,password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-读写分离"><a href="#1-3-读写分离" class="headerlink" title="1.3 读写分离"></a>1.3 读写分离</h3><p>单机、主从运行模式都是连接固定服务器地址，因此实现读写分只需要创建两个JedisPool即可。</p><h2 id="2-哨兵版配置"><a href="#2-哨兵版配置" class="headerlink" title="2.哨兵版配置"></a>2.哨兵版配置</h2><h3 id="2-1-配置文件"><a href="#2-1-配置文件" class="headerlink" title="2.1 配置文件"></a>2.1 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 哨兵节点</span><br><span class="line">spring.jedis.sentinel.nodes&#x3D;127.0.0.1:26379,127.0.0.2:26379,127.0.0.3:26379</span><br><span class="line"></span><br><span class="line"># 哨兵主节点名称，用于指定连接的某个主从组合</span><br><span class="line">spring.jedis.sentinel.master.name&#x3D;abc</span><br><span class="line"></span><br><span class="line"># 连接密码</span><br><span class="line">spring.jedis.password&#x3D;123456</span><br><span class="line"></span><br><span class="line"># 连接超时时间</span><br><span class="line">spring.jedis.timeout&#x3D;2000</span><br><span class="line"></span><br><span class="line"># 连接池最大连接数(使用负值表示没有限制)</span><br><span class="line">spring.jedis.pool.max-total&#x3D;200</span><br><span class="line"></span><br><span class="line"># 连接池最大空闲连接</span><br><span class="line">spring.jedis.pool.max-idle&#x3D;10</span><br><span class="line"></span><br><span class="line"># 连接池最小空闲连接</span><br><span class="line">spring.jedis.max-idle&#x3D;5</span><br><span class="line"></span><br><span class="line"># 获取连接最大等待时间</span><br><span class="line">spring.jedis.max-wait-millis&#x3D;10000</span><br></pre></td></tr></table></figure><h3 id="2-1-Java配置类"><a href="#2-1-Java配置类" class="headerlink" title="2.1 Java配置类"></a>2.1 Java配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;$&#123;spring.jedis.sentinel.nodes&#125;&#x27;.split(&#x27;,&#x27;)&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; nodeList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.sentinel.master.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String masterName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.pool.max-total&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.pool.max-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.pool.min-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.max-wait-millis&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxWaitMillis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisSentinelPool <span class="title">jedisPoolConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接池参数</span></span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(maxTotal);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(maxIdle);</span><br><span class="line">        jedisPoolConfig.setMinIdle(minIdle);</span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 哨兵节点</span></span><br><span class="line">        Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;(nodeList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哨兵连接池</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JedisSentinelPool(masterName, sentinels, jedisPoolConfig, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-感知节点变化"><a href="#2-3-感知节点变化" class="headerlink" title="2.3 感知节点变化"></a>2.3 感知节点变化</h3><p>哨兵模式的配置中，JedisSentinelPool对象的构造器会为每个masterName下的每个sentinel节点开启一个线程，通过pub/sub模式订阅master节点的变化，接收到变化信息后重置jedis连接池信息。</p><p>监听器为JedisSentinelPool的内部类MasterListener，线程的run()源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.设置线程正常运行</span></span><br><span class="line">    <span class="keyword">this</span>.running.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.正常运行情况下，进入循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.running.get()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.通过哨兵IP、端口与服务器建立连接</span></span><br><span class="line">        <span class="keyword">this</span>.j = <span class="keyword">new</span> Jedis(<span class="keyword">this</span>.host, <span class="keyword">this</span>.port);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.再次判断是否满足运行条件</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.running.get()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.订阅master节点变化频道</span></span><br><span class="line">            <span class="keyword">this</span>.j.subscribe(<span class="keyword">new</span> JedisPubSub() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 订阅到消息后的处理逻辑</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String channel, String message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 打印日志</span></span><br><span class="line">                    JedisSentinelPool.<span class="keyword">this</span>.log.fine(<span class="string">&quot;Sentinel &quot;</span> + MasterListener.<span class="keyword">this</span>.host + <span class="string">&quot;:&quot;</span> + MasterListener.<span class="keyword">this</span>.port + <span class="string">&quot; published: &quot;</span> + message + <span class="string">&quot;.&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 5.1 解析订阅返回的消息字符串，格式:</span></span><br><span class="line">                    String[] switchMasterMsg = message.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 5.2 分割后的数据长度小于3代表正常格式，大于等于3代表无效返回结果</span></span><br><span class="line">                    <span class="keyword">if</span> (switchMasterMsg.length &gt; <span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 5.3 再次判断masterName是否为自己监听的，估计是怕乱传数据</span></span><br><span class="line">                        <span class="keyword">if</span> (MasterListener.<span class="keyword">this</span>.masterName.equals(switchMasterMsg[<span class="number">0</span>])) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 5.4 提取新master节点的IP、端口，作为参数调用initPool()方法重置连接</span></span><br><span class="line">                            JedisSentinelPool.<span class="keyword">this</span>.initPool(JedisSentinelPool.<span class="keyword">this</span>.toHostAndPort(Arrays.asList(switchMasterMsg[<span class="number">3</span>], switchMasterMsg[<span class="number">4</span>])));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            JedisSentinelPool.<span class="keyword">this</span>.log.fine(<span class="string">&quot;Ignoring message on +switch-master for master name &quot;</span> + switchMasterMsg[<span class="number">0</span>] + <span class="string">&quot;, our master name is &quot;</span> + MasterListener.<span class="keyword">this</span>.masterName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        JedisSentinelPool.<span class="keyword">this</span>.log.severe(<span class="string">&quot;Invalid message received on Sentinel &quot;</span> + MasterListener.<span class="keyword">this</span>.host + <span class="string">&quot;:&quot;</span> + MasterListener.<span class="keyword">this</span>.port + <span class="string">&quot; on channel +switch-master: &quot;</span> + message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// &quot;+switch-master&quot;，就是订阅的channel名称</span></span><br><span class="line">            &#125;, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;+switch-master&quot;</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisConnectionException var8) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6.如果发生连接异常，且监听逻辑仍然允许运行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.running.get()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 打印日志</span></span><br><span class="line">                JedisSentinelPool.<span class="keyword">this</span>.log.log(Level.SEVERE, <span class="string">&quot;Lost connection to Sentinel at &quot;</span> + <span class="keyword">this</span>.host + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.port + <span class="string">&quot;. Sleeping 5000ms and retrying.&quot;</span>, var8);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7.暂停固定时间后，进入下次while循环继续监听</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="keyword">this</span>.subscribeRetryWaitTimeMillis);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException var7) &#123;</span><br><span class="line">                        JedisSentinelPool.<span class="keyword">this</span>.log.log(Level.SEVERE, <span class="string">&quot;Sleep interrupted: &quot;</span>, var7);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                JedisSentinelPool.<span class="keyword">this</span>.log.fine(<span class="string">&quot;Unsubscribing from Sentinel at &quot;</span> + <span class="keyword">this</span>.host + <span class="string">&quot;:&quot;</span> + <span class="keyword">this</span>.port);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 8.关闭连接</span></span><br><span class="line">            <span class="keyword">this</span>.j.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看initPool()方法源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPool</span><span class="params">(HostAndPort master)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有订阅返回的master信息，与当前的不一致，才会进行重置</span></span><br><span class="line">    <span class="keyword">if</span> (!master.equals(<span class="keyword">this</span>.currentHostMaster)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新赋值当前master节点指向实例</span></span><br><span class="line">        <span class="keyword">this</span>.currentHostMaster = master;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置Jedis工厂信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.factory = <span class="keyword">new</span> JedisFactory(master.getHost(), master.getPort(), <span class="keyword">this</span>.connectionTimeout, <span class="keyword">this</span>.soTimeout, <span class="keyword">this</span>.password, <span class="keyword">this</span>.database, <span class="keyword">this</span>.clientName, <span class="keyword">false</span>, (SSLSocketFactory)<span class="keyword">null</span>, (SSLParameters)<span class="keyword">null</span>, (HostnameVerifier)<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.initPool(<span class="keyword">this</span>.poolConfig, <span class="keyword">this</span>.factory);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.factory.setHostAndPort(<span class="keyword">this</span>.currentHostMaster);</span><br><span class="line">            <span class="keyword">this</span>.internalPool.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印变化日志</span></span><br><span class="line">        <span class="keyword">this</span>.log.info(<span class="string">&quot;Created JedisPool to master at &quot;</span> + master);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-读写分离"><a href="#2-4-读写分离" class="headerlink" title="2.4 读写分离"></a>2.4 读写分离</h3><p>之前在写Redis运行模式的时候有讲过，Redis服务端不支持读写分离功能，需要客户端自己去实现。然而Jedis客户端也不会自动对请求进行读写分离，具体情况还得看源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个Jedis连接对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Jedis <span class="title">getResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从池子里获取一个Jedis连接(连接池全都是master连接)</span></span><br><span class="line">        Jedis jedis = (Jedis)<span class="keyword">super</span>.getResource();</span><br><span class="line">        jedis.setDataSource(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前master信息</span></span><br><span class="line">        HostAndPort master = <span class="keyword">this</span>.currentHostMaster;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果连接池取出的Jedis连接信息，与当前master的连接一致时，才返回</span></span><br><span class="line">        HostAndPort connection = <span class="keyword">new</span> HostAndPort(jedis.getClient().getHost(), jedis.getClient().getPort());</span><br><span class="line">        <span class="keyword">if</span> (master.equals(connection)) &#123;</span><br><span class="line">            <span class="keyword">return</span> jedis;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里说明不一致，肯定是master挂掉了，选举出了新master，连接池的数据还没来得及更新，</span></span><br><span class="line">        <span class="comment">// 特殊处理后进入下次循环，确保返回的一定是master的Jedis连接</span></span><br><span class="line">        <span class="keyword">this</span>.returnBrokenResource(jedis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码可以看出，实现读写分离只能手动配置。实现方案也很简单，Jedis提供了sentinelSlaves()方法，可以通过哨兵节点获取到所有Slave节点信息，然后为每个Slave节点创建JedisPool对象，多个Slave就自己写代码实现负载均衡，另外照抄一份MasterListener类的订阅代码，及时更新从节点信息即可。</p><p>由于Jedis客户端很少直接使用，再加上Redis读写分离的应用不是很普遍，这里就不自己写代码实现了。</p><h2 id="3-集群版配置"><a href="#3-集群版配置" class="headerlink" title="3.集群版配置"></a>3.集群版配置</h2><h3 id="3-1-配置文件"><a href="#3-1-配置文件" class="headerlink" title="3.1 配置文件"></a>3.1 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 集群节点</span><br><span class="line">spring.jedis.nodes&#x3D;127.0.0.1:6379,127.0.0.2:6379,127.0.0.3:6379</span><br><span class="line"></span><br><span class="line"># 连接密码</span><br><span class="line">spring.jedis.password&#x3D;123456</span><br><span class="line"></span><br><span class="line"># 连接超时时间</span><br><span class="line">spring.jedis.timeout&#x3D;2000</span><br><span class="line"></span><br><span class="line"># 连接池最大连接数(使用负值表示没有限制)</span><br><span class="line">spring.jedis.pool.max-total&#x3D;200</span><br><span class="line"></span><br><span class="line"># 连接池最大空闲连接</span><br><span class="line">spring.jedis.pool.max-idle&#x3D;10</span><br><span class="line"></span><br><span class="line"># 连接池最小空闲连接</span><br><span class="line">spring.jedis.max-idle&#x3D;5</span><br><span class="line"></span><br><span class="line"># 获取连接最大等待时间</span><br><span class="line">spring.jedis.max-wait-millis&#x3D;10000</span><br></pre></td></tr></table></figure><h3 id="3-2-Java配置类"><a href="#3-2-Java配置类" class="headerlink" title="3.2 Java配置类"></a>3.2 Java配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.nodes&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nodes;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.pool.max-total&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.pool.max-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.pool.min-idle&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.jedis.max-wait-millis&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxWaitMillis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisCluster <span class="title">jedisCluster</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(maxTotal);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(maxIdle);</span><br><span class="line">        jedisPoolConfig.setMinIdle(minIdle);</span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);</span><br><span class="line"></span><br><span class="line">        String[] nodesArray = nodes.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        Set&lt;HostAndPort&gt; nodeSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodesArray.length; i++)&#123;</span><br><span class="line">            String[] nodeInfo = nodesArray[i].split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            String host = nodeInfo[<span class="number">0</span>];</span><br><span class="line">            Integer port = Integer.valueOf(nodeInfo[<span class="number">1</span>]);</span><br><span class="line">            nodeSet.add(<span class="keyword">new</span> HostAndPort(host, port));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JedisPool(nodeSet,timeout,jedisPoolConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-读写分离"><a href="#3-3-读写分离" class="headerlink" title="3.3 读写分离"></a>3.3 读写分离</h3><p>集群模式的读写分离，除了要考虑主节点的变化外，还需要考虑到卡槽的路由，总之实现起来较为复杂，以后有空再写吧。</p><h2 id="4-线程安全"><a href="#4-线程安全" class="headerlink" title="4.线程安全"></a>4.线程安全</h2><p>使用Jedis对象直连服务端，多线程调用情况下会造成线程安全问题。Jedis发送请求命令是通过Connection的connect()方法实现，具体源码:<br><img src="/2021/02/05/Redis-Jedis%E5%AE%A2%E6%88%B7%E7%AB%AF/connect%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.jpg" class="lazyload" data-srcset="/2021/02/05/Redis-Jedis%E5%AE%A2%E6%88%B7%E7%AB%AF/connect%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h3 id="4-1-传输流安全"><a href="#4-1-传输流安全" class="headerlink" title="4.1 传输流安全"></a>4.1 传输流安全</h3><p>源码中可以看出方法内的outputStream、inputStream均为Jedis对象的成员变量，并且俩成员变量的赋值没有任何加锁措施，这意味着多个线程同时调用一个Jedis对象发送命令时，输入输出流的值会被不停覆盖引起数据错乱，也就是出现了线程安全问题。</p><h3 id="4-2-网络连接安全"><a href="#4-2-网络连接安全" class="headerlink" title="4.2 网络连接安全"></a>4.2 网络连接安全</h3><p>在较低版本的Jedis依赖中，Socket的创建并没有单独抽成一个方法，而是写在connect()方法内部，具体源码:<br><img src="/2021/02/05/Redis-Jedis%E5%AE%A2%E6%88%B7%E7%AB%AF/%E4%BD%8E%E7%89%88%E6%9C%ACconnect%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.jpg" class="lazyload" data-srcset="/2021/02/05/Redis-Jedis%E5%AE%A2%E6%88%B7%E7%AB%AF/%E4%BD%8E%E7%89%88%E6%9C%ACconnect%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>源码中可以看出Socket对象是先创建并赋值给socket成员变量，然后再建立长连接，最后处理连接的输入输出流。假设线程A创建完Socket对象并成功建立长连接，但是还没有调用getXXStream()方法，此时线程B也执行connect方法创建Socket对象并重新赋值socket，由于线程B还没来得及建立长连接，线程A就开始调用getXXStream()方法，因此会抛出java.net.SocketException: Socket is not connected异常。</p><h3 id="4-3-解决方案"><a href="#4-3-解决方案" class="headerlink" title="4.3 解决方案"></a>4.3 解决方案</h3><p>解决线程安全的方案是通过JedisPool连接池去管理Jedis实例，线程向服务器发送redis命令时，先通过连接池获取一个Jedis实例，使用完毕后归还连接池，这样就保证了一个Jedis实例同一时刻只会被一个线程调用。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存中间件 </category>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis(三) 运行模式</title>
      <link href="2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-单机模式"><a href="#1-单机模式" class="headerlink" title="1.单机模式"></a>1.单机模式</h2><p>关于Redis单节点服务的并发性能，官方提供的数据表示读的速度为110000次/每秒,写的速度是81000次/每秒。当然，官方数据只能代表大概情况，毕竟机器内存大小、网络带宽等因素都会影响到Redis的性能，不过支撑万级并发还是没啥问题的。</p><h3 id="1-1-单机性能"><a href="#1-1-单机性能" class="headerlink" title="1.1 单机性能"></a>1.1 单机性能</h3><p>Redis自带redis-benchmark工具，可以指定参数对Redis单个服务进行并发压测，得出真实的性能数据，工具参数如下:</p><table><thead><tr><th>序号</th><th>参数项</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>1</td><td>-h</td><td>指定服务器IP或域名</td><td>127.0.0.1</td></tr><tr><td>1</td><td>-p</td><td>指定服务器端口</td><td>6379</td></tr><tr><td>1</td><td>-s</td><td>指定服务器socket</td><td>无</td></tr><tr><td>1</td><td>-c</td><td>指定并发连接数</td><td>50</td></tr><tr><td>1</td><td>-n</td><td>指定请求数</td><td>10000</td></tr><tr><td>1</td><td>-d</td><td>以字节形式指定set、get值的数据大小</td><td>2</td></tr><tr><td>1</td><td>-k</td><td>keep alive=1 reconncet=0</td><td>无</td></tr><tr><td>1</td><td>-r</td><td>set、get使用随机key，SADD使用随机值</td><td>无</td></tr><tr><td>1</td><td>-P</td><td>通过管道传输请求</td><td>1</td></tr><tr><td>1</td><td>-q</td><td>强制退出redis，没懂表达什么的</td><td>无</td></tr><tr><td>1</td><td>–csv</td><td>以csv格式输出</td><td>无</td></tr><tr><td>1</td><td>-l</td><td>生成循环，永久性执行测试</td><td>无</td></tr><tr><td>1</td><td>-t</td><td>仅运行以逗号分隔的测试命令列表</td><td>无</td></tr><tr><td>1</td><td>-I</td><td>Idle模式，仅打开N个idle连接并等待</td><td>无</td></tr></tbody></table><p>先看看官网是什么姿势:<br><img src="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E5%AE%98%E6%96%B9%E5%8E%8B%E6%B5%8B%E6%95%B0%E6%8D%AE.jpg" class="lazyload" data-srcset="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E5%AE%98%E6%96%B9%E5%8E%8B%E6%B5%8B%E6%95%B0%E6%8D%AE.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>用我阿里云服务器来一波:<br><img src="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E6%9C%AC%E5%9C%B0%E5%8E%8B%E6%B5%8B%E6%95%B0%E6%8D%AE.jpg" class="lazyload" data-srcset="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E6%9C%AC%E5%9C%B0%E5%8E%8B%E6%B5%8B%E6%95%B0%E6%8D%AE.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p class="p red">没使用管道传输请求时，和Redis官网数据差不多，加上管道参数我这小霸王服务器简直渣渣...</p><h3 id="1-2-优缺点"><a href="#1-2-优缺点" class="headerlink" title="1.2 优缺点"></a>1.2 优缺点</h3><p>没啥优点，缺点一大堆。首先不具备自动容错和恢复功能，服务器宕机或者Redis服务崩掉后只能手动干预，在恢复期间完全不可用。其次数据没有备份，如果将单机Redis服务作为数据库存储数据，机器磁盘发生损坏或被删库跑路，数据就真的丢失了。</p><h2 id="2-主从模式"><a href="#2-主从模式" class="headerlink" title="2.主从模式"></a>2.主从模式</h2><p>主从模式是将某一台Redis服务作为主机，其余的一或多个作为备份机，主机每次收到写命令执行成功后会发送给所有备份机进行数据同步。这种模式主要解决单机模式的数据备份问题，并且主从结点的数据几乎一致，可以对集群进行读写分离，提高请求的处理能力。</p><h3 id="2-1-集群架构"><a href="#2-1-集群架构" class="headerlink" title="2.1 集群架构"></a>2.1 集群架构</h3><p><img src="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" class="lazyload" data-srcset="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h3 id="2-2-主从复制"><a href="#2-2-主从复制" class="headerlink" title="2.2 主从复制"></a>2.2 主从复制</h3><p>Redis在2.8版本前主从节点的数据同步是用SYNC实现，主节点需要执行BGSAVE命令生成RDB文件，并且RDB文件的传输也由主线程完成，这意味着整个同步流程中主线程是完全阻塞的，无法处理读写请求，如果RBD文件过大会导致数据同步耗时太久，大量的请求被阻塞。</p><p>Redis2.8版本开始采用PSYNC，通过异步+缓冲区的方式同步数据，整个过程如下:</p><ul><li>从节点启动连接主节点，发送PSYNC命令进行同步数据</li><li>主节点收到命令后执行BGSAVE向从节点发送快照文件(异步)</li><li>从节点拿到新的rdb文件替换旧的，载入收到的rdb文件到内存</li><li>主节点完成自己的rdb加载后开始向从节点发送缓冲区的命令</li><li>从节点开始同步主节点的缓冲区的命令(此时从节点初始化完成，正常工作)</li><li>每次主节点收到命令都会发送给从节点同步数据</li></ul><h3 id="2-3-读写分离"><a href="#2-3-读写分离" class="headerlink" title="2.3 读写分离"></a>2.3 读写分离</h3><p>Redis的读写分离机制是主节点处理所有的写命令，从节点处理所有的读命令，从而减轻主节点的请求压力。然而引用这种机制是要付出一定代价的，首先是数据一致性问题，毕竟主节点的数据同步到从节点需要时间，比如秒杀业务的库存数据，就需要强一致性。其次Redis服务端并不支持这个功能，服务端接收到命令后并不会根据命令类型转发到主节点或从节点，需要客户端自己区分哪些IP的服务是拥有写权限，哪些是只读权限。</p><p>单纯的主从模式，从java客户端的角度来实现读写分离，需要创建两个连接bean，一个连接主节点，另一个连接从节点，并根据命令类型分别调用不同bean的API。哨兵模式配置相对较为简单，客户端只需要连接哨兵节点，就可以定位主节点与从节点，然后进行读写分离操作。</p><p>读写分离机制更多的是针对mysql这种需要磁盘IO的数据库，因为磁盘IO是比较耗时的操作，对于Redis这种内存IO的数据库很少能达到这种瓶颈。如果你项目中对于Redis仅仅作为缓存使用，换句话说就是读请求数量远大于写请求数量，并且可以接受一定程度的数据一致性问题，可以考虑使用读写分离。</p><p class="p red">由于Redis的内存管理机制并不能保证某个Key过期后立马被清除，导致在3.2版本以前会把过期数据同步到从节点，在读写分离的场景下会读取到脏数据，这个问题在3.2版本后修复，使用读写分离的一定要注意Redis的版本号!</p><h3 id="2-4-优缺点"><a href="#2-4-优缺点" class="headerlink" title="2.4 优缺点"></a>2.4 优缺点</h3><p>优点:</p><ul><li>数据可以保持多个备份，不会出现由于磁盘损坏导致的数据丢失。</li><li>主节点向从节点同步数据的过程是异步执行，在此期间正常处理读写请求。</li><li>读写分离机制有效缓解了主节点的读请求压力。</li></ul><p>缺点:</p><ul><li>仍然不支持自动容错和恢复功能，宕机后需要手动干预。</li><li>主节点宕机如果没来得及同步到从服务器会引起数据不一致。</li><li>数据全部存储在一个节点中，无法在线扩容。</li></ul><h2 id="3-哨兵模式"><a href="#3-哨兵模式" class="headerlink" title="3.哨兵模式"></a>3.哨兵模式</h2><p>哨兵模式是启动一个或多个哨兵节点对多个Redis主从节点进行发现并监控，如果主节点宕机将所属的某个从节点升级为主节点，另外哨兵节点之间也会互相监控。哨兵模式的出现是为了解决Redis集群模式下的自动容错和恢复功能。</p><h3 id="3-1-集群架构"><a href="#3-1-集群架构" class="headerlink" title="3.1 集群架构"></a>3.1 集群架构</h3><p><img src="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" class="lazyload" data-srcset="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h3 id="3-2-哨兵监控原理"><a href="#3-2-哨兵监控原理" class="headerlink" title="3.2 哨兵监控原理"></a>3.2 哨兵监控原理</h3><p>哨兵节点启动后，会根据配置文件确认要监控的master节点，并且与每个主节点建立两条连接:<br><img src="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E5%93%A8%E5%85%B5%E4%B8%8E%E4%B8%BB%E8%8A%82%E7%82%B9%E5%BB%BA%E7%AB%8B%E5%8F%8C%E8%BF%9E%E6%8E%A5.png" class="lazyload" data-srcset="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E5%93%A8%E5%85%B5%E4%B8%8E%E4%B8%BB%E8%8A%82%E7%82%B9%E5%BB%BA%E7%AB%8B%E5%8F%8C%E8%BF%9E%E6%8E%A5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><font color="#FF0000">在连接②中，哨兵节点每10秒向主节点、从节点发送INFO命令。</font>由于配置哨兵监控对象时只需要填写主节点信息，因此通过INFO命令可以获取到主节点的所有从节点，达到自动发现新加入的从节点的目的。对于链式主从模式来说，从节点可能还会配置从节点，因此涉及到的所有从节点也会发送INFO命令。</p><p><font color="#FF0000">在连接②中，哨兵节点每2秒向主节点、从节点的<em>sentinel</em>:hello频道发布自己的信息。</font>信息内容包括自身的IP、端口、运行ID等，以此来向其他哨兵宣告自己的存在。</p><p><font color="#FF0000">在连接②中，哨兵节点每1秒向主节点、从节点以及其他哨兵节点发送ping命令。</font>接收方必须在指定时间内(down-after-milliseconds)作出正确响应，如果down-after-milliseconds值小于1秒时，那么发送频率会提升到每down-after-milliseconds秒发送一次。</p><p><font color="#FF0000">在连接①中，哨兵节点订阅监控目标的<em>sentinel</em>:hello频道，从而得知其他哨兵节点的存在。</font>在订阅到消息后会判断消息中的哨兵节点是否为新加入的节点，如果是则与其建立连接②，然后发送ping命令，并通过这种形式实现哨兵集群的相互监控。</p><h3 id="3-2-主观-客观下线"><a href="#3-2-主观-客观下线" class="headerlink" title="3.2 主观/客观下线"></a>3.2 主观/客观下线</h3><p>哨兵节点会通过ping命令的形式判断节点是否正常运行，当命令在down-after-milliseconds内未做出正确响应，那么哨兵节点会认为其主观下线。主观下线仅表示哨兵自己认为出故障了，但并不一定是节点出现故障，也有可能是哨兵自己网络出现问题导致与被监控节点无法ping通，因此需要借助其他哨兵进一步判断。</p><p>哨兵发送命令给其他哨兵节点，询问此故障节点是否主观下线，如果超过指定数量(参数配置)的哨兵都觉得此故障节点主观下线，那么会被整个哨兵集群认为客观下线。如果故障节点的角色是从节点或其他哨兵节点，需要将其踢掉，如果是主节点挂掉了，那么还要进行故障恢复，考虑到故障恢复只能由一个哨兵去完成，因此需要选举出领头哨兵，处理这个事情。</p><h3 id="3-3-故障恢复"><a href="#3-3-故障恢复" class="headerlink" title="3.3 故障恢复"></a>3.3 故障恢复</h3><p>领头哨兵获取故障主节点的所有从节点，选出优先级最高的从节点，优先级通过replica-priority参数设置。如果出现优先级相同的情况，则选出复制的偏移量最大的节点，因为偏移量越大代表同步的数据越完整，如果到此还存在优先级相同的从节点，那么选择运行ID(启动时自动生成)最小的那个节点。</p><ul><li>领头哨兵向选中的从节点发送SLAVEOF no one命令，将其升级为主节点</li><li>故障的原主节点重新启动后，领头哨兵发送SLAVEOF命令，将其变为新master的slave</li></ul><h3 id="3-4-优缺点"><a href="#3-4-优缺点" class="headerlink" title="3.4 优缺点"></a>3.4 优缺点</h3><p>优点:</p><ul><li>哨兵模式是主从模式的升级版，主从模式拥有的优点，哨兵模式都有</li><li>支持自动容错和恢复功能</li><li>哨兵支持集群相互监控，稳定性高</li></ul><p>缺点:</p><ul><li>所有数据仍然存储在单节点中，很难在线扩容</li><li>配置太繁琐</li></ul><h2 id="4-分片模式"><a href="#4-分片模式" class="headerlink" title="4.分片模式"></a>4.分片模式</h2><p>分片模式是将数据集分成几个小部分，存储在不同的服务节点中，在处理读写请求时，通过对key的hash取余定位到具体的节点，然后转发命令到该节点进行处理。分片模式的出现是为了解决主从模式、哨兵模式下，单节点存储瓶颈以及在线扩容的问题。</p><p>早期为了应对哨兵模式单节点存储的弱点，需要借助代理中间件在客户端实现分区存储以及对key的定位查询功能，常见的中间件有codis、twemproxy等。直到Redis发布3.0版本后，才开始在服务端支持分片模式，下面只讲述redis自己提供的分片模式。</p><h3 id="4-1-集群架构"><a href="#4-1-集群架构" class="headerlink" title="4.1 集群架构"></a>4.1 集群架构</h3><p><img src="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E5%88%86%E7%89%87%E6%A8%A1%E5%BC%8F-%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.png" class="lazyload" data-srcset="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E5%88%86%E7%89%87%E6%A8%A1%E5%BC%8F-%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>图中为3个master节点的分片集群，每个master节点拥有一个slave节点，每个节点(包括slave节点)都会实时同步其他所有节点的信息。服务端只有master节点处理请求(如果需要实现读写分离，需要在客户端进行改造)，当请求命令涉及的key不属于本节点负责时，会根据实时同步的节点信息进行转发。</p><h3 id="4-2-槽位分配"><a href="#4-2-槽位分配" class="headerlink" title="4.2 槽位分配"></a>4.2 槽位分配</h3><p>Redis分片模式在存储数据时采用虚拟哈希槽的方式存储，预先分配16384(2^14)个卡槽，集群内各master节点均摊所有卡槽，并对外提供服务:<br><img src="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E8%99%9A%E6%8B%9F%E5%93%88%E5%B8%8C%E6%A7%BD.png" class="lazyload" data-srcset="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E8%99%9A%E6%8B%9F%E5%93%88%E5%B8%8C%E6%A7%BD.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>服务端接收读到写命令后，通过key定位出所在的节点:<br><img src="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E5%88%86%E7%89%87%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%BD%8D%E8%8A%82%E7%82%B9.png" class="lazyload" data-srcset="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E5%88%86%E7%89%87%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%BD%8D%E8%8A%82%E7%82%B9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>Redis在分片设计上，并没有直接使用一致性哈希算法(hash值%节点数，定位节点)，而是在中间添加了一层哈希槽的定位计算。这样节点新增或删除后进行数据转移，只需要操作卡槽到对应节点即可，如果采用一致性哈希算法，还需要遍历节点内所有数据并逐个计算，得出哪些数据需要转移的。</p><p>另外卡槽的存储概念仅针对master节点，slave节点仅根据master节点同步的数据正常存储。</p><h3 id="4-3-节点伸缩"><a href="#4-3-节点伸缩" class="headerlink" title="4.3 节点伸缩"></a>4.3 节点伸缩</h3><p>当对集群进行缩容或扩容后，整个集群的master节点数量发生变化，为了保证所有正常节点对哈希槽的分配是均匀的，需要对所有哈希槽进行重新分配并迁移。</p><p>例如三个master节点的集群中，新增一个master节点后的哈希槽分配变化:<br><img src="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E8%8A%82%E7%82%B9%E6%89%A9%E5%AE%B9-%E5%93%88%E5%B8%8C%E6%A7%BD%E8%BF%81%E7%A7%BB.png" class="lazyload" data-srcset="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/%E8%8A%82%E7%82%B9%E6%89%A9%E5%AE%B9-%E5%93%88%E5%B8%8C%E6%A7%BD%E8%BF%81%E7%A7%BB.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>图中可以看出哈希槽迁移的范围:</p><ul><li>master-0节点的4097～5461哈希槽转移到master-1节点中</li><li>master-1节点的8193～10922哈希槽转移到master-2节点中</li><li>master-2节点的12289～16384哈希槽转移到master-3节点中</li></ul><h3 id="4-4-客户端路由"><a href="#4-4-客户端路由" class="headerlink" title="4.4 客户端路由"></a>4.4 客户端路由</h3><p>客户端向服务端发送读写命令时，并不知道此次操作涉及的key到底在哪个分片节点上，因此只能请求集群中的任意一个节点(包括从节点)，如果响应的是moved重定向异常，则从异常中获取正确的节点信息并再次请求:<br><img src="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/moved%E9%87%8D%E5%AE%9A%E5%90%91.png" class="lazyload" data-srcset="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/moved%E9%87%8D%E5%AE%9A%E5%90%91.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>在集群正常运行期间，moved重定向机制完全可以解决key的路由访问，当节点正常退出或者有新节点加入集群后，部分卡槽数据进行迁移。此时moved重定向节点的数据已经迁移到别的节点中，仍然会出现查询不到数据的情况，此时节点会返回ask重定向给客户端，再次请求服务端:<br><img src="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/ask%E9%87%8D%E5%AE%9A%E5%90%91.png" class="lazyload" data-srcset="/2021/01/28/Redis-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/ask%E9%87%8D%E5%AE%9A%E5%90%91.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>上述的路由转发机制可以看出，数据量过多或者集群节点过多时，客户端的请求会产生大量的重定向，对redis的性能造成影响，因此客户端都会对分片节点负责的哈希槽信息进行缓存，从而减少无用的网络请求，当节点伸缩导致负责的哈希槽变化时，客户端也会做出相应的更新。</p><p>比如java提供的Jedis客户端，内部JedisCluster类久实现了类似机制。JedisCluster在创建后会从集群中选择一个正常运行的节点，查询哈希槽的分布情况并将映射关系保存到本地，然后为集群的每个节点建立连接池，所有的请求命令都会先去映射缓存查询，然后再调用指定的连接池发送请求命令。</p><h3 id="4-5-故障恢复"><a href="#4-5-故障恢复" class="headerlink" title="4.5 故障恢复"></a>4.5 故障恢复</h3><p>分片模式并没有哨兵模式那种单独监控节点实现故障恢复，当某个master节点挂掉后，需要借助集群内其他master节点，从故障master的众多slave节点中选举出一个继续工作。</p><p>首先有两种情况会导致redis-cluster不可用，也就是集群无法提供服务:</p><ul><li>超过半数master节点挂掉(无视对应的slave)</li><li>某个节点的master、slave全挂</li></ul><p>在集群可用的情况下，master挂掉后会触发选举，选出新的master节点:</p><ul><li>slave节点发现自己的master变为FAIL</li><li>slave节点先给自己epoch+1，然后请求集群内其他master节点给自己投票，并将事件广播给其他所有节点</li><li>slave节点发起投票后，会等待至少NODE_TIMEOUT*2时间接受投票结果(最少也会2秒)</li><li>master节点接收到投票后响应FAILOVER_AUTH_ACK，并且在NODE_TIMEOUT*2时间内不给同一master的其他slave投票</li><li>slave接收FAILOVER_AUTH_ACK的epoch如果小于自身，直接丢失</li><li>如果slave接收到半数以上符合条件的FAILOVER_AUTH_ACK，则声明自己选举成功</li><li>如果在等待的NODE_TIMEOUT<em>2时间内没有赢得选举，放弃本次选举，然后在NODE_TIMEOUT</em>4时间后重新发起选举</li><li>选举成功后，广播通知集群内其他节点</li></ul><p>节点中的epoch全称为currentEpoch，集群中新加入或重启的节点(无论master或slave)currentEpoch值都为0，某节点需要请求其他节点提供协助时(目前只有选举)currentEpoch+1。当节点接收到其他节点的包时(比如slave发起的选举)，如果包中的currentEpoch大于自身的currentEpoch，那么会更新为发送者的currentEpoch。这种规则下集群中所有节点的currentEpoch最终会达成一致，也是代表自身在集群中的通信是健康的。</p><p>另外slave节点发现master挂掉后，不会立即发起投票，而是通过延迟公式计算出一定延迟时间后在发起:<br>延迟公式: 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</p><p>延迟发送选举是为了确保master挂掉的信息在整个集群内传开(让子弹飞一会)，如果没有延迟的情况下可能部分master接收到选举请求时还没有感知到master挂了，造成误判。在0.5秒的基础上增加随机时间，是为了防止多个slave同时发起选举。公式最后的SLAVE_RANK代表slave节点已经从master节点复制的总量的rank，越小代表复制的越新，这个参数理论上可以保证持有最新数据的slave会先发起选举。</p><h3 id="4-6-slave自动迁移"><a href="#4-6-slave自动迁移" class="headerlink" title="4.6 slave自动迁移"></a>4.6 slave自动迁移</h3><p>Redis为了保证整个集群的高可用，让每个分片都正常提供服务，某些情况下会对slave节点迁移到别的分片下面。假设某个集群拥有3主3从共6个节点，万一某个master对应的slave发生宕机，这时候就不存在高可用这一说，因为master在发生宕机就没有任何节点可以代替它工作，会导致整个集群不可用。</p><p>针对这种情况，集群在发现某个master节点没有任何slave节点时，会将其他master节点多余的slave节点迁移过来，继续保证集群的高可用。因此在搭建集群模式时，一定要多部署几台slave节点备用，提高集群的高可用状态。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存中间件 </category>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis(二) 内存管理与持久化</title>
      <link href="2021/01/24/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>2021/01/24/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="1-过期策略"><a href="#1-过期策略" class="headerlink" title="1.过期策略"></a>1.过期策略</h2><h3 id="1-1-定期删除"><a href="#1-1-定期删除" class="headerlink" title="1.1 定期删除"></a>1.1 定期删除</h3><p>Redis中所有设置过期时间的KEY都会被记录到一个字典中，通过定时任务每隔一段时间(默认100ms)对字典中的KEY进行扫描删除过期数据，当然这种定时扫描只会发生在master节点上，slave节点会通过主节点同步的DEL命令进行同步达到删除过期键的目的。</p><p>扫描过程中如果过期KEY在总数中占的比例少于25%，则终止循环，这么做的目的是为了节省CPU资源，为了防止过期KEY数量过多导致循环一直执行下去，Redis增加了超时限制，消耗一定时间循环也会被打破。</p><h3 id="1-2-惰性删除"><a href="#1-2-惰性删除" class="headerlink" title="1.2 惰性删除"></a>1.2 惰性删除</h3><p>Redis在执行任何读写命令时都会先找到这个KEY，惰性删除就作为一个切入点在命令执行前判断KEY是否过期，如果过期则进行删除。这种机制主要为了弥补定期删除策略扫描无法覆盖全部KEY的情况。</p><h2 id="2-淘汰策略"><a href="#2-淘汰策略" class="headerlink" title="2.淘汰策略"></a>2.淘汰策略</h2><h3 id="2-1-淘汰规则"><a href="#2-1-淘汰规则" class="headerlink" title="2.1 淘汰规则"></a>2.1 淘汰规则</h3><p>Redis的内存淘汰机制是针对内存不足的情况下，采用某种策略淘汰掉内存中的部分数据，保证服务可以继续写入数据，Redis提供了六种淘汰规则:</p><ul><li>noeviction: 禁止淘汰，当内存达到阈值时，后续所有需要申请内存的命令都会报错</li><li>allkeys-random: 从数据集中任意选择数据淘汰</li><li>allkeys-lru: 从数据集中挑选最近最少使用的数据淘汰</li><li>volatile-lru: 从设置了过期时间的数据集中挑选最近最少使用的数据淘汰</li><li>volatile-ttl: 从已设置了过期时间的数据集中挑选即将要过期的数据淘汰</li><li>volatile-random: 从已设置了过期时间的数据集中任意选择数据淘汰</li></ul><p class="p red">如果内存中不存在设置过期时间的key，会导致前缀为volatile的三种策略找不到任何可以清理的key，结果和noeviction一样报错。</p><h3 id="2-2-文件配置"><a href="#2-2-文件配置" class="headerlink" title="2.2 文件配置"></a>2.2 文件配置</h3><figure class="highlight plain"><figcaption><span>redis.conf</span></figcaption><table><tr><td class="code"><pre><span class="line"># 策略启动阈值(单位字节，64位系统中0表示不限制，32位系统中隐式不能超过3GB)</span><br><span class="line">maxmemory 0</span><br><span class="line"></span><br><span class="line"># 淘汰策略类型</span><br><span class="line">maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line"># 样本池数量</span><br><span class="line">maxmemory-samples 5</span><br></pre></td></tr></table></figure><h3 id="2-3-淘汰过程"><a href="#2-3-淘汰过程" class="headerlink" title="2.3 淘汰过程"></a>2.3 淘汰过程</h3><p>当Redis服务内存达到maxmemory后，对于所有的读写请求，都会触发freeMemoryIfNeeded函数以清理内存，并且这个清理过程是阻塞的，直到腾出足够的内存空间。整个清理过程并不是针对所有key，而是随机抽取maxmemory-samples个样本key，根据设置好的淘汰策略从样本范围中进行淘汰。</p><p>maxmemory-samples的大小对于noeviction和random策略没有任何影响，对于lru和ttl策略来说，值的大小直接影响到淘汰的精准度。值越大则样本范围越大，精准度越高，缺点是CPU耗时也会越高，在清理函数阻塞情况下甚至造成请求卡顿，反之亦然。</p><h3 id="2-4-lru算法实现"><a href="#2-4-lru算法实现" class="headerlink" title="2.4 lru算法实现"></a>2.4 lru算法实现</h3><p>lru算法是淘汰掉最近最少使用的数据，由于Redis采用样本随机抽取的机制清理数据，因此并不是严格意义上的lru算法。Redis给每个key额外添加了一个25bit的字段，存储最后一次的访问时间，并以此字段作为参考值实现lru算法。</p><p>在3.0版本进行优化，维护一个大小为16的候选池，池中的数据根据访问时间排序，第一次抽取的样本都会放入池中，后续随机抽取的样本数据只有在访问时间小于池中最小时间的情况下，才会放入池中，直到候选池放满数据。再往后抽取的样本中，如果仍然存在访问时间小于池中的数据，将池中访问时间最大的移除并添加到池中。当需要淘汰数据时，直接从池中选取最久没被访问的key淘汰掉。</p><h2 id="3-RDB持久化"><a href="#3-RDB持久化" class="headerlink" title="3.RDB持久化"></a>3.RDB持久化</h2><p>RDB即快照，是Redis默认的持久化方式，对某个特定时间点的数据进行一次全量备份，并将备份结果写入一个紧凑的二进制文件中，除此之外Redis还支持命令的方式手动触发一次RDB持久化。</p><h3 id="3-1手动触发"><a href="#3-1手动触发" class="headerlink" title="3.1手动触发"></a>3.1手动触发</h3><p>SAVE: 同步持久化，由于Redis所有命令仅用一个线程进行处理，因此整个持久化过程会阻塞所有读写请求，如果数据量大的话会造成长时间的阻塞，生产环境一般禁止使用。</p><p>BGSAVE: 异步持久化，Redis接收到此命令后会fork出一个子进程处理持久化工作，由于Redis所有命令仅用一个线程进行处理，因此fork期间所有读写请求仍然是阻塞的，直到fork完毕后继续处理请求，与此同时，子进程异步执行持久化工作。</p><h3 id="3-2-自动触发"><a href="#3-2-自动触发" class="headerlink" title="3.2 自动触发"></a>3.2 自动触发</h3><p>在配置文件redis.conf中，默认设置了三种自动触发的规则，用户可以根据自身业务场景修改触发规则。如果同时配置多个save选项，那么只要其中任一条满足，Redis都会触发一次BGSAVE操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 自动触发的规则格式:</span><br><span class="line"># save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"></span><br><span class="line"># 900秒(15分钟)内至少发生一次写操作，触发RDB持久化</span><br><span class="line">save 900 1</span><br><span class="line"># 300秒(5分钟)内至少发生10次写操作，触发RDB持久化</span><br><span class="line">save 300 10</span><br><span class="line"># 60秒(1分钟)内至少发生10000次写操作，触发RDB持久化</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p class="p red">当手动执行shutdown命令关闭服务器时，如果没有开启AOF持久化功能，也会自动触发一次bgsave命令进行RDB持久化。</p><h3 id="3-3-执行流程"><a href="#3-3-执行流程" class="headerlink" title="3.3 执行流程"></a>3.3 执行流程</h3><ul><li><p>执行bgsave命令的时候，Redis主进程会检查是否有子进程在执行RDB/AOF持久化任务，如果有的话，直接返回</p></li><li><p>Redis主进程会fork一个子进程来执行执行RDB操作，fork操作会对主进程的读写请求造成阻塞，fork操作完成后会发消息给主进程，从而不再阻塞主进程。</p></li><li><p>RDB子进程会根据Redis主进程的内存生成临时的快照文件，持久化完成后会使用临时快照文件替换掉原来的RDB文件。该过程中主进程的读写不受影响，但Redis的写操作不会同步到主进程的主内存中，而是会写到一个临时的内存区域作为一个副本。</p></li><li><p>子进程完成RDB持久化后会发消息给主进程，通知RDB持久化完成，并将上阶段内存副本中的增量写数据同步到主内存。</p></li></ul><h3 id="3-4-优缺点"><a href="#3-4-优缺点" class="headerlink" title="3.4 优缺点"></a>3.4 优缺点</h3><p>优点是主进程在整个持久化过程中唯一要做的就是fork出子进程，剩下的持久化工作全部由子进程完成，父进程无需执行任何磁盘IO操作。RDB文件是紧凑的二进制数据构成，占用磁盘相对AOF较小，在服务重启加载数据时速度会快很多。</p><p>缺点是无法做到实时持久化，一旦服务器异常退出或宕机，会导致最后一次快照后面的所有数据丢失，因此需要根据自身场景配置触发规则，尽量减少这种意外带来的损失。另外主进程fork子进程属于重量级操作，过程中会阻塞主进程的读写请求，因此配置触发规则除了考虑到减少意外带来的损失以外，还要考虑到频繁RDB对读写请求响应时间带来的影响。</p><h2 id="4-AOF持久化"><a href="#4-AOF持久化" class="headerlink" title="4.AOF持久化"></a>4.AOF持久化</h2><p>AOF采用命令日志的方式进行内存数据的持久化，每条写命令都会记录到AOF日志中，当Redis需要重启时会逐条执行命令日志，将持久化数据恢复到内存中。</p><h3 id="4-1-开启方式"><a href="#4-1-开启方式" class="headerlink" title="4.1 开启方式"></a>4.1 开启方式</h3><p>AOF持久化方式默认是关闭的，可以通过配置文件redis.conf进行开启，如果RDB和AOF同时开启，Redis在启动时默认加载AOF文件恢复数据，并且后续采用AOF方式进行持久化。</p><p>redis.conf中，关于AOF的相关配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 此选项为aof功能的开关，默认为no，可以通过修改为yes来开启aof功能</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># 指定aof文件名称</span><br><span class="line">appendfilename appendonly.aof</span><br><span class="line"></span><br><span class="line"># 指定aof操作中文件同步策略，分为always、everysec(默认)、no三种</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># 在aof-rewrite期间，appendfsync是否暂缓文件同步</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># aof文件rewrite触发的最小文件尺寸(mb,gb),只有大于此aof文件大于此尺寸是才会触发rewrite，默认64mb</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 相对于“上一次”rewrite，本次rewrite触发时aof文件应该增长的百分比</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br></pre></td></tr></table></figure><h3 id="4-2-appendfsync"><a href="#4-2-appendfsync" class="headerlink" title="4.2 appendfsync"></a>4.2 appendfsync</h3><p>AOF对于每条写命令都会追加到文件中，当写命令过于频繁会导致磁盘IO的负荷加重，另外Linux系统提供了pageCache机制将部分磁盘IO请求转化为内存IO，并通过异步方式刷回磁盘文件，这种机制在一定程度上缓解了AOF文件写入的压力，同时也增加了数据丢失的可能，比如数据写入内核缓存后还没来得及刷回磁盘发生断电，那么这部分数据就会丢失。</p><p>Redis提供了三种刷盘的策略:</p><ul><li>always: 每条写命令都会调用操作系统的fsync函数，强制从内核缓存刷回磁盘，较为安全，代价是性能很低。</li><li>everysec: 每秒调用一次操作系统的fsync函数，是一种折中的处理方式，最多丢失一秒的数据。</li><li>no: Redis永远不主动调用fsync函数，让操作系统自身选择何时同步磁盘，性能较好，缺点是断电情况下会造成更多的丢失可能。</li></ul><h3 id="4-3-rewrite-重写机制"><a href="#4-3-rewrite-重写机制" class="headerlink" title="4.3 rewrite(重写机制)"></a>4.3 rewrite(重写机制)</h3><p>AOF采用记录命令的方式持久化，这会导致随着时间的推移AOF文件会越来越大，因此需要定期对AOF日志进行压缩，压缩的过程就是rewrite。例如对key1初始值是0，共调用incr命100次，key1的值变为100，那么一条set key1 100 就可以合并之前的100条命令。</p><p>rewrite目的是对AOF文件的压缩，但是执行过程中并不是对现有AOF文件进行编辑删减，而是采取类似RDB快照的方式，遍历内存中所有数据，逐个将数据对应的命令添加到新的AOF文件中。在rewrite过程中对于新的变更操作仍然写入到旧的AOF文件中，不过这些命令Redis会单独在保存一份，当内存中的数据全部写入到新的AOF文件后，之前单独存储的新命令也会一并写入到新AOF文件，最后替换掉旧的AOF文件。</p><h3 id="4-4-no-appendfsync-on-rewrite"><a href="#4-4-no-appendfsync-on-rewrite" class="headerlink" title="4.4 no-appendfsync-on-rewrite"></a>4.4 no-appendfsync-on-rewrite</h3><p>在对AOF文件压缩期间，新的写命令仍然会记录到旧的AOF文件中，在假设新的AOF文件必定生成成功的前提下，这部分命令是否成功写入旧的AOF文件已经不重要了，这段时间调用操作系统的fsync函数强制刷盘完全是资源浪费，可以暂缓。但是这个参数Redis给的默认值是no，也就是说Redis不推荐暂缓强制刷盘，可能是出于安全考虑吧。</p><h3 id="4-5-自动触发rewrite"><a href="#4-5-自动触发rewrite" class="headerlink" title="4.5 自动触发rewrite"></a>4.5 自动触发rewrite</h3><p>auto-aof-rewrite-min-size是自动触发rewrite的最小文件尺寸，默认64mb。当某条写命令追加到AOF文件后文件大于64mb，会自动触发rewrite。</p><p>auto-aof-rewrite-percentage是自动触发rewrite的最小增长比例，默认100%。每次rewrite后都会记录此刻AOF文件的大小，后续每次追加命令都会获取当前AOF文件大小，和最初的大小比较并计算增长百分比，当增长比例超过100%触发rewrite。</p><p class="p red">注:只有俩个条件都满足的情况下才会触发rewrite。</p><h3 id="4-6-手动触发rewrite"><a href="#4-6-手动触发rewrite" class="headerlink" title="4.6 手动触发rewrite"></a>4.6 手动触发rewrite</h3><p>如果你的Redis一直使用RDB持久化方式，并且想更换为AOF，那么可以使用config命令动态修改redis.conf配置，然后发送此命令将扫描当前内存数据，生成一份AOF文件。</p><figure class="highlight plain"><figcaption><span>触发命令:</span></figcaption><table><tr><td class="code"><pre><span class="line">redis-cli -h ip -p port bgrewriteaof</span><br></pre></td></tr></table></figure><h3 id="4-7-优缺点"><a href="#4-7-优缺点" class="headerlink" title="4.7 优缺点"></a>4.7 优缺点</h3><p>优点是大部分情况下仅仅是对AOF文件追加写日志，对服务器性能影响较小，并且在默认配置下最多丢失一秒的数据。AOF文件的内容都是命令，可以兼容任何Redis版本。</p><p>缺点是在数据量较大的情况下，会不断触发rewrite，对AOF文件进行压缩。即使经过压缩，由于自身是文本文件，体积相对RDB(二进制文件)要大得多。并且在服务重启过程中需要重演命令式的恢复数据，相对于RDB要慢上许多。</p><h3 id="4-8-AOF文件修复"><a href="#4-8-AOF文件修复" class="headerlink" title="4.8 AOF文件修复"></a>4.8 AOF文件修复</h3><p>在将命令写入AOF文件过程中，可能因为宕机造成文件有错误，导致Redis服务重启时拒绝加载此AOF文件，可以通过redis-check-aof工具修正AOF文件。</p><h2 id="5-混合持久化"><a href="#5-混合持久化" class="headerlink" title="5.混合持久化"></a>5.混合持久化</h2><h3 id="5-1-开启方式"><a href="#5-1-开启方式" class="headerlink" title="5.1 开启方式"></a>5.1 开启方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># yes开启 no关闭</span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><h3 id="5-2-执行过程"><a href="#5-2-执行过程" class="headerlink" title="5.2 执行过程"></a>5.2 执行过程</h3><p>RDB与AOF俩种持久化方式的优缺点都很明显，因此Redis4.0推出了混合持久化方式，将原AOF文件内容变成了前部分存储RDB格式数据、后部分存储AOF格式数据，既保证了服务运行期间数据不丢失，又避免了服务重启数据恢复慢的问题:<br><img src="/2021/01/24/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96.png" class="lazyload" data-srcset="/2021/01/24/Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E6%8C%81%E4%B9%85%E5%8C%96/%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> 缓存中间件 </category>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis(一) 常用数据类型</title>
      <link href="2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="1-字符串-string"><a href="#1-字符串-string" class="headerlink" title="1.字符串(string)"></a>1.字符串(string)</h2><p>string是Redis最基础的数据类型，底层通过int或SDS(动态字符串:Simple Dynamic String)实现。在设置一个字符串键值对后，Redis会根据value的类型、长度来决定使用哪种编码，通过不同的编码方式映射到不同的数据结构。</p><h3 id="1-1-内部结构"><a href="#1-1-内部结构" class="headerlink" title="1.1 内部结构"></a>1.1 内部结构</h3><p><img src="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><ul><li><p>int类型数据结构支持incr、incrby、decr、decrby等命令对value值进行增减操作。</p></li><li><p>embstr编码的SDS结构是专门用于保存短字符串的优化编码方式，与raw编码不同，embstr编码通过一次内存分配函数将字符串KV对象和value值分配在连续的内存块中，提高CPU取数据的效率问题。</p></li><li><p>raw编码的SDS结构用于存储较长的字符串，通过俩次内存分配函数得到俩块内存，给字符串KV对象和value分别存储。</p></li></ul><h3 id="1-2-常用命令"><a href="#1-2-常用命令" class="headerlink" title="1.2 常用命令"></a>1.2 常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">get [key] [value]  &#x2F;&#x2F; 获取指定key对应value</span><br><span class="line"></span><br><span class="line">set [key] [value]  &#x2F;&#x2F; 给指定key设置value，该命令会覆盖旧的KV</span><br><span class="line"></span><br><span class="line">set [key] [value] [ex 秒数]&#x2F;[px 毫秒]&#x2F;[nx 纳秒]  &#x2F;&#x2F; 给指定key设置value和过期时间，该命令会覆盖旧的KV和过期时间</span><br><span class="line"></span><br><span class="line">append [key] [value] &#x2F;&#x2F; 把value追加到key的原值上</span><br><span class="line"></span><br><span class="line">expire [key] [time]  &#x2F;&#x2F; 等价于set + expire命令</span><br><span class="line"></span><br><span class="line">setex [key] [time] [value]  &#x2F;&#x2F; 给指定key设置过期时间，单位秒</span><br><span class="line"></span><br><span class="line">setnx [key] [value]  &#x2F;&#x2F; 如果key不存在则set，否则返回0</span><br><span class="line"></span><br><span class="line">incr [key]  &#x2F;&#x2F; 如果key为整数则使值增加1</span><br><span class="line"></span><br><span class="line">incrby [key] [number]  &#x2F;&#x2F; 如果key为整数则使值增加number</span><br><span class="line"></span><br><span class="line">decr [key]  &#x2F;&#x2F; 如果key为整数则使值减少1</span><br><span class="line"></span><br><span class="line">decrby [key] [number]  &#x2F;&#x2F; 如果key为整数则使值减少number</span><br></pre></td></tr></table></figure><h3 id="1-3-应用场景"><a href="#1-3-应用场景" class="headerlink" title="1.3 应用场景"></a>1.3 应用场景</h3><ul><li>分布式缓存: 字典常量数据、JSON字符串、图片视频等序列化数组、Session等</li><li>分布式锁: 根据业务对接口或代码块加分布式锁</li><li>常规计数: 网站浏览量、点击量、收藏量等</li><li>接口监控: 通过AOP和Redis计数器对指定接口限流或屏蔽</li></ul><h2 id="2-哈希-hash"><a href="#2-哈希-hash" class="headerlink" title="2 哈希(hash)"></a>2 哈希(hash)</h2><p>hash类型在Redis类型中是指键值中的值本身又是一个键值对，底层通过ziplist(压缩列表)或hashtable(哈希表)实现，Redis会根据哈希表中的KV元素数量、每个元素值大小来决定使用哪种数据。</p><h3 id="2-1-内部结构"><a href="#2-1-内部结构" class="headerlink" title="2.1 内部结构"></a>2.1 内部结构</h3><p><img src="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><ul><li><p>ziplist是Redis自己设计的数据结构，使用更加紧凑的结构实现多个元素的连续存储，相比较hashtable更加节约内存，但是在大量元素的情况下读写效率不如hashtable，大块连续的存储空间的要求也比较苛刻。</p></li><li><p>hashtable的结构与Java JDK1.7版本的HashMap类似，采用数组加链表的形式进行存储，相比较ziplist在大量元素情况下读写效率更好，因为读写时间复杂度为O(1)。</p></li></ul><h3 id="2-2-常用命令"><a href="#2-2-常用命令" class="headerlink" title="2.2 常用命令"></a>2.2 常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">hset [object-key] [hash-key] [hash-value] &#x2F;&#x2F; 对某个hash对象设置单个键值对</span><br><span class="line"></span><br><span class="line">hsetnx [object-key] [hash-key] [hash-value]  &#x2F;&#x2F; 对某个hash对象设置单个键值对(如果hash-key已存在则什么都不做)</span><br><span class="line"></span><br><span class="line">hset [object-key] [hash-key-1] [hash-value-1] [hash-key-2] [hash-value-2] &#x2F;&#x2F; 对某个hash对象设置多个键值对</span><br><span class="line"></span><br><span class="line">hexists [object-key] [hash-key] &#x2F;&#x2F; 判断hash对象某个key是否存在(0否 1是)</span><br><span class="line"></span><br><span class="line">hget [object-key] [hash-key-1] &#x2F;&#x2F; 获取hash对象单个key的值</span><br><span class="line"></span><br><span class="line">hmget [object-key] [hash-key-1] [hash-key-2] &#x2F;&#x2F; 获取hash对象多个key的值</span><br><span class="line"></span><br><span class="line">hlen [object-key]  &#x2F;&#x2F; 获取hash对象某个键值对</span><br><span class="line"></span><br><span class="line">hgetall [object-key]  &#x2F;&#x2F; 获取hash对象所有键值对</span><br><span class="line"></span><br><span class="line">hkeys [object-key]  &#x2F;&#x2F; 获取某个hash对象的key列表</span><br><span class="line"></span><br><span class="line">hdel [object-key]  &#x2F;&#x2F; 删除hash的某个key</span><br><span class="line"></span><br><span class="line">hincrby [object-key] [hash-key] num  &#x2F;&#x2F; hash对象某个数字类型value递增num(num为整数)</span><br><span class="line"></span><br><span class="line">hincrbyfloat [object-key] [hash-key] num  &#x2F;&#x2F; hash对象某个数字类型value递增num(num为浮点)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-应用场景"><a href="#2-3-应用场景" class="headerlink" title="2.3 应用场景"></a>2.3 应用场景</h3><p>哈希一般用于存储结构简单、属性较多、修改频率较高的对象信息，比如购物车、商品信息、配置信息等。哈希存储对象相对于字符串存储对象的优势在于，整个修改操作可以只针对某个属性。</p><p>比如购物车的商品数量发生改变，字符串存储需要将内容提取出来转为对象，修改完属性后在转化为字符串存储，在购物车数据比较大的情况下会增加很多无意义的资源浪费。哈希类型存储购物车信息一般将每个商品的ID和数量作为元素的键值对，每次发生改变也仅仅是修改某个键值对的value，涉及到的资源消耗相对较少。</p><h2 id="3-列表-list"><a href="#3-列表-list" class="headerlink" title="3.列表(list)"></a>3.列表(list)</h2><p>list类型是用来存储多个有序的字符串，3.2之前的版本底层通过ziplist(压缩列表)或linkedlist(链表)实现，Redis会根据列表中的KV元素数量、每个元素值大小来决定使用哪种数据结构，3.2包括以后版本采用quicklist代替。</p><h3 id="3-1-内部结构"><a href="#3-1-内部结构" class="headerlink" title="3.1 内部结构"></a>3.1 内部结构</h3><p><img src="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%97%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%97%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><ul><li>ziplist的优缺点上面已经提到了。</li><li>linkedlist和ziplist都是线性数据结构，当元素较多或者某元素内存占用较大时，连续存储不太现实，还得采用linkedlist方式进行存储。</li></ul><h3 id="3-2-应用场景"><a href="#3-2-应用场景" class="headerlink" title="3.2 应用场景"></a>3.2 应用场景</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">lpush [key] [value] [value]...  &#x2F;&#x2F; 在list的头部插入单个或多个value，如果可以不存在则先创建(返回插入个数)</span><br><span class="line"></span><br><span class="line">rpush [key] [value] [value]...  &#x2F;&#x2F; 在list的尾部插入单个或多个value，如果可以不存在则先创建(返回插入个数)</span><br><span class="line"></span><br><span class="line">lpushx [key] [value]  &#x2F;&#x2F; 在list的头部插入单个value，如果key不存在则什么都不做</span><br><span class="line"></span><br><span class="line">rpushx [key] [value]  &#x2F;&#x2F; 在list的尾部插入单个value，如果key不存在则什么都不做</span><br><span class="line"></span><br><span class="line">lrange [key] [start] [end]  &#x2F;&#x2F; 获取list从start到end之间的元素，start和end可为负数，-1代表尾部元素，-2代表倒数第二个</span><br><span class="line"></span><br><span class="line">llen [key]  &#x2F;&#x2F; 获取list的长度</span><br><span class="line"></span><br><span class="line">lpop [key] &#x2F;&#x2F; 返回并删除list中的第一个元素</span><br><span class="line"></span><br><span class="line">rpop [key] &#x2F;&#x2F; 返回并删除list中的最后一个元素</span><br><span class="line"></span><br><span class="line">lrem [key] [count] [value]  &#x2F;&#x2F; 从头遍历并删除count个值为value的元素，如果count&#x3D;0，则删除全部</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-应用场景"><a href="#3-3-应用场景" class="headerlink" title="3.3 应用场景"></a>3.3 应用场景</h3><p>Redis关于此类型结构的操作比较丰富，支持两端插入和弹出、还可以获取指定范围的元素列表、获取指定索引下标的元素等，是一个比较灵活的数据结构，因此应用场景也比较灵活。可以利用list实现消息队列、列表的分页数据缓存等。</p><h2 id="4-去重集合-set"><a href="#4-去重集合-set" class="headerlink" title="4.去重集合(set)"></a>4.去重集合(set)</h2><p>set类型是一个无序并唯一的键值集合，底层通过inset(整数集合)或hashtable(哈希表)实现，根据集合内部的元素类型、个数来决定使用哪种数据结构。</p><h3 id="4-1-内部结构"><a href="#4-1-内部结构" class="headerlink" title="4.1 内部结构"></a>4.1 内部结构</h3><p><img src="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%BB%E9%87%8D%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%BB%E9%87%8D%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>intset集合存在的意义就是尽量减少内存的使用，当intset的条件无法满足时，使用hashtable进行存储，set集合对hashtable的使用和Java一样，仅仅使用key而已。</p><h3 id="4-2-常用命令"><a href="#4-2-常用命令" class="headerlink" title="4.2 常用命令"></a>4.2 常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sadd [key] [value-1] [value-2]...  &#x2F;&#x2F; 添加单个或多个元素</span><br><span class="line"></span><br><span class="line">scard [key]  &#x2F;&#x2F; 获取集合中元素个数</span><br><span class="line"></span><br><span class="line">sismember [key] [value]  &#x2F;&#x2F; 判断某个元素是否存在(返回 0否 1是)</span><br><span class="line"></span><br><span class="line">spop [key] &#x2F;&#x2F; 随机弹出一个元素，如果set没有元素则返回(nil)</span><br><span class="line"></span><br><span class="line">srandmember [key] [num]  &#x2F;&#x2F; 随机获取集合中num个元素，num为大于总数则获取全量，为负数则随机获取num的绝对值个(可能有重复)</span><br><span class="line"></span><br><span class="line">smove [key-A] [key-B] [value]  &#x2F;&#x2F; 将key-A的某个元素移动到key-B中</span><br><span class="line"></span><br><span class="line">srem [key] [value]  &#x2F;&#x2F; 删除某个元素(返回 0没找到 1删除成功)</span><br><span class="line"></span><br><span class="line">sdiff [key] [key-A] [key-B]  &#x2F;&#x2F; 差集，返回key有、key-A和key-B没有的所有元素(也可以一对一比较)</span><br><span class="line"></span><br><span class="line">sdiffstore [key] [key-A] [key-B]  &#x2F;&#x2F; 差集，计算后将结果重置到key中</span><br><span class="line"></span><br><span class="line">sinter [key] [key-A] [key-B]  &#x2F;&#x2F; 交集，返回多个key中共有的元素</span><br><span class="line"></span><br><span class="line">sdiffstore [key] [key-A] [key-B]  &#x2F;&#x2F; 交集，计算后将结果重置到key中</span><br><span class="line"></span><br><span class="line">sunion [key] [key-A] [key-B]  &#x2F;&#x2F; 并集，返回多个key中包含的所有元素</span><br><span class="line"></span><br><span class="line">sunionstore [key] [key-A] [key-B]  &#x2F;&#x2F; 并集，计算后将结果重置到key中</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-3-应用场景"><a href="#4-3-应用场景" class="headerlink" title="4.3 应用场景"></a>4.3 应用场景</h3><p>set类型具有无序、不可重复、支持并交差等特性，在电商、社交、视频网站等平台有着广泛的应用，通过将用户的标签信息存储在set结构中，可以向用户推荐相同兴趣爱好的好友，或者存储好友信息来展示相同好友功能等。</p><p>通过set集合提供的SADD、SRANDMEMBER命令可以实现抽奖功能。需要注意的是Redis在2.6版本才支持SADD命令的count参数，在3.2版本支持SRANDMEMBER命令的count参数，2.6版本以下仅支持单次获取一个随机元素。</p><h2 id="5-有序去重集合-zset"><a href="#5-有序去重集合-zset" class="headerlink" title="5.有序去重集合(zset)"></a>5.有序去重集合(zset)</h2><p>zset类型相对于set类型，每个元素多了一个score值，保证元素内容不重复的前提下，通过score值对元素自动排序，底层通过ziplist(压缩列表)或skiplist(跳跃表)实现，根据集合内部的元素个数、大小来决定使用哪种数据结构。</p><h3 id="5-1-数据结构"><a href="#5-1-数据结构" class="headerlink" title="5.1 数据结构"></a>5.1 数据结构</h3><p><img src="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><ul><li>ziplist的优缺点上面已经提到了。</li><li>skiplist也是一个有序的数据结构，为了避免链表结构这种查找元素需要从头到尾遍历的弊端，采用在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</li><li>zset还会维护一个字典结构(hashtable)，用于新增元素时判断是否已存在</li></ul><h3 id="5-2-常用命令"><a href="#5-2-常用命令" class="headerlink" title="5.2 常用命令"></a>5.2 常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">zadd [key] [score-1] [value-1] [score-2] [value-2]...  &#x2F;&#x2F; 添加单个或多个元素</span><br><span class="line"></span><br><span class="line">zrange [key] [start] [end] [withscores]  &#x2F;&#x2F; 根据范围列出zset的所有元素和对应score，如果end为-1则代表尾部，-2为倒数第二个元素</span><br><span class="line"></span><br><span class="line">zrangebyscore [key] [start-score] [end-score]  &#x2F;&#x2F; 根据score范围取元素(闭区间)</span><br><span class="line"></span><br><span class="line">zrangebyscore [key] [start-score] [end-score] [withscores]  &#x2F;&#x2F; 根据score范围取元素和对应score(闭区间)</span><br><span class="line"></span><br><span class="line">zrangebyscore [key] [start-score] [end-score] [withscores] limit [start-index] [size]  &#x2F;&#x2F; 根据score范围取元素和对应score(闭区间)，并分页</span><br><span class="line"></span><br><span class="line">zcard [key]  &#x2F;&#x2F; 获取元素个数</span><br><span class="line"></span><br><span class="line">zcard [key] [start-score] [end-score] &#x2F;&#x2F; 获取指定socre范围的元素个数</span><br><span class="line"></span><br><span class="line">zrank [key] [value]  &#x2F;&#x2F; 获取某个元素的下标值</span><br><span class="line"></span><br><span class="line">zscore [key] [value]  &#x2F;&#x2F; 获取某个元素的score值</span><br><span class="line"></span><br><span class="line">zrem [key] [value-1] [value-2]  &#x2F;&#x2F; 删除指定元素</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-3-应用场景"><a href="#5-3-应用场景" class="headerlink" title="5.3 应用场景"></a>5.3 应用场景</h3><p>既然数据结构的亮点是排序，那么应用场景自然也是和排序相关。应用最为广泛的就是排行榜系统，例如某个网站的文章访问量、视频播放量/点赞量、电商系统商品的销售量等等。</p><p>Redis的ZRANGEBYLEX命令支持对相同的score元素进行排序，实现方式是将元素字符串转化为二进制数组的字节数进行比较，因此可以用来实现手机号、姓名等排序场景。</p><h2 id="6-SDS-动态字符串"><a href="#6-SDS-动态字符串" class="headerlink" title="6.SDS(动态字符串)"></a>6.SDS(动态字符串)</h2><p>SDS的实现原理和Java的ArrayList差不多，都是采用动态扩容的方式来减少内存的频繁分配。当字符串长度小于1M时，扩容后为原来的两倍，当字符串超过1M时，每次固定扩容1M。Redis对SDS的扩容限制为最高512M，也就是说Redis的字符串最多可以存储512M的字符串，超过此容量会报错。</p><h3 id="6-1-内部结构"><a href="#6-1-内部结构" class="headerlink" title="6.1 内部结构"></a>6.1 内部结构</h3><p><img src="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/SDS%E6%89%A9%E5%AE%B9.png" class="lazyload" data-srcset="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/SDS%E6%89%A9%E5%AE%B9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h2 id="7-ziplist-压缩列表"><a href="#7-ziplist-压缩列表" class="headerlink" title="7.ziplist(压缩列表)"></a>7.ziplist(压缩列表)</h2><p>ziplist存在的意义就是压缩、节约内存，当然这种节约内存是相对于数组而言进行的优化，在Redis中存在的意义是为了弥补链表和哈希表在内存分配上的不足。</p><h3 id="7-1-数组存储的弊端"><a href="#7-1-数组存储的弊端" class="headerlink" title="7.1 数组存储的弊端"></a>7.1 数组存储的弊端</h3><p>我们都知道数组中每个元素的大小相同，在我们存储字符串的时候，不能保证存储的每个元素大小都相同，这就需要以占用内存最大的元素作为数组元素大小的标准。假设某个数组中最大的元素占用30KB，数组中小于30KB的元素存储就会出现部分下标的内存浪费:<br><img src="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5.png" class="lazyload" data-srcset="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h3 id="7-2-数组压缩存储"><a href="#7-2-数组压缩存储" class="headerlink" title="7.2 数组压缩存储"></a>7.2 数组压缩存储</h3><p>数组的优势在于分配一片连续的空间，提升CPU的内存访问效率，压缩列表保留了这个优势，同时在结构上将每个下标的进行压缩，压缩后的占用保持和对应元素大小一致，达到节约内存的目的:<br><img src="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-1.png" class="lazyload" data-srcset="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>这就有个问题了，每个元素占用的内存块不固定，无法向数组那样通过下标内存大小计算出下个元素的位置。因此压缩列表为每个元素添加了一个length属性，通过这个属性就很容易计算出下个元素的位置并提取数据了:<br><img src="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-2.png" class="lazyload" data-srcset="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h3 id="7-2-优缺点"><a href="#7-2-优缺点" class="headerlink" title="7.2 优缺点"></a>7.2 优缺点</h3><p>ziplist的特点是数据在内存中连续存储，不会像linkedlist、hashtable那样分散存储，不需要额外的存储指针来管理分散内存块之间的关联，再加上ziplist内存块中绝大多数空间都用来存储元素数据，且元素数据不会浪费内存空间，因此ziplist的优势在于节约内存。</p><p>当元素数量上升，或某个元素占用内存过大，会导致当前内存块大小无法满足而必须要扩展，内存块越大扩展的消耗就越大。对于list类型来说，提供的常用命令都是对列表的增删操作，大量元素下的情况下linkedlist更能胜任。对于hash类型来说，无论元素数量多大查询某个元素的时间复杂度永远是O(1)，也比ziplist的更合适。</p><h2 id="8-quicklist-压缩列表-链表混合"><a href="#8-quicklist-压缩列表-链表混合" class="headerlink" title="8.quicklist(压缩列表+链表混合)"></a>8.quicklist(压缩列表+链表混合)</h2><p>列表类型在Redis3.2版本以前采用ziplist和linkedlist进行存储，前者的思想是时间换空间，后者的思想是空间换时间，无论哪种都有很明显的优缺点为此Redis3.2版本开始对列表数据结构进行了改造，创建了quicklist代替ziplist和linkedlist。</p><h3 id="8-1-内存结构"><a href="#8-1-内存结构" class="headerlink" title="8.1 内存结构"></a>8.1 内存结构</h3><p>quicklist是ziplist和linkedlist的混合体，从宏观上讲仍然是一个linkedlist，而其中的每个元素都是一个zipList，zipList内部紧凑且连续的存储着真实的元素数据:<br><img src="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/quickList%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/quickList%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h3 id="8-1-新增节点过程"><a href="#8-1-新增节点过程" class="headerlink" title="8.1 新增节点过程"></a>8.1 新增节点过程</h3><p>quicklist仍然是将元素存储在zipList中，上面也讲过zipList不适合存储大型字符串和大量元素，扩容是他的硬伤。当新插入的元素无法放入zipList中时，quicklist会直接创建一个新的zipList并将数据存入，然后将新创建的zipList作为一个元素添到linkedlist中，删除也是同样的道理。</p><h2 id="9-skiplist-跳表"><a href="#9-skiplist-跳表" class="headerlink" title="9.skiplist(跳表)"></a>9.skiplist(跳表)</h2><p>对于链表来说，即使结构中的数据是有序存储，如果想要查询某个数据也只能从头到尾遍历，查询效率较低。skiplist也是一种有序链表，为了提高查询效率，skiplist在每个节点上建立索引，避免从头到尾遍历，是一种空间换时间的优化思想。</p><h3 id="9-1-内部结构"><a href="#9-1-内部结构" class="headerlink" title="9.1 内部结构"></a>9.1 内部结构</h3><p><font size="4"><b>传统链表获取第9个元素，需要通过指针地址查询9次:</b></font><br><img src="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%9F%E5%A7%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E9%81%8D%E5%8E%86.png" class="lazyload" data-srcset="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8E%9F%E5%A7%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E9%81%8D%E5%8E%86.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><font size="4"><b>跳表获取第9个元素，通过元素存储的索引，只需要通过指针地址查询5次:</b></font><br><img src="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%80%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8%E9%81%8D%E5%8E%86.png" class="lazyload" data-srcset="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%80%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8%E9%81%8D%E5%8E%86.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><font size="4"><b>如果获取的是第8个元素，则通过索引遍历到索引9(大于8)，然后退回索引7向后遍历:</b></font><br><img src="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%80%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8%E9%81%8D%E5%8E%86-2.png" class="lazyload" data-srcset="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%80%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8%E9%81%8D%E5%8E%86-2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><font size="4"><b>当元素数量增多，可以建立多层索引提高效率:</b></font><br><img src="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%9A%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8%E9%81%8D%E5%8E%86.png" class="lazyload" data-srcset="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A4%9A%E5%B1%82%E8%B7%B3%E8%B7%83%E8%A1%A8%E9%81%8D%E5%8E%86.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><font size="4"><b>Redis跳表结构:</b></font><br><img src="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/redis%E8%B7%B3%E8%A1%A8%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/2021/01/22/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/redis%E8%B7%B3%E8%A1%A8%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p class="p red">Redis跳表的元素索引存储的是链表下坐标，由于整个列表根据score排序存储，因此score的范围查询同样可以走索引。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存中间件 </category>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ(十一)高可靠</title>
      <link href="2020/09/24/RocketMQ%E9%AB%98%E5%8F%AF%E9%9D%A0/"/>
      <url>2020/09/24/RocketMQ%E9%AB%98%E5%8F%AF%E9%9D%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h2><p><font size="4"><b>Rebalance</b></font><br>集群模式下，由于各种原因导致触发rebalance，可能出现某个Consumer已经消费完一条消息，但是并没有向Broker提交offset，导致rebalance结束后，Consumer再次拉取此条数据进行消费。</p><p><font size="4"><b>TIMEOUT</b></font><br>Consumer没有及时向Broker反馈消息的处理状态，或者网络原因导致Broker没有收到反馈，Broker判定为TIMEOUT并触发重试机制，导致消息重复消费。</p><p><font size="4"><b>instanceName重复</b></font><br>RocketMQ会通过ClientConfig类的buildMQClientId方法为每个Consumer生成唯一标示cid:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buildMQClientId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地IP地址</span></span><br><span class="line">sb.append(<span class="keyword">this</span>.getClientIP());</span><br><span class="line">sb.append(<span class="string">&quot;@&quot;</span>);</span><br><span class="line"><span class="comment">// jvm进程ID</span></span><br><span class="line">sb.append(<span class="keyword">this</span>.getInstanceName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// unitName可以在启动时指定，默认null</span></span><br><span class="line"><span class="keyword">if</span> (!UtilAll.isBlank(<span class="keyword">this</span>.unitName)) &#123;</span><br><span class="line">sb.append(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">sb.append(<span class="keyword">this</span>.unitName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果某个消费组的Consumer完全在部署在一个服务器的不同Docker容器中，会出现instanceName相同的情况，默认情况下会导致不同Consumer的唯一标示cid相同。前面再均衡章节有讲述过重新分配是对cid集合、队列集合提取并排序，然后根据策略重新给Consumer分配队列。</p><p>如果Consumer的cid相同，会被分配到同一个队列进行消息拉取消费，也就是说一个队列会被同一消费组内多个Consumer订阅，那么投递到此队列的所有消息都会出现重复消费，甚至退化为广播模式。</p><p><font size="4"><b>分配策略不同</b></font><br>这个场景只是个人猜测，rebalance过程中，Consumer各自通过分配策略计算出自身需要拉取的队列，如果同一消费组内不同的Consumer设置的策略不同，会出现计算结果有重叠的队列，也就意味着一条消息被会被多个Consumer消费，造成消息重复。</p><p><font size="4"><b>解决方案</b></font><br>根据业务逻辑做幂等处理，或者使用redis等中间件对相关数据进行加锁，如果Consumer部署在同一个服务器的不同Docker容器中，则需要在Consumer手动设置随机instanceName(比如UUID)。</p><h2 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h2><p><font size="4"><b>Producer单向发送</b></font><br>Producer如果采用单向发送消息的方式，无法知晓消息是否发送成功，如果因为网络等原因Broker没有收到消息并落盘，会导致消息丢失。</p><p><font size="4"><b>异步刷盘</b></font><br>RocketMQ的异步刷盘机制，采用pageCache减少磁盘IO次数，并由操作系统定时将pageCache中的数据IO到磁盘中，如果消息存储在pageCache中还未落盘就发生宕机，会导致这部分消息丢失。</p><p><font size="4"><b>Broker无备份</b></font><br>即使Broker采用同步刷盘方式保存消息数据，由于特殊情况导致磁盘损坏，没有任何备份的情况下该Broker保存的所有消息全部丢失。</p><p><font size="4"><b>解决方案</b></font></p><ul><li>Producer端使用同步发送机制，如果有必要采用事务消息机制，确保消息投递到Broker进行存储。</li><li>Broker端开启主从模式并且复制方式设置为同步复制。</li><li>Consumer端确保消息处理完毕后提交offset，而不是接收消息后交给线程异步处理直接提交offset。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ(十)HA机制</title>
      <link href="2020/09/20/RocketMQHA%E6%9C%BA%E5%88%B6/"/>
      <url>2020/09/20/RocketMQHA%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><p>RocketMQ通过Broker的主从模式实现服务的高可用，Slave节点定时向Master节点发送请求同步最新数据，并且在4.5版本后支持主从节点的自动切换，当主节点出现故障后，根据RAFT算法从Slave节点中选择一个作为Master，保证Broker服务的正常生产消费。</p><p><font size="4"><b>主从模式优点:</b></font></p><ul><li>数据备份 : 数据冗余多份，一定程度上保证了Master出现不可恢复的故障后，数据不丢失。</li><li>高可用性 : 即使Master宕机，Consumer会自动重连到对应的Slave节点，不会出现消费停滞的情况。</li><li>读写分离 : Slave节点可以一定程度上缓解Master节点的读压力。</li></ul><h2 id="元数据复制"><a href="#元数据复制" class="headerlink" title="元数据复制"></a>元数据复制</h2><p>BrokerController类有个handleSlaveSynchronize方法，当role为BrokerRole.SLAVE时，会注册一个定时任务，每隔10秒钟执行一次SlaveSynchronize类的syncAll()方法，进行元数据的复制:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 同步topic信息</span></span><br><span class="line">        <span class="keyword">this</span>.syncTopicConfig();</span><br><span class="line">        <span class="comment">// 同步消费者偏移量信息</span></span><br><span class="line">        <span class="keyword">this</span>.syncConsumerOffset();</span><br><span class="line">        <span class="comment">// 同步延迟消费的偏移量信息</span></span><br><span class="line">        <span class="keyword">this</span>.syncDelayOffset();</span><br><span class="line">        <span class="comment">//同步订阅的消息组信息</span></span><br><span class="line">        <span class="keyword">this</span>.syncSubscriptionGroupConfig();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>没有什么复杂的逻辑，就是通过NameServer可以得到Master节点的服务地址，然后直接调用接口就能拿到所有数据信息。Consumer在拉取完消息并消费完毕后，仍然是向Master节点提交消费进度，Slave定时进行拉取刷新。当Master节点宕机后，Consumer无法向Master提交offset信息，对此RocketMQ提供了俩种机制确保不丢失offset信息。</p><p>第一种是Consumer端将消费进度存储在自身内存中并标记hasCommitOffsetFlag属性为true，仍然定时向Broker反馈offset信息，当Broker恢复后会收到并更新offset，从节点也会定时同步Master最新offset，如果再恢复期间Consumer宕机或关闭服务，仍然会丢失部分消费进度，造成数据重复消费。</p><p>第二种是消费者在向Broker节点拉取消息时，如果为Master节点，拉取消息后会顺带更新Master的offset。</p><h2 id="CommitLog复制"><a href="#CommitLog复制" class="headerlink" title="CommitLog复制"></a>CommitLog复制</h2><p><font size="4"><b>复制流程:</b></font><br><img src="/2020/09/20/RocketMQHA%E6%9C%BA%E5%88%B6/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B.png" class="lazyload" data-srcset="/2020/09/20/RocketMQHA%E6%9C%BA%E5%88%B6/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><ul><li>AcceptSocketService: Master启动后会运行此线程，监听并接受Slave的连接请求。</li><li>HAConnection: 每接受一个Slave的连接请求，都会创建一个对应的HAConnection，本质是对SocketChannel的read/write的封装。</li><li>SocketReadService: 由HAConnection创建，是对SocketChannel中read的封装，作用是读取slave发送的已同步offset。</li><li>SocketWriteService: 由HAConnection创建，是对SocketChannel中write的封装，作用是将消息发送给Slave。</li><li>GroupTransferService: 同步复制模式下，将Master挂起直到Slave发出同步成功信号后唤醒。</li></ul><p><font size="4"><b>异步复制</b></font><br>异步复制的好处是将消息写入commitlog后直接返回，无需关心与Slave的数据同步问题，消息同步给Slave的逻辑处理由HAConnection异步处理。消息持久化后无需等待Slave确认是否存储成功，从效率上高于同步复制，缺点是如果Master宕机，由于数据同步有延迟导致Slave和Master存在一定程度的数据不一致问题，适用于数据可靠性要求不高的业务场景。</p><p><font size="4"><b>同步复制</b></font><br>同步复制与异步复制的唯一区别是持久化消息后，需等待Slave节点返回此消息的同步结果，期间被GroupTransferService线程使用CountDownLatch阻塞挂起，直到Slave返回成功结果或超时再进行唤醒。这种模式不会造成消息丢失，但是工作效率相对降低，适用于数据可靠性要求很高的业务场景。</p><p>判断主从同步是否完成的依据是Slave中已成功复制的最大消息偏移量是否大于等于消息生产者发送消息后消息服务端返回的下一条消息的起始偏移量。如果大于等于说明主从同步完成，否则等待1秒后继续检查，每一批任务中循环5次加上初始的一次一共6次，6次还没确认就关闭连接。</p><p class="p red">这里只需要有一个Slave复制成功并成功应答即算成功。</p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>传统的读写分离是完全按照Master节点写入、Slave节点读取的规则进行，而RocketMQ有属于自己的一套读写分离逻辑。在默认情况下RocketMQ会优先选择从Master进行拉取消息，并且计算堆积量是否超过物理内存40%，表示主服务繁忙，当超过时则建议Consumer下次从Slave拉取消息。</p><p>开启读写分离需要Master与Slave添加配置slaveReadEnable=true，默认为false。</p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ(九)事务消息</title>
      <link href="2020/09/18/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/"/>
      <url>2020/09/18/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RocketMQ事务消息本质是将发送消息和本地数据库操作融合为一个事务，要么一起成功，要么一起失败，不会存在一个操作成功另一操作失败的情况，说明白点就是Broker端与数据库端持久化数据的分布式事务问题。</p><p>例如电商系统中，用户下单成功后会得到一定数量的积分奖励，但是订单系统与积分系统是俩个独立的微服务，无法放在一个事务里执行。这种业务场景可以在订单系统中执行数据库insert订单的操作，然后将增加积分以RocketMQ形式异步发送处理。</p><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><p>阿里官方的RocketMQ事务消息发送流程图:<br><img src="/2020/09/18/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" class="lazyload" data-srcset="/2020/09/18/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><font size="4"><b>RocketMQ参考2PC的分布式事务解决方案，将RocketMQ事务消息的发送分解为俩个阶段:</b></font></p><ul><li><p>第一阶段：发送消息，Producer把消息发送到Broker，但是此时该消息还不能被投递给消费者，此时消息的状态被称为半消息。</p></li><li><p>第二阶段：请求Broker进行消息的二次确认，根据本地数据库事务执行的成功或失败，对半消息进行提交或者回滚，成功提交的消息才可以被投递给消费者，回滚的消息会被删除。</p></li></ul><p><font size="4"><b>事务状态回查:</b></font><br>整个流程在执行过程中，可能由于网络或者服务器宕机等原因导致Broker没有收到二次确认请求，那么数据库操作和消息推送就会出现数据一致性问题。因此Broker端会启动一个线程定时扫描本地存储的半消息，并向Producer发起事务状态回查，根据回查结果决定消息的去留。</p><p class="p red">由事务状态回查机制可以断定，RocketMQ并不能保证分布式事务的强一致性，仅仅保证分布式事务的最终一致性，还不是100%保证。因为Broker存储的半消息同样会被删除策略扫描，如果因为各种原因没能及时处理二次确认，或者消息转移到队列但是Consumer一直消费失败，都会导致Conusmer错过此消息的逻辑处理。</p><p class="p red">对于Producer端要保证回查接口能正常调用，对于Consumer端要保证一定次数的消费失败后，将消息写入数据库并开启定时器扫描继续处理，然后采用发短信或钉钉、企业微信等办公APP的内部通知方式告知管理员，对消息进行人工排查处理。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>订单新增业务层:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(OrderInfo orderInfo)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">orderMapper.insert(orderInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他逻辑...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">existById</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> id == <span class="keyword">null</span> ? <span class="keyword">false</span> : orderMapper.existById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RocketMQ本地事务监听对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQTransactionListener(txProducerGroup = &quot;order_integral_tx_producer_group&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderIntegralTransactionListener</span> <span class="keyword">implements</span> <span class="title">RocketMQLocalTransactionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 半消息发送成功后需要执行的本地事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            String jsonStr = <span class="keyword">new</span> String(msg.getBody());</span><br><span class="line">OrderInfo orderInfo = JSONObject.parseObject(jsonStr, OrderInfo.class);</span><br><span class="line">            orderService.insert(orderInfo);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;本地事务执行异常, 回滚消息&quot;</span>, e.getErrorMessage());</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Broker进行事务状态回查调用的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt messageExt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析半消息</span></span><br><span class="line">    String halfMessage = <span class="keyword">new</span> String(messageExt.getBody(), RemotingHelper.DEFAULT_CHARSET);</span><br><span class="line">    OrderInfo orderInfo = JSONObject.parseObject(halfMessage, OrderInfo.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询数据库是否存在</span></span><br><span class="line"><span class="keyword">boolean</span> exist = orderService.existById(orderInfo.getId());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据订单查询结果决定返回状态</span></span><br><span class="line">RocketMQLocalTransactionState localTransactionState = exist </span><br><span class="line">? LocalTransactionState.COMMIT_MESSAGE : LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;本地事务状态回查执行完毕, halfMessage:&#123;&#125;, localTransactionState:&#123;&#125;&quot;</span>, </span><br><span class="line">halfMessage, localTransactionState);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 失败的最好记录下来，方便数据异常排查</span></span><br><span class="line"><span class="keyword">if</span>(!exist)&#123;</span><br><span class="line"><span class="comment">// 记录到数据库或NoSQL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> localTransactionState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订单新增控制层:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/insert&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(<span class="meta">@RequestBody</span> OrderInfo orderInfo)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">String message = JSONObject.toJSONString(orderInfo);</span><br><span class="line">Message sendMsg = <span class="keyword">new</span> Message(<span class="string">&quot;ORDER_INTEGRAL&quot;</span>, <span class="string">&quot;*&quot;</span>, message.getBytes());</span><br><span class="line">producer.sendMessageInTransaction(sendMsg, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">return</span> Result.success(<span class="string">&quot;新增成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ(八)再均衡</title>
      <link href="2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/"/>
      <url>2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>在集群消费模式下，消费组内各Consumer均摊订阅的队列信息，也就是消费端的负载均衡机制。在消费过程中如果队列、消费组信息发生变化，则需要根据分配策略对组内所有Consumer重新分配队列，这个过程就是再均衡(rebalance)。</p><h2 id="队列变化"><a href="#队列变化" class="headerlink" title="队列变化"></a>队列变化</h2><p>1.当Broker节点因为宕机、停止等原因导致服务不可用时，触发一次rebalance，重新分配消费组队列:<br><img src="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/%E5%AE%95%E6%9C%BA%E6%88%96%E9%80%80%E5%87%BA%E5%BC%95%E8%B5%B7rebalance.png" class="lazyload" data-srcset="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/%E5%AE%95%E6%9C%BA%E6%88%96%E9%80%80%E5%87%BA%E5%BC%95%E8%B5%B7rebalance.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>2.当故障Broker节点重新启动后，触发一次rebalance，重新分配消费组的订阅队列:<br><img src="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/Broker%E5%90%AF%E5%8A%A8%E6%96%B0%E8%8A%82%E7%82%B9%E5%BC%95%E8%B5%B7rebalance.png" class="lazyload" data-srcset="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/Broker%E5%90%AF%E5%8A%A8%E6%96%B0%E8%8A%82%E7%82%B9%E5%BC%95%E8%B5%B7rebalance.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>3.当Broker节点的某个topic进行队列扩容时(为了明显一点，使用环形分配策略):<br><img src="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/%E9%98%9F%E5%88%97%E6%89%A9%E5%AE%B9%E5%BC%95%E8%B5%B7rebalance.png" class="lazyload" data-srcset="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/%E9%98%9F%E5%88%97%E6%89%A9%E5%AE%B9%E5%BC%95%E8%B5%B7rebalance.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>4.当Broker节点的某个topic进行队列缩容时:<br><img src="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/%E9%98%9F%E5%88%97%E7%BC%A9%E5%AE%B9%E5%BC%95%E8%B5%B7rebalance.png" class="lazyload" data-srcset="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/%E9%98%9F%E5%88%97%E7%BC%A9%E5%AE%B9%E5%BC%95%E8%B5%B7rebalance.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h2 id="消费组变化"><a href="#消费组变化" class="headerlink" title="消费组变化"></a>消费组变化</h2><p>1.当消费组启动一个Consumer时，触发一次rebalance，重新分配消费组队列:<br><img src="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/%E6%96%B0%E5%90%AF%E5%8A%A8consumer%E5%BC%95%E8%B5%B7rebalance.png" class="lazyload" data-srcset="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/%E6%96%B0%E5%90%AF%E5%8A%A8consumer%E5%BC%95%E8%B5%B7rebalance.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>2.当消费组某个Consumer因为宕机、停止、网络异常导致无法与Broker心跳等原因停止消费时，触发一次rebalance，重新分配消费组队列:<br><img src="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/consumer%E9%80%80%E5%87%BA%E5%BC%95%E8%B5%B7rebalance.png" class="lazyload" data-srcset="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/consumer%E9%80%80%E5%87%BA%E5%BC%95%E8%B5%B7rebalance.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h2 id="rebalance过程"><a href="#rebalance过程" class="headerlink" title="rebalance过程"></a>rebalance过程</h2><p>整个过程由Broker检测并通知Consumer端，Consumer端接收到通知后调用RebalanceImpl类的rebalanceByTopic()方法进行rebalance。rebalance是以topic+消费组为粒度对队列进行重分配的，例如某个组订阅了5个topic，那么会遍历这5个topic并分别调用rebalanceByTopic()方法执行rebalance。</p><p><img src="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/rebalance%E8%BF%87%E7%A8%8B.jpg" class="lazyload" data-srcset="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/rebalance%E8%BF%87%E7%A8%8B.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p class="p red">注意:由于rebalance都是通过Broker端发起通知，为了防止特殊原因导致Consumer端没有收到通知错过rebalance，Consumer端会开启RebalanceService线程，每隔10秒钟对订阅的topic进行一次rebalance。</p><h2 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h2><p><font size="4"><b>平均分配策略(默认)(AllocateMessageQueueAveragely)</b></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title">allocate</span><span class="params">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,List&lt;String&gt; cidAll)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//省略参数校验代码...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前Consumer在消费者集合(cidAll)中下标的位置</span></span><br><span class="line"><span class="keyword">int</span> index = cidAll.indexOf(currentCID);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Queue数除以Consumer数取余</span></span><br><span class="line"><span class="comment">     * 如果mod等于0，说明Queue可以被平均分配</span></span><br><span class="line"><span class="comment">     * 如果mod大于0，说明不可以被平均分配，一定程度平均分配后仍剩余mod个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">int</span> mod = mqAll.size() % cidAll.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * averageSize代表当前Consumer可以得到的队列数</span></span><br><span class="line"><span class="comment">     * Queue数小于等于Consumer，averageSize=1，也就是平均分配1个队列(虽然靠后的Consumer可能啥都没分到)</span></span><br><span class="line"><span class="comment">     * Queue数大于Consumer的情况下，根据Queue能否被Consumer平均分配继续处理:</span></span><br><span class="line"><span class="comment">     * 如果能平均分配，直接计算Queue数除以Consumer数得到平均值</span></span><br><span class="line"><span class="comment">     * 如果不能平均分配，继续判断当前Consumer在cidAll的index是否小于mod:</span></span><br><span class="line"><span class="comment">     *如果小于则说明最大化平均后剩余的mod个队列还有自己一份，averageSize = Queue数除以Consumer数取整后+1</span></span><br><span class="line"><span class="comment">     *如果大于等于说明最大化平均后剩余的mod个队列和自己没缘分了，averageSize = Queue数除以Consumer数取整</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">int</span> averageSize =</span><br><span class="line">mqAll.size() &lt;= cidAll.size() ? <span class="number">1</span> : (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size()</span><br><span class="line">+ <span class="number">1</span> : mqAll.size() / cidAll.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后续会遍历mqAll集合提取属于当前Consumer的Queue，这里需要计算遍历的起始坐标</span></span><br><span class="line"><span class="comment">     * 如果不能平均消费，且剩余的mod个队列有自己一份，startIndex = index * averageSize</span></span><br><span class="line"><span class="comment">     * 如果不能平均消费，且剩余的mod个队列和自己无缘，startIndex = index * averageSize + mod</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">int</span> startIndex = (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据Math.min()计算消费者最终需要消费的数量</span></span><br><span class="line"><span class="keyword">int</span> range = Math.min(averageSize, mqAll.size() - startIndex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历提取</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">result.add(mqAll.get((startIndex + i) % mqAll.size()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各种情况下Queue分配情况:<br><img src="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/%E5%B9%B3%E5%9D%87%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.png" class="lazyload" data-srcset="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/%E5%B9%B3%E5%9D%87%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><font size="4"><b>环形分配策略(AllocateMessageQueueAveragelyByCircle)</b></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title">allocate</span><span class="params">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll, List&lt;String&gt; cidAll)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//省略参数校验代码...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前Consumer在消费者集合(cidAll)中下标的位置</span></span><br><span class="line"><span class="keyword">int</span> index = cidAll.indexOf(currentCID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以index作为起点遍历Queue集合</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; mqAll.size(); i++) &#123;</span><br><span class="line"><span class="comment">// 对下标取模(mod), 如果与index相等, 则存储到result集合中</span></span><br><span class="line"><span class="keyword">if</span> (i % cidAll.size() == index) &#123;</span><br><span class="line">result.add(mqAll.get(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各种情况下Queue分配情况:<br><img src="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/%E7%8E%AF%E5%BD%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.png" class="lazyload" data-srcset="/2020/09/18/RocketMQ%E5%86%8D%E5%9D%87%E8%A1%A1/%E7%8E%AF%E5%BD%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><font size="4"><b>手动配置分配策略(AllocateMessageQueueByConfig)</b></font><br>自己发挥</p><p><font size="4"><b>机房分配策略(AllocateMessageQueueByMachineRoom)</b></font><br>感觉与平均分配策略的逻辑差不多，就近机房的逻辑判断没看懂</p><p><font size="4"><b>一致性哈希分配策略(AllocateMessageQueueConsistentHash)</b></font><br>牵涉到一致性哈希算法，以后在更新</p><h2 id="与kafka区别"><a href="#与kafka区别" class="headerlink" title="与kafka区别"></a>与kafka区别</h2><p>Kafka是在消费组的众多Consumer中，选举一个作为Group Leader，由这个Group Leader来计算出分配结果并同步给其他Consumer，这种机制很好的避免了脑裂问题。</p><p>RocketMQ中，Consumer端无论是主动收到通知、还是RebalanceService线程触发的rebalance，都是每个Consumer自己按照分配策略给自己重新分配队列。如果消费组内各Consumer设置的分配策略以及获取的队列信息相同，那么计算出的分配结果也是相同的，不会有任何问题，如果不相同会导致脑裂，造成多个Consumer抢夺一个队列，有的队列无人问津。</p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ(七)消费端</title>
      <link href="2020/09/11/RocketMQ%E6%B6%88%E8%B4%B9%E7%AB%AF/"/>
      <url>2020/09/11/RocketMQ%E6%B6%88%E8%B4%B9%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="springboot1-X集成"><a href="#springboot1-X集成" class="headerlink" title="springboot1.X集成"></a>springboot1.X集成</h2><p><font size="4"><b>RocketMQ依赖</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.rocketmq&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;rocketmq-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;4.7.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><font size="4"><b>application.properties</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 服务端口</span><br><span class="line">server.port&#x3D;8082</span><br><span class="line"></span><br><span class="line"># 消费者分组</span><br><span class="line">rocketmq.consumer.groupName&#x3D;GROUP_A</span><br><span class="line"></span><br><span class="line"># MQ注册中心地地址</span><br><span class="line">rocketmq.producer.namesrvAddr&#x3D;localhost:9876</span><br></pre></td></tr></table></figure><p><font size="4"><b>启动Consumer</b></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderReminderConsumer</span> <span class="keyword">implements</span> <span class="title">MessageListenerConcurrently</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;rocketmq.consumer.groupName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String groupName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;rocketmq.producer.namesrvAddr&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nameSrvAddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置消费组</span></span><br><span class="line">            consumer.setConsumerGroup(groupName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置注册中心地址</span></span><br><span class="line">            consumer.setNamesrvAddr(nameSrvAddr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置偏移量</span></span><br><span class="line">            consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置消费模式</span></span><br><span class="line">            consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置订阅topic和tags，其中tags设置多个时使用||分割</span></span><br><span class="line">            consumer.subscribe(<span class="string">&quot;ORDER_REMINDER&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每次拉取10条</span></span><br><span class="line">            consumer.setConsumeMessageBatchMaxSize(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置消费失败重试次数</span></span><br><span class="line">            consumer.setMaxReconsumeTimes(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置监听者(自身)</span></span><br><span class="line">            consumer.registerMessageListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动</span></span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消费者启动失败......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 消费处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; messageExtList, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(MessageExt messageExt : messageExtList)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(messageExt.getBody(), RemotingHelper.DEFAULT_CHARSET);</span><br><span class="line">                log.info(<span class="string">&quot;接收消息成功, topic:&#123;&#125;, tags:&#123;&#125;, messageId:&#123;&#125;, messageKey:&#123;&#125;, message:&#123;&#125;&quot;</span>,</span><br><span class="line">                        messageExt.getTopic(),</span><br><span class="line">                        messageExt.getTags(),</span><br><span class="line">                        messageExt.getMsgId(),</span><br><span class="line">                        messageExt.getKeys(),</span><br><span class="line">                        message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;消费失败&quot;</span>, e);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 关闭Consumer</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        consumer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推拉模式"><a href="#推拉模式" class="headerlink" title="推拉模式"></a>推拉模式</h2><p>Consumer可以使用推模式、拉模式从Broker节点中获取消息并消费，分别对应DefaultMQPushConsumer(推模式)和DefaultMQPullConsumer(拉模式)俩个对象来实现。</p><p><font size="4"><b>拉模式(PULL)</b></font><br>拉模式获取消息，具体实现需要使用者在Consumer自己编写代码，先通过NameServer获取订阅topic对应的MessageQueue列表，遍历此列表对每个MessageQueue对象批量获取消息，并记录该队列下一次要取的开始offset，获取完毕后在处理下一个MessageQueue。</p><p>这种模式由Consumer端主动向Broker节点发送请求拉取消息，拉取的相关逻辑可以自由控制(比如拉取频率、单次批量拉取数量等)，因此不会出现消息堆积的情况，只要专注维护每个队列的offset即可(最好在数据库维护，能与消费业务在一个事务中更好)。缺点也很明显，Consmuer端无法准确地决定何时去拉取最新的消息，循环时间间隔太短容易忙等，浪费CPU资源，时间间隔太长client的处理能力会下降，导致有些时候消息延迟。</p><p>于是阿里采用长轮询的方式来解决这个问题，Consumer发送请求到Broker拉取消息，如果Broker发现没有消息不会直接返回，而是把连接挂起(wait)，直到Producer投递新的消息过来在对请求线程进行唤醒返回(notify)<br>。为了避免请求连接被阻塞对系统的开销，需要使用者根据自身业务场景合理的评估时间间隔，设置消费者对于长轮询的等待时间，由consumerTimeoutMillisWhenSuspend属性控制。</p><p><font size="4"><b>推模式(PUSH)</b></font><br>推模式获取消息，DefaultMQPushConsumer在启动时需指定MessageListenerConcurrently监听器，用于监听最新的消息，达到实时消费的效果。然而严格意义上讲，RcoketMQ并没有提供任何Broker主动推消息的功能，PUSH的本质是consumer对PULL的一层封装，让使用者感觉消息是通过Broker推送过来的。</p><p>DefaultMQPushConsumer在启动成功后，会启动一个线程并运行类似while(true)的方法疯狂的去pullRequestQueue队列里面take()元素pullRequest，可以理解为队列里面的每一个pullRequest元素都是一个需求，需求的内容就是去Broker拉取消息(PullRequest对象就是拉取消息的参数)。如果没有元素说明此时不需要拉取消息，将线程自身挂起，如果有就取出并调用pullMessage方法访问Broker进行拉取，pullMessage方法内部是对PULL的一层封装，拉取到消息后扔给线程池的消费处理函数，无论拉没拉取到消息，都会将pullRequest元素放回队列。</p><p>由此可以看出推模式的本质还是拉模式，区别在于推模式是写个死循环一直调用PULL，相当于和Broker一直保持联系。拉消息、消费消息由不同的线程取处理，这就导致一个问题，如果订阅的主题，Producer投递消息的速度远超Consumer的消费能力，会导致消费端拉消息的线程拉取了大量的消息不能及时被消费线程处理掉，造成消息堆积。</p><p>最后messageListenerConcurrently的作用貌似是监听订阅的topic发生变化后，通知用。</p><h2 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h2><p>RocketMQ的Consumer支持集群和广播俩种消费模式，可在初始化方法中指定，消费模式用于决定Consumer订阅Broker节点中topic-queue的分配规则。</p><p><font size="4"><b>集群模式</b></font></p><p>集群模式中，消费组名称相同的Consumer实例被视为一个Consumer集群，集群内部所有Consumer实例共同承担订阅的topic，在各个Borker节点中队列的消费工作。比如现在有个名为order的topic在Broker-a和Broker-b节点中各有4个队列，并且Group_A消费组有3个Consumer在订阅，Group_B消费组有4个Consumer在订阅:<br><img src="/2020/09/11/RocketMQ%E6%B6%88%E8%B4%B9%E7%AB%AF/%E6%B6%88%E8%B4%B9%E7%BB%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.png" class="lazyload" data-srcset="/2020/09/11/RocketMQ%E6%B6%88%E8%B4%B9%E7%AB%AF/%E6%B6%88%E8%B4%B9%E7%BB%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>图中可以看出不同的消费组分配情况相互隔离，互不影响。同一组内的各Consumer实例按照分配策略对应一部分队列，如果总队列数正好等于Consmuer数，那么直接按一对一方式分配；如果总队列数大于Consmuer数并且是其倍数，按照一对多的方式平均分配(如上图的GROUP_B)；如果总队列数大于Consmuer数但不是其倍数，仍然按照一对多的方式，会有个别Consumer被多分配一个(如上图的GROUP_A)；<span class="p red">如果总队列数小于Consmuer数，先将队列按一对一分配出去，剩下的Consumer不会被分配到任何队列，也就接收不到任何消息。</span></p><p>将多个Consumer划分到一个组内的作用是topic的消息进行分片，采用并行处理的方式提高消费能力。另外一个作用是实现消费失败重试机制，因为Consumer在进行消费时可能因为各种异常导致消费逻辑执行失败，并返回RECONSUME_LATER状态，遇到这种情况会将消息回发到Broker，然后Broker尝试重新发送。</p><p>最后，在使用集群模式进行消费时，所有消费组名称以及订阅topic的所有队列的消费进度(逻辑偏移量)，全部存储在对应的Broker节点上(上篇文章讲到的config文件夹的consumerOffset.json文件中)，Consumer不进行任何进度的存储。</p><p><font size="4"><b>广播模式</b></font></p><p>广播模式中，任何一条消息都会发送到消费组内所有Consumer进行消费。也就是说消费组内有几个Consumer实例，消息就会被处理几遍。在实现方式上较集群模式简单一些，不用考虑队列分配情况:<br><img src="/2020/09/11/RocketMQ%E6%B6%88%E8%B4%B9%E7%AB%AF/%E6%B6%88%E8%B4%B9%E7%BB%84%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F.png" class="lazyload" data-srcset="/2020/09/11/RocketMQ%E6%B6%88%E8%B4%B9%E7%AB%AF/%E6%B6%88%E8%B4%B9%E7%BB%84%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>与集群模式不同，广播模式下的Consumer在出现消费失败时(返回RECONSUME_LATER状态)不会进行失败重投，所以使用广播模式要额外关注消费失败情况，做好应对措施，防止消费失败引起的消息丢失。另外一个不同点是，消费组内每个Consumer消费进度由自身维护，源码中是LocalFileOffsetStore类负责记录存储。</p><h2 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h2><p>顺序消费首先要保证Producer将顺序的消息发送到同一个Queue中，然后单个Queue只会被单个Consumer消费，这一点是由RocketMQ的分配机制保证。以上的Demo代码是使用MessageListenerConcurrently并发监听，说明白点就是Consumer即使顺序的拉取到消息，也会采用多线程并行消费消息，仍然无法保证消费的顺序。</p><p>对此RocketMQ中提供了MessageListenerOrderly来实现真正的顺序消费，实现此接口并重写ConsumeOrderlyStatus方法，其他与并行消费没区别:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderReminderConsumer</span> <span class="keyword">implements</span> <span class="title">MessageListenerOrderly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeOrderlyContext consumeOrderlyContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费逻辑...</span></span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MessageListenerOrderly使用风险:</p><ul><li>并行消费变为串行消费，降低了Consumer的消费能力</li><li>如果某条消息在消费失败时，不会将失败告诉Broker执行重试，并且队列消费暂停</li></ul><h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><p>Tag、SQL92和类过滤器(新版去除)</p><h2 id="订阅关系一致"><a href="#订阅关系一致" class="headerlink" title="订阅关系一致"></a>订阅关系一致</h2><p>同一个消费组内的所有Consumer还需遵循订阅关系一致性原则，才能保证消息的正常消费。这个原则要求消费组内的所有Consumer订阅的topic和对应tags必须保持一致，一旦订阅关系不一致就会导致消费混乱，甚至消息丢失。</p><p>消费组的订阅信息在Broker的存储结构由ConsumerManager类的consumerTable进行维护:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* Group */</span>, ConsumerGroupInfo&gt; consumerTable = </span><br><span class="line">    <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConsumerGroupInfo&gt;(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>ConsumerGroupInfo类存储了消费组的具体结构，类内部的subscriptionTable存储的topic的订阅详情:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* Topic */</span>, SubscriptionData&gt; subscriptionTable =</span><br><span class="line">    <span class="keyword">new</span> ConcurrentHashMap&lt;String, SubscriptionData&gt;();</span><br></pre></td></tr></table></figure><p>SubscriptionData类存储了订阅的所有规则信息:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriptionData</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">SubscriptionData</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订阅所有消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String SUB_ALL = <span class="string">&quot;*&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类过滤模式标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> classFilterMode = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// topic名称</span></span><br><span class="line">    <span class="keyword">private</span> String topic;</span><br><span class="line">    <span class="comment">// 订阅tags，多个可用||隔开</span></span><br><span class="line">    <span class="keyword">private</span> String subString;</span><br><span class="line">    <span class="comment">// 订阅tags集合</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; tagsSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="comment">// tagcode集合</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; codeSet = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 订阅版本时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> subVersion = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 表达式类型</span></span><br><span class="line">    <span class="keyword">private</span> String expressionType = ExpressionType.TAG;</span><br><span class="line">    <span class="comment">// 构造器、hashCode、equals、getset等...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面结构可以看出，消费组的订阅信息是以groupName为单位进行保存。当Consumer启动后，会将自己的订阅信息(List<SubscriptionData>)发送到对应的Broker中，之后还会采取心跳机制不断将这些信息刷新到Broker中。Broker以新的订阅信息为基准与本地的进行对比，该新增的新增，该删除的删除，如果topic对应的SubscriptionData已存在，则根据subVersion属性进行对比，新的覆盖旧的。也就是说如果同一组内的Consumer订阅关系不一致，会导致该组在Broker中的订阅信息会因为新Consumer的加入或者心跳机制的刷新，不断覆盖掉旧信息，那这和消费混乱有什么关系呢？</SubscriptionData></p><p>要想搞清楚这个问题，还需要清楚Consumer是如何去Broker拉取消息的，上面的推拉模式也简单说过，推模式是将PullRequest作为参数拉取消息，那就要知道PullRequest对象内部都有什么属性:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PullRequest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 消费组名</span></span><br><span class="line">    <span class="keyword">private</span> String consumerGroup;</span><br><span class="line">    <span class="comment">// 消息队列对象，内部包含queueId以及topic</span></span><br><span class="line">    <span class="keyword">private</span> MessageQueue messageQueue;</span><br><span class="line">    <span class="comment">// 不重要</span></span><br><span class="line">    <span class="keyword">private</span> ProcessQueue processQueue;</span><br><span class="line">    <span class="comment">// 拉取的坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line">    <span class="comment">// 不重要</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lockedFirst = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里问题就差不多搞清楚了，Consumer在拉取消息时，根据consumerGroup和topic获取到SubscriptionData对象，也就是消费组的订阅信息。然后根据对应的queueId以及nextOffset拉取消息，并按照订阅消息配置的tags以及filter等对消息进行筛选拉取，消费完毕后提交offset。</p><p>由于同一时刻NameServer保存的订阅信息只有一份，当同一消费组内的Consumer订阅关系不一致时，与NameServer保存的信息不符合的那部分Consumer会拉取到不属于自己的消息。比如tags不一致，会拉取到别的tags，如果topic不一致，直接报the consumer’s subscription not exist错误。</p><h2 id="消费重试"><a href="#消费重试" class="headerlink" title="消费重试"></a>消费重试</h2><p>Consumer端的消费失败分为俩种，一种是EXCEPTION，另一种是TIMEOUT，当Broker感知到Consumer端消费失败后，会根据不同的失败类型采取不同的措施。<span class="p red">Consumer的消费重试机制，仅仅在集群模式中有效，广播模式不会进行消息重试。</span></p><p><font size="4"><b>EXCEPTION</b></font><br>exception是指Consumer正常接收到消息后，在进行消费处理过程中发生异常，比如要将消息的内容插入数据库，正巧此时数据库宕机，又或者消息对应数据库查询出来的数据是脏数据，导致逻辑处理走不通等。这些都会引起消费逻辑的异常，通常我们会将消息的处理代码块使用try catch包起来(上面的例子)，如果正常执行就返回CONSUME_SUCCESS，抓取到异常就返回RECONSUME_LATER。</p><p>无论如何，Broker都会收到Consumer端的消费结果情况，如果成功就更新offset，如果失败重新尝试推送，重试次数默认是16次，考虑到异常恢复起来需要一些时间，所以每次重试都有一定的时间间隔，间隔依次为1S,5S,10S,30S,1M,2M····2H。RocketMQ会为每个消费组创建一个格式为%RETRY%+consumerGroup的重试队列，对于消费失败的消息根据间隔时间将其放入延迟topic(SCHEDULE_TOPIC_XXXX)，到达延迟时间点后发送到对应的重试队列，然后再次投递到Consumer。<br><img src="/2020/09/11/RocketMQ%E6%B6%88%E8%B4%B9%E7%AB%AF/%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95.png" class="lazyload" data-srcset="/2020/09/11/RocketMQ%E6%B6%88%E8%B4%B9%E7%AB%AF/%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>实际开发中也许并不需要这么多重试次数，比如只需要3次重试次数，超过这个次数就记录到数据库或缓存，然后开启定时器等扫描在处理，或者人为干涉修复。这种方式首先要在Consumer设置重试次数，然后在消费前调用MessageExt类的getReconsumeTimes()方法查看重试次数，如果超过设置次数则将消息保存到数据库或缓存，然后直接返回CONSUME_SUCCESS。</p><p><font size="4"><b>TIMEOUT</b></font><br>TIMEOUT是指因为种种原因导致Consumer端没有及时给Broker反馈消息的处理状态，导致Broker认为消息并没有被消费掉，然后会一直发送消息。超时时间可以调用Consumer的setConsumeTimeout()方法设置，默认为15(单位分钟)。</p><span class="p red">注:超时引起的重试不受重试次数条件的影响，会无限制的发送给Consumer直到成功。</span><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>当消息遇到EXCEPTION，并达到重试次数限制后仍然未成功，消息会投递到DLQ死信队列(%DLQ%RetryConsumer)，可以在控制台进行查看:<br><img src="/2020/09/11/RocketMQ%E6%B6%88%E8%B4%B9%E7%AB%AF/%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97.png" class="lazyload" data-srcset="/2020/09/11/RocketMQ%E6%B6%88%E8%B4%B9%E7%AB%AF/%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>死信队列特点：</p><ul><li>死信队列是以%DLQ%+消费组名称进行命名，换句话说每个消费组都有自己的死信队列</li><li>消费组在未产生死信消息的情况下，不会创建死信队列</li><li>消费组的死信队列包含组内所有的topic所属的死信消息，换句话说组内订阅的topic共享一个死信队列</li></ul><h2 id="消息回溯"><a href="#消息回溯" class="headerlink" title="消息回溯"></a>消息回溯</h2><p>回溯消费是指Consumer已经消费成功的消息，由于业务上需求需要重新消费，消息回溯就是对这种场景的支持。Consumer是基于队列的offset进行拉取消息，因此消息回溯的只需要重新指定topic和queue的offset即可，另外RocketMQ还支持按照时间回溯消费，时间维度精确到毫秒，可以向前回溯，也可以向后回溯。</p><p><font size="4"><b>Consumer启动重置offset</b></font><br>在Consumer端配置中，可以通过setConsumeFromWhere(ConsumeFromWhere)方法设置启动后消费的起点offset，其中传入参数ConsumeFromWhere是个枚举类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public enum ConsumeFromWhere &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 一个新的订阅组第一次启动从队列的最后位置开始消费&lt;br&gt;</span><br><span class="line">     * 后续再启动接着上次消费的进度开始消费</span><br><span class="line">     *&#x2F;</span><br><span class="line">    CONSUME_FROM_LAST_OFFSET,</span><br><span class="line"></span><br><span class="line">    &#x2F;** @deprecated *&#x2F;</span><br><span class="line">    @Deprecated</span><br><span class="line">    CONSUME_FROM_LAST_OFFSET_AND_FROM_MIN_WHEN_BOOT_FIRST,</span><br><span class="line"></span><br><span class="line">    &#x2F;** @deprecated *&#x2F;</span><br><span class="line">    @Deprecated</span><br><span class="line">    CONSUME_FROM_MIN_OFFSET,</span><br><span class="line"></span><br><span class="line">    &#x2F;** @deprecated *&#x2F;</span><br><span class="line">    @Deprecated</span><br><span class="line">    CONSUME_FROM_MAX_OFFSET,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 一个新的订阅组第一次启动从队列的最前位置开始消费</span><br><span class="line">     * 后续再启动接着上次消费的进度开始消费</span><br><span class="line">     *&#x2F;</span><br><span class="line">    CONSUME_FROM_FIRST_OFFSET,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 一个新的订阅组第一次启动从指定时间点开始消费</span><br><span class="line">     * 后续再启动接着上次消费的进度开始消费</span><br><span class="line">     * 时间点设置参见DefaultMQPushConsumer.consumeTimestamp参数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    CONSUME_FROM_TIMESTAMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="4"><b>控制台重置offset</b></font><br>进入控制台点击Topic导航栏，筛选出topic行信息后，点击<span class="p red">REST CONSUMER OFFSET</span>按钮，选择要重置的消费组以及回溯时间:<br><img src="/2020/09/11/RocketMQ%E6%B6%88%E8%B4%B9%E7%AB%AF/%E6%8E%A7%E5%88%B6%E5%8F%B0offset%E9%87%8D%E7%BD%AE.png" class="lazyload" data-srcset="/2020/09/11/RocketMQ%E6%B6%88%E8%B4%B9%E7%AB%AF/%E6%8E%A7%E5%88%B6%E5%8F%B0offset%E9%87%8D%E7%BD%AE.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ(六)消息存储</title>
      <link href="2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/"/>
      <url>2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h2><p>Broker负责存储消息、主题、对应队列等，将这些内容持久化到配置文件的store文件夹中:<br><img src="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/%E6%96%87%E4%BB%B6%E5%88%86%E7%B1%BB.jpg" class="lazyload" data-srcset="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/%E6%96%87%E4%BB%B6%E5%88%86%E7%B1%BB.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>当生产者通过路由信息将消息发送到Broker后，Broker先将消息写到内存中，然后通过线程刷到磁盘。刷盘方式分为同步和异步俩种方式，在配置文件的flushDiskType属性中进行设置:<br><img src="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/%E5%88%B7%E7%9B%98%E6%96%B9%E5%BC%8F.jpg" class="lazyload" data-srcset="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/%E5%88%B7%E7%9B%98%E6%96%B9%E5%BC%8F.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>此文件夹存储了Broker运行需要的各种配置信息，采用json文本形式存储配置文件以及对应的备份文件:</p><table><thead><tr><th>文件名称</th><th>解析存储类</th><th>描述</th></tr></thead><tbody><tr><td>topics.json</td><td>TopicConfigManager</td><td>存储每个topic的读写队列数、权限、是否顺序等信息</td></tr><tr><td>consumerOffset.json</td><td>ConsumerOffsetManager</td><td>记录每个Consumer在每个topic上对于该topic的consumequeue队列的消费进度</td></tr><tr><td>consumerFilter.json</td><td>ConsumerFilterManager</td><td>存储每个消费者Consumer的过滤信息</td></tr><tr><td>subscriptionGroup.json</td><td>SubscriptionGroupManager</td><td>存储每个消费者Consumer的订阅信息</td></tr><tr><td>delayOffset.json</td><td>ScheduleMessageService</td><td>记录对于延迟主题SCHEDULE_TOPIC_XXXX的每个consumequeue队列的消费进度</td></tr></tbody></table><h2 id="commitlog"><a href="#commitlog" class="headerlink" title="commitlog"></a>commitlog</h2><p>此文件夹负责存储Broker节点接收到的消息，存储消息的文件名长度为20位，以起始物理偏移量的值进行命名，如果长度不够20位则在左侧补零，每个文件的大小默认1G，也就是1073741824字节，当文件写满则创建下一个文件。比如Broker接收到第一个消息后创建00000000000000000000代表第一个文件，起始偏移量为0，当文件写满1G后，创建名为00000000001073741824的文件继续存储消息，起始偏移量为1073741824。</p><p class="p red">注:这里的偏移量是指物理偏移量(1个字节代表一个偏移量)，并非按消息数量递增的逻辑偏移量，物理偏移量用于定位某个消息在此文件中的物理位置</p><p>消息在commitlog文件中的存储格式如下:<br><img src="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/commitlog%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/commitlog%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>存储结构中，各部位代表的含义:</p><table><thead><tr><th>名称</th><th>占用磁盘</th><th>描述</th></tr></thead><tbody><tr><td>msgLen</td><td>4字节</td><td>消息长度，具体指整个消息体所占用的字节大小</td></tr><tr><td>magicCode</td><td>4字节</td><td>魔数，固定值daa320a7</td></tr><tr><td>bodyCRC</td><td>4字节</td><td>消息体验证码</td></tr><tr><td>queueId</td><td>4字节</td><td>消息体发送到了哪个MessageQueue</td></tr><tr><td>flag</td><td>4字节</td><td>创建Message对象时由生产者通过构造器设定的flag值</td></tr><tr><td>queueOffset</td><td>8字节</td><td>表示在队列中逻辑的偏移量</td></tr><tr><td>physicalPosition</td><td>8字节</td><td>表示在存储文件中的偏移量</td></tr><tr><td>sysFlag</td><td>4字节</td><td>是生产者相关的信息标识</td></tr><tr><td>msg born timestamp</td><td>8字节</td><td>消息创建时间</td></tr><tr><td>msg host</td><td>8字节</td><td>消息生产者的host</td></tr><tr><td>store timestamp</td><td>8字节</td><td>消息存储时间</td></tr><tr><td>store host</td><td>8字节</td><td>消息存储机器的host</td></tr><tr><td>reconsume times</td><td>4字节</td><td>消息重复消费次数</td></tr><tr><td>prepare transaction offset</td><td>8字节</td><td>消息事务相关偏移量</td></tr><tr><td>body length</td><td>4字节</td><td>消息体的长度</td></tr><tr><td>msg body</td><td>不固定</td><td>消息内容</td></tr><tr><td>topic length</td><td>1</td><td>主题名称长度(1字节=8位，因此topic长度不会超过127)</td></tr><tr><td>topic length</td><td>不固定</td><td>主题名称</td></tr><tr><td>properties lengh</td><td>不固定</td><td>Properties内容长度</td></tr><tr><td>properties</td><td>不固定</td><td>Properties的内容</td></tr></tbody></table><p class="p red">某个Broker节点接收到的所有topic-queue消息，全部写入一个文件中(直到写满为止)，这一点与Kafka有很大不同。Kafka是以topic-partition为单位创建存储消息的文件，存储文件的分类粒度比RocketMQ要细很多，也意味着相同的业务场景，kafka节点创建存储消息的文件数量肯定会比RocketMQ节点要多，且随着节点中topic和queue/partition的激增，数量差距越来越大。</p><p class="p red">当kafka的存储文件越来越多(单机以64个partition为分水岭)，顺序写入特性会被大大破坏从而引起大量的随机I/O，吞吐量会急剧下降，而RocketMQ的这个设计，很好的避免了这个问题。</p><h2 id="consumequeue"><a href="#consumequeue" class="headerlink" title="consumequeue"></a>consumequeue</h2><p>Broker节点接收到的任何topic-queue消息都会写在commitlog文件中，并且没有规则的分布情况，如果消费者想要拉取某个topic-queue消息时，需要整体检索commitlog文件，这种方式的效率难以保障。这就需要对commitlog文件的消息建立索引来加快消息的检索，而这些索引数据就是在consumequeue文件夹进行存储。</p><p>例如现在某个Broker节点中负责订单的发货(DELIVER_PACKAGE)、到货(ARRIVAL_PACKAGE)、签收(SIGN_PACKAGE)的三个消息通知topic，每个topic都有4个队列，目录结构如下:<br><img src="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/consumequeue%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/consumequeue%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>由此图可以看出，consumequeue目录结构的分类粒度与Kafka存储消息文件的粒度类似，只不过consumequeue目录不存储具体的消息内容，只存储路由到该queue中的消息在CommitLog中的物理偏移量(offset)、消息大小(size)、消息所属的tag的hash值(tagCode)三个属性，每条索引占用磁盘空间固定为20字节。</p><p><font size="4"><b>文件写入</b></font><br>当Broker收到某个topic-queue消息时，先将消息写入commitlog文件中并得到物理偏移量，然后进入consumequeue目录对应的文件夹创建文件，文件名长度为20位，以起始物理偏移量的值进行命名，如果长度不够20位则在左侧补零。每个文件默认可以存储30W个消息索引，文件磁盘大小也就是60W字节，比如Broker收到某个topic-queue的第一条消息时，创建文件00000000000000000000，起始物理偏移量为0，将刚才的物理偏移量、消息大小、tag的hash值写入创建的文件中，当写满后30W条消息时创建第二个文件00000000000006000000，起始物理偏移量为60W，继续存储写入的数据。</p><p><font size="4"><b>文件读取</b></font><br>当Broker收到Consumer的消息拉取请求时，根据topic、queueId找到对应文件夹，通过文件夹里面各文件的名称计算出存储的逻辑偏移量范围，然后根据Consumer提供的offset锁定到具体检索哪个文件。将Consumer提供的offset*20后减去文件名的数值，即可得到要查询的消息在consumequeue索引中的物理偏移量位置，往后取20字节的数据就是消息的索引信息，拿到物理偏移量去commitlog即可查询最终的消息。</p><p class="p red">consumequeue文件夹创建的文件命名虽然和commitlog同样都是物理偏移量，不过consumequeue文件存储的数据量固定，且布局有序、有固定规则，因此可以通过文件名去定位具体的物理偏移量，不会存在检索效率的问题。</p><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>Broker除了通过Consumer提供的offset获取消息外，还支持通过MessageID或者MessageKey查询消息。使用ID查询处理起来比较简单，因为MessageID就是根据Broker+offset生成的，因此很容易找到对应的commitlog文件来读取消息。而MessageKey由生产者自己设定，RocketMQ为了保证其查询的效率，使用index文件夹记录对应的索引信息。</p><p>index文件由IndexHeader、HashSlot、Index三部分构成:<br><img src="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/index%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/index%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><font size="4"><b>IndexHeader中存储的都是一些文件基础数据:</b></font></p><table><thead><tr><th>名称</th><th>占用磁盘</th><th>描述</th></tr></thead><tbody><tr><td>beginTimestamp</td><td>8字节</td><td>该索引文件第一个消息的存储(落盘)时间</td></tr><tr><td>endTimestamp</td><td>8字节</td><td>该索引文件最后一个消息的存储(落盘)时间</td></tr><tr><td>beginPhyoffset</td><td>8字节</td><td>该索引文件第一个消息在commitlog的物理偏移量</td></tr><tr><td>endPhyoffset</td><td>8字节</td><td>该索引文件最后一个消息在commitlog的物理偏移量</td></tr><tr><td>hashSlotCount</td><td>4字节</td><td>该索引文件目前的哈希槽个数</td></tr><tr><td>indexCount</td><td>4字节</td><td>该索引文件目前已存储的索引数量</td></tr></tbody></table><p><font size="4"><b>HashSlot负责对索引内容进行分片:</b></font><br>消息在进行index存储时，通过消息key的哈希值%500W定位哈希槽(貌似500W这个值可以修改)，因此可以理解为一个index文件的哈希槽最多500W个，另外IndexHeader与HashSlot的大小都是固定的，再文件中的位置不需要额外标记，可以直接定位获取。</p><p>其中每个哈希槽固定占有4字节，仅仅用来存储当前卡槽最后一个key在index部分的逻辑位置(整个索引文件index区域中第几个写入的)，这么做的目的仍然是节省磁盘空间，如果直接存储物理偏移量需要8个字节，这里四个字节就够了，因为IndexHeader与HashSlot的大小是固定的，每个索引数据在整个index的物理偏移量为:</p><p class="p red">IndexHeader大小(40字节) + hashSlot大小(4字节) * 数量(500w) + 逻辑位置 * 每个index大小(20字节)</p><p><font size="4"><b>Index存储真正的索引信息:</b></font></p><table><thead><tr><th>名称</th><th>占用磁盘</th><th>描述</th></tr></thead><tbody><tr><td>key hash value</td><td>4字节</td><td>消息key的哈希值</td></tr><tr><td>phyOffset</td><td>8字节</td><td>消息在commitlog的物理偏移量(索引的核心数据)</td></tr><tr><td>timeDiff</td><td>4字节</td><td>消息落盘时间与IndexHeader中的beginTimestamp的差值(节省磁盘空间，如果直接存储落盘时间就需要占用8字节)</td></tr><tr><td>prevIndex</td><td>4字节</td><td>哈希槽的第一个索引prevIndex=0，后续的索引prevIndex=前一个索引的物理偏移量</td></tr></tbody></table><p><font size="4"><b>索引文件创建过程:</b></font><br>当Broker接收到消息后，先将消息写入commitlog文件中并得到物理偏移量，然后进入index文件夹查询最新创建的索引文件，如果此索引文件的IndexHeader的indexCount等于2000W则表示已满，获取当前时间戳作为名称创建新的索引文件，如果小于2000W直接进入写文件环节。</p><p>获取消息key的哈希值并%500W计算出卡槽号，如果此卡槽存储的值为0，表示目前下面还没有存储索引，写入索引数据(其中prevIndex=0)，如果卡槽存储的值不为0，通过卡槽值计算出索引数据所在的物理偏移量并取出，然后将新的索引数据写入文件(其中prevIndex=当前卡槽值)，然后刷新卡槽值为当前索引数据的逻辑位置(整个索引文件index区域中第几个写入的)，其实就是类似HashMap的数组+链表。</p><p><font size="4"><b>消息key查询过程:</b></font><br>查询的传入值除了key外，还包含一个时间起始值以及截止值(这玩意在控制台貌似不需要?)，时间范围参数用于定位具体的索引文件，根据消息key的哈希值锁定具体的卡槽。通过卡槽值计算出最后一个索引数据在索引文件中的物理偏移量并取出，紧接着通过prevIndex属性递归遍历，再加上时间范围与timeDiff属性对比筛选，得出符合条件的phyOffset属性集合，去commitlog捞消息。由于key的hash相同，内容不一定相同，所以在捞消息的时候还要对key的内容进行筛选。</p><h2 id="abort文件"><a href="#abort文件" class="headerlink" title="abort文件"></a>abort文件</h2><p>Broker启动时会在store目录创建此文件，在正常退出后会删除此文件。如果Broker在启动时发现store目录中发现abort文件存在，那么说明上次服务退出属于异常退出(宕机或者手动kill进程等)，异常退出会导致部分文件的写入逻辑没有执行完就被打断(比如某条消息只写入一半)，造成脏数据影响后续的解析。</p><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><p>这叼毛文件完全搜不到是干啥的</p><h2 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h2><p>checkpoint文件的作用是记录commitlog、consumequeue、index最后一次刷盘时间，此文件固定长度为4k。但是Broker仅仅使用了前24个字节，这24个字节按照8字节为单位划分为三部分，使用16进制数字表示上述的三个刷盘时间戳。</p><p>使用文本打开此文件，内容如下:<br><img src="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/checkpoint%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9.jpg" class="lazyload" data-srcset="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/checkpoint%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h2 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h2><p>每个Broker节点存储的文件都会随着时间的推移不断增长，CommitLog、ConsumeQueue文件是基于文件内存映射机制，并且在启动的时候会将所有的文件加载，为了避免内存与磁盘的浪费、能够让磁盘能够循环利用、避免因为磁盘不足导致消息无法写入等引入了文件过期删除机制。</p><p>RocketMQ采用定时器扫描方式执行删除策略，并且在删除过程中不会关心消息是否被消费，删除策略在以下任一条件成立的情况才会执行批量删除:</p><ul><li>消息文件过期(默认72小时)，且到达清理时点(默认是凌晨4点)，删除过期文件。</li><li>消息文件过期(默认72小时)，且磁盘空间达到了水位线(默认75%)，删除过期文件。</li><li>磁盘已经达到必须释放的上限(85%水位线)的时候，则开始批量清理文件(无论是否过期)，直到空间充足。</li></ul><p class="p red">注：若磁盘空间达到危险水位线（默认90%），出于保护自身的目的，broker会拒绝写入服务。</p><h2 id="高性能存储"><a href="#高性能存储" class="headerlink" title="高性能存储"></a>高性能存储</h2><p>整个RocketMQ集群服务的本质是进行消息发送与消费，Producer发送消息到Broker端并进行磁盘写入，Consumer发送请求到Broker端并进行磁盘读取，也就是说RocketMQ的工作与磁盘数据的读写息息相关。上述的commitlog、consumequeue、index是在磁盘的存储结构上进行优化，除此之外，RocketMQ设计者们还从磁盘的读写层面进行了性能优化。</p><p><font size="4"><b>磁盘读过程</b></font></p><ul><li>寻道 : 磁头移动定位到指定磁道，这部分时间代价最高</li><li>旋转延迟 : 在磁道位置确定后，中轴带动盘面旋转到合适的扇区开头处</li><li>数据传输 : 表示盘面继续转动，读取数据并传送到内存</li></ul><p><font size="4"><b>顺序与随机读写</b></font><br>对于磁盘的读写分为两种模式，顺序读写和随机读写。随机读写存在一个多次寻址的过程，而顺序读写相当于有一个物理索引，在读取的时候不需要寻找地址，因此顺序读写相对于随机读写，效率很高。</p><p>RocketMQ与Kafka在进行消息持久化时，都采用追加的方式写入磁盘文件(顺序写入)。Consumer在进行消费时，也是对磁盘文件进行顺序读取，每次要读取的数据在磁盘的位置，正好都在上次的后面，因此不需要寻道，移动到扇区开头处后直接进行数据传输，<span class="p red">可以理解为RocketMQ与Kafka的顺序写入保证了顺序读取。</span></p><p><font size="4"><b>PageCache</b></font><br>当操作系统的运行内存有大量剩余时，为了提高IO的性能，会将多余的内存抽取出来作为文件的缓存使用。操作系统将文件按大小切割为多个数据块，并放入PageCache中进行缓存。</p><p>当Broker进行文件写入时，操作系统只是将数据写入PageCache中，并采用异步方式将PageCache写入的数据刷盘到磁盘中，也就是说文件写入磁盘是纯内存操作的，内存IO相对于磁盘IO来说，效率提升很多。这也带来了一定的风险，写入PageCache的数据如果未来得及同步到磁盘就发生宕机，会导致这部分数据丢失，因此RocketMQ在Broker端配置文件中可以自己选择同步或者异步刷盘方式，效率与可靠性由开发者自己权衡，而kafka直接不支持同步刷盘(太奔放了)。</p><p>当Broker进行文件读取时，首先去PageCache中查询要操作的文件内容是否存在，如果存在则直接读取并返回，如果不存在则需要启动磁盘IO，读取完毕后将内容加入PageCache中，除了读取查询需要的数据外，操作系统还会往后预读取若干(至少1个，通常3个)页数据一并放入PageCache中，这么做的目的就是尽量减少磁盘IO的次数，尽量提高PageCache的命中率。如果保证多数情况下对文件都是顺序读取，配合PageCache的预读取，可以保证请求几乎都命中PageCache，大大提升文件读取的执行效率。</p><p class="p red">PageCache机制是牺牲可靠性(宕机引发数据丢失)的前提下，尽量将磁盘IO转化为内存IO从而提高执行效率，这种机制虽然是操作系统层面的优化，但是RocketMQ顺序读写完美契合了PageCache，使其发挥出优越的性能。</p><p class="p red">如果某Broker端负责的topic不多且Consumer消费进度几乎一致，那么PageCache在缓存数据很小的情况下依然能极大提高效率。如果topic数量极多且各Consumer消费进度完全不一致，那么PageCache缓存的数据也会激增，一旦超出PageCache所能承受的极限，会导致后续的磁盘IO无法缓存引发随机读写，性能并不能达到满意的效果。</p><p><font size="4"><b>零拷贝</b></font></p><p>以Linux系统为例，当A服务器需要读取B服务器的磁盘数据时，B服务器默认采用操作系统提供的read()、write()函数进行读取并传输，在此过程中涉及到四个步骤:</p><ul><li>1.用户态切换到内核态，操作系统调用read()函数，将磁盘数据copy到内核缓冲区，此过程由MDA完成。</li><li>2.将内核缓冲区数据copy到用户缓冲区，内存之间的数据拷贝需CPU协助完成，copy完毕后内核态切回用户态。</li><li>3.用户空间的数据如果需要网络传送到其他服务器，需要调用write()函数，此时用户态切换到内核态，然后将用户缓冲区数据copy到内核socket发送缓冲区，涉及到内存之间的数据copy，仍然需CPU协助完成。</li><li>4.最后socket缓冲区数据需要复制到网卡缓冲区中，此操作由MDA完成，复制完毕后由网卡发送到客户端，然后CPU状态切回用户态。</li></ul><p>步骤流程图:<br><img src="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/%E5%B8%B8%E8%A7%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96.png" class="lazyload" data-srcset="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/%E5%B8%B8%E8%A7%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>整个过程涉及4次数据的copy、2次CPU调度、4次内核用户态的切换，频繁的数据复制以及内核/用户态的切换对系统开销非常大，因此便产生了零拷贝技术。零拷贝技术的思想是减少CPU调度和内核用户态切换的次数，实现方式分为mmap、sendfile等。</p><p>mmap通过虚拟内存映射，让多个虚拟地址指向同一个物理内存地址，用户空间通过映射关系共享内核空间的数据，内核缓冲区数据copy到用户缓冲区的步骤可以省略，这样从PageCache到网卡的传输就省掉了1次CPU调度、2次内核用户态切换:<br><img src="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/%E9%9B%B6%E6%8B%B7%E8%B4%9D-mmap.png" class="lazyload" data-srcset="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/%E9%9B%B6%E6%8B%B7%E8%B4%9D-mmap.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>sendfile直接没有用户态进行参与，也不需要将数据拷贝到用户缓冲区，相比较mmap又少了一次CPU调度:<br><img src="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/%E9%9B%B6%E6%8B%B7%E8%B4%9D-sendfile.png" class="lazyload" data-srcset="/2020/09/09/RocketMQ%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/%E9%9B%B6%E6%8B%B7%E8%B4%9D-sendfile.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p class="p red">mmap适合操作小块数据量，sendfile适合操作大块数据量，RocketMQ选择mmap方式，而Kafka选择sendfile方式，至于区别暂时没找到...</p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ(五)生产端</title>
      <link href="2020/09/07/RocketMQ%E7%94%9F%E4%BA%A7%E7%AB%AF/"/>
      <url>2020/09/07/RocketMQ%E7%94%9F%E4%BA%A7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="springboot集成"><a href="#springboot集成" class="headerlink" title="springboot集成"></a>springboot集成</h2><p><font size="4"><b>RocketMQ依赖</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.rocketmq&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;rocketmq-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;4.7.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><font size="4"><b>application.properties</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 服务端口</span><br><span class="line">server.port&#x3D;8082</span><br><span class="line"></span><br><span class="line"># 生产者分组</span><br><span class="line">rocketmq.producer.groupName&#x3D;GROUP_A</span><br><span class="line"></span><br><span class="line"># MQ注册中心地地址</span><br><span class="line">rocketmq.producer.namesrvAddr&#x3D;localhost:9876</span><br><span class="line"></span><br><span class="line"># 消息最大长度 默认 1024 * 4 (4M)</span><br><span class="line">rocketmq.producer.maxMessageSize &#x3D; 4096</span><br><span class="line"></span><br><span class="line"># 发送消息超时时间，默认 3000</span><br><span class="line">rocketmq.producer.sendMsgTimeOut&#x3D;3000</span><br><span class="line"></span><br><span class="line"># 发送消息失败重试次数，默认2</span><br><span class="line">rocketmq.producer.retryTimesWhenSendFailed&#x3D;2</span><br></pre></td></tr></table></figure><p><font size="4"><b>将生产者注册到IOC</b></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQProducerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;rocketmq.producer.groupName&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String groupName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;rocketmq.producer.namesrvAddr&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String namesrvAddr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;rocketmq.producer.maxMessageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxMessageSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;rocketmq.producer.sendMsgTimeOut&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer sendMsgTimeOut;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;rocketmq.producer.retryTimesWhenSendFailed&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer retryTimesWhenSendFailed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RocketMQ生产者对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultMQProducer <span class="title">defaultProducer</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(groupName);</span><br><span class="line">        producer.setNamesrvAddr(namesrvAddr);</span><br><span class="line">        producer.setVipChannelEnabled(<span class="keyword">false</span>);</span><br><span class="line">        producer.setMaxMessageSize(maxMessageSize);</span><br><span class="line">        producer.setSendMsgTimeout(sendMsgTimeOut);</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(retryTimesWhenSendFailed);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> producer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h2><p>DefaultMQProducer类提供了fetchPublishMessageQueues方法，可以查看当前Producer从NameServer同步过来的topic路由信息:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MessageQueue&gt; messageQueueList = producer.fetchPublishMessageQueues(<span class="string">&quot;TEST_TOPIC&quot;</span>);</span><br></pre></td></tr></table></figure><p>Producer向某个topic发送消息时，如果从NameServer同步的路由信息中发现，此topic在多个Broker中都存在队列，那么就需要依靠某种策略从中选择一个进行发送，这个策略由MQFaultStrategy类的selectOneMessageQueue方法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(String lastBrokerName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果上次发送的brokerName为空，直接轮询</span></span><br><span class="line">    <span class="keyword">if</span> (lastBrokerName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.selectOneMessageQueue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对messageQueueList进行轮询选取</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.messageQueueList.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = Math.abs(index++) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果此次轮询到的MessageQueue对应的Broker节点没任何问题，直接返回</span></span><br><span class="line">            MessageQueue mq = (MessageQueue)<span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line">            <span class="keyword">if</span> (!mq.getBrokerName().equals(lastBrokerName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接轮询</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Producer采用轮询的方式发送消息，每次发送消息时调用无参的selectOneMessageQueue()方法，这个方法就是一个单纯的轮询策略。只是消息并不能保证每次都会发送成功，如果发送失败并且设置了重试次数，那么Producer会调用有参的selectOneMessageQueue()方法，将发送失败的Broker名称作为参数传进去，并且此次轮询会忽略掉这个Broker名称。</p><p>当消息经过重试发送成功后，有问题的Broker并没有被记录下来，这就导致下次发送消息时并不会知晓这个Broker有问题，仍然在轮询策略的选择范围内，仍然有发送失败的情况出现。想要避免此问题，就需要开启延迟故障。</p><h2 id="延迟故障"><a href="#延迟故障" class="headerlink" title="延迟故障"></a>延迟故障</h2><p>延迟故障功能通过创建Producer时调用setSendLatencyFaultEnable(true)开启(默认false)，开启后对于高延迟、有故障的Broker都会记录下来，并且根据故障的严重程度，给予一段不可用的时间。具体的规则维护在MQFaultStrategy类的俩个数组中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] latencyMax = <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">50L</span>, <span class="number">100L</span>, <span class="number">550L</span>, <span class="number">1000L</span>, <span class="number">2000L</span>, <span class="number">3000L</span>, <span class="number">15000L</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] notAvailableDuration = <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">0L</span>, <span class="number">0L</span>, <span class="number">30000L</span>, <span class="number">60000L</span>, <span class="number">120000L</span>, <span class="number">180000L</span>, <span class="number">600000L</span>&#125;;</span><br></pre></td></tr></table></figure><p>latencyMax数组元素表示各种延迟的时间，notAvailableDuration数组元素表示各种不可用时间，这俩个数组的同一个下坐标对应的值就是延迟时间对应的惩罚时间。由此可以看到100ms以内的延迟都是正常的，其余的规定时间内会排除掉，从正常的Broker中轮询获取。</p><p>如果在极端的情况，所有的Broker延迟都高于100，都被视为故不可用的故障节点，这段时间的消息发送如何处理呢。RocketMQ提供了pickOneAtLeast()方法，从故障Broker列表中选择最优的一个，也就是俗话矮子里面拔将军:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">pickOneAtLeast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Enumeration&lt;FaultItem&gt; elements = <span class="keyword">this</span>.faultItemTable.elements();</span><br><span class="line">    List&lt;FaultItem&gt; tmpList = <span class="keyword">new</span> LinkedList&lt;FaultItem&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先把故障的broker列表复制一份，后面好做打乱</span></span><br><span class="line">    <span class="keyword">while</span> (elements.hasMoreElements()) &#123; </span><br><span class="line">        <span class="keyword">final</span> FaultItem faultItem = elements.nextElement();</span><br><span class="line">        tmpList.add(faultItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打乱该列表</span></span><br><span class="line">    <span class="keyword">if</span> (!tmpList.isEmpty()) &#123;</span><br><span class="line">        Collections.shuffle(tmpList); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Collections.sort(tmpList); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从前50%里面递增选取一个</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> half = tmpList.size() / <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">if</span> (half &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> tmpList.get(<span class="number">0</span>).getName();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="keyword">this</span>.whichItemWorst.getAndIncrement() % half;</span><br><span class="line">            <span class="keyword">return</span> tmpList.get(i).getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从故障Broker列表中按照规则排序，然后从前半部分中轮询获取一个作为发送的目的地，因此重点在于排序规则，这就需要查看FaultItem类重写的排序方法了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">final</span> FaultItem other)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可用的笔不可用的优先级高</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isAvailable() != other.isAvailable()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isAvailable())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (other.isAvailable())</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟低的比延迟高的优先级高</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.currentLatency &lt; other.currentLatency)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.currentLatency &gt; other.currentLatency) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 被惩罚时间早的比晚的优先级高</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.startTimestamp &lt; other.startTimestamp)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.startTimestamp &gt; other.startTimestamp) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里并没有将选择结果固定为排序规则中最好的那个，主要是为了避免topic的消息聚集在一个Broker的队列中造成负担过重，负载均衡到所有故障Broker又失去了故障延迟的初衷，因此选择折中的方式，将前50%的节点采用轮询方式进行负载均衡。</p><h2 id="发送方式"><a href="#发送方式" class="headerlink" title="发送方式"></a>发送方式</h2><p><font size="4"><b>同步发送</b></font></p><ul><li>同步发送消息时，线程进入阻塞状态，直到发送完毕返回SendResult类</li><li>如果发送失败，会在默认的超时时间进行重试，最多重试俩次</li><li>返回SendResult类，并不代表发送成功，需要根据sendStatus来判断是否成功</li><li>可以根据返回的结果作相应处理，因此理论上不会出现消息丢失(可靠)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者对象</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DefaultMQProducer producer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建消息对象</span></span><br><span class="line">Message sendMsg = <span class="keyword">new</span> Message(<span class="string">&quot;ORDER_REMINDER&quot;</span>, <span class="string">&quot;LOGISTICS&quot;</span>, message.getBytes());</span><br><span class="line"><span class="comment">// 同步发送</span></span><br><span class="line">SendResult sendResult = producer.send(sendMsg);</span><br></pre></td></tr></table></figure><p><font size="4"><b>异步发送</b></font></p><ul><li>异步调用不存在返回值，投递的结果信息SendResult类在成功回调onSuccess()方法中</li><li>异步发送没有retry机制，投递失败回调onException()方法</li><li>异步调用主要请求耗时过长，或者对响应时间过于敏感的请求，比如大数据量的excel导入，选择用户群体后批量推送消息等</li><li>可以根据onSuccess()方法返回的结果作相应处理，因此理论上不会出现消息丢失(可靠)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者对象</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DefaultMQProducer producer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建消息对象</span></span><br><span class="line">Message sendMsg = <span class="keyword">new</span> Message(<span class="string">&quot;TEST_TOPIC&quot;</span>, <span class="string">&quot;tag&quot;</span>, message.getBytes());</span><br><span class="line"><span class="comment">// 异步发送</span></span><br><span class="line">producer.send(sendMsg, <span class="keyword">new</span> SendCallback()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发送成功回调逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发送失败回调逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><font size="4"><b>单向发送</b></font></p><ul><li>单向发送仅仅处理消息的发送，由于发送是否成功无法知晓，因此有几率造成数据丢失(不可靠)</li><li>优点在于发送消息的耗时非常短，一般在微秒级别</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者对象</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DefaultMQProducer producer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建消息对象</span></span><br><span class="line">Message sendMsg = <span class="keyword">new</span> Message(<span class="string">&quot;TEST_TOPIC&quot;</span>, <span class="string">&quot;tag&quot;</span>, message.getBytes());</span><br><span class="line"><span class="comment">// 单向发送</span></span><br><span class="line">producer.sendOneway(sendMsg);</span><br></pre></td></tr></table></figure><h2 id="发送特点"><a href="#发送特点" class="headerlink" title="发送特点"></a>发送特点</h2><p><font size="4"><b>顺序发送</b></font><br>Producer将消息发送到Broker节点后，Broker会找到对应的队列文件，并采用追加的方式将消息内容写入文件中，可以理解为RocketMQ可以保证队列级别的消息顺序。因此我们只需要将同一类数据发送到同一个队列中，就可以保证消息的顺序发送，Consumer在进行消费时也就毫无悬念的顺序消费了。</p><p>最常见的顺序消费场景就是使用canal或maxwell来订阅Mysql数据库的Binlog，同一条数据会产生多条操作日志，如果不做任何措施可能会导致Insert日志和Update日志被投递到不同的Broker中，这就有很大几率出现Update日志抢先在Insert日志处理前被消费处理，造成数据不一致的情况。对此最常见的解决方案是提取消息的业务唯一标示(比如id等)，和队列长度取余运算定位需要发送的Broker的节点进行发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者对象</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DefaultMQProducer producer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建消息对象</span></span><br><span class="line">Message sendMsg = <span class="keyword">new</span> Message(<span class="string">&quot;TEST_TOPIC&quot;</span>, <span class="string">&quot;tag&quot;</span>, message.getBytes());</span><br><span class="line"><span class="comment">// 假设此binlog消息的主键id为666</span></span><br><span class="line">Long id = <span class="number">666L</span>;</span><br><span class="line"><span class="comment">// 顺序发送</span></span><br><span class="line">SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// arg的值就是send方法第三个参数(id)的值</span></span><br><span class="line">        Long id = (Long) arg;</span><br><span class="line">        <span class="comment">// mqs为此Producer从注册中心拿到的，需要发送</span></span><br><span class="line">        <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">        <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">    &#125;, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="4"><b>延迟发送</b></font><br>延迟消息的使用场景很多，例如电商系统的订单业务场景，用户下单后发送一个30分钟的延迟消息，30分钟后Consumer会收到此消息，然后检查订单是否已付款，如果未付款执行自动取消逻辑处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者对象</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DefaultMQProducer producer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建消息对象</span></span><br><span class="line">Message sendMsg = <span class="keyword">new</span> Message(<span class="string">&quot;TEST_TOPIC&quot;</span>, <span class="string">&quot;tag&quot;</span>, message.getBytes());</span><br><span class="line"><span class="comment">// 设置延迟级别</span></span><br><span class="line">sendMsg.setDelayTimeLevel(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 延迟发送</span></span><br><span class="line">SendResult sendResult = producer.send(sendMsg);</span><br></pre></td></tr></table></figure><p>RocketMQ商业版本支持任意精度的延迟消息，而开源版本仅仅支持18个特定时间的延迟功能，通过setDelayTimeLevel()方法进行控制，具体的延迟等级与延迟时间的对应关系如下:</p><table><thead><tr><th>延迟等级</th><th>延迟时间</th></tr></thead><tbody><tr><td>1</td><td>1秒</td></tr><tr><td>2</td><td>5秒</td></tr><tr><td>3</td><td>10秒</td></tr><tr><td>4</td><td>30秒</td></tr><tr><td>5</td><td>1分钟</td></tr><tr><td>6</td><td>2分钟</td></tr><tr><td>7</td><td>3分钟</td></tr><tr><td>8</td><td>4分钟</td></tr><tr><td>9</td><td>5分钟</td></tr><tr><td>10</td><td>6分钟</td></tr><tr><td>11</td><td>7分钟</td></tr><tr><td>12</td><td>8分钟</td></tr><tr><td>13</td><td>9分钟</td></tr><tr><td>14</td><td>10分钟</td></tr><tr><td>15</td><td>20分钟</td></tr><tr><td>16</td><td>30分钟</td></tr><tr><td>17</td><td>1小时</td></tr><tr><td>18</td><td>2小时</td></tr></tbody></table><p>Producer发送延迟消息时，消息首先会被投递到名为SCHEDULE_TOPIC_XXXX的topic中，这个topic是集群自动创建的，可以在控制台的Topic页面中勾选SYSTEM进行REFRESH查询，点开此topic的路由信息可以看到每个Broker节点都负责此topic的18个读写队列。</p><p>Producer会根据延迟等级值来决定将消息发送到SCHEDULE_TOPIC_XXXX的哪个队列号中，紧接着将真实的topic和queueId设置到Message的propertiesString属性中，然后选择一个Broker进行发送。每个Broker的SCHEDULE_TOPIC_XXXX的每个queue，都会对应一个定时器去刷新，是否有到达时间需要被发送的消息，若有就从propertiesString取出真实的topic和queueId发送出去。</p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ(四)主题创建</title>
      <link href="2020/09/05/RocketMQ%E4%B8%BB%E9%A2%98%E5%88%9B%E5%BB%BA/"/>
      <url>2020/09/05/RocketMQ%E4%B8%BB%E9%A2%98%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="自动创建"><a href="#自动创建" class="headerlink" title="自动创建"></a>自动创建</h2><p>topic在默认情况下支持自动创建，开关由配置文件的autoCreateTopicEnable(默认true)属性决定，在项目启动后存储在BrokerConfig类中。如果某个Broker的自动创建设置为true，则Broker在启动后会在topicManager中创建名为TBW102的topic并向所有NameServer进行注册。</p><p>当Producer向某个topic投递消息时，首先会访问NameServer获取此topic的路由列表，这里假设此topic之前并没有被创建，那么得到的将是一个空列表，Producer会再次访问NameServer获取名为TBW102的topic的路由列表，如果整个集群中没有任何Broker支持自动创建，那么这个路由列表仍然是空的，此时会抛出No route info of this topic异常，如果集群中存在支持自动创建的Broker，那么就返回这些Broker的路由信息。</p><p>Producer拿到TBW102的路由列表后，会从中选择(默认轮询)一个Broker进行投递，Broker接收到此消息后会调用msgCheck方法对topic进行校验，先去topicConfigTable中查询此topic是否存在，在目前讨论的场景下是肯定不存在的，那么会以这个不存在的tpoic名称创建一个TopicConfig。这个类包含了topic的具体信息包括队列数、读写权限、同步/异步复制等，基本上沿用TBW102的属性，创建完毕后存入topicConfigTable中，然后将topicConfigTable中的所有数据同步到NameServer中。</p><p>topic自动创建流程图:<br><img src="/2020/09/05/RocketMQ%E4%B8%BB%E9%A2%98%E5%88%9B%E5%BB%BA/topic%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA.png" class="lazyload" data-srcset="/2020/09/05/RocketMQ%E4%B8%BB%E9%A2%98%E5%88%9B%E5%BB%BA/topic%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>流程图可以看出，自动创建的topic仅仅在消息投递到的Broker节点中生成queue，一旦刷回注册中心，此topic的负载均衡能力就被固定(排除手动修改的情况)。如果某一时刻不存在的topic被多个Producer同时投递，且集群中支持自动创建的Broker节点数量还算可观，考虑到从投递消息开始直到刷回注册中心这段时间的并发情况，可能会有多个Broker都被分配此topic的queue，此topic仍然有很可观的并行执行能力。</p><p>这里换一种假设，不存在的topic第一次被Producer投递时，没有其他Producer同时进行，导致此topic仅仅分配在某一个Broker中。这就相当危险了，并行能力太差，如果消息量上来很容易造成积压。说这么多就是想表达自动创建的topic的配置信息，因为场景的不确定性很难达到理想值，因此在生产环境中最好关闭自动创建，所有topic都由开发人员根据业务场景主观判断并创建。</p><h2 id="手动创建"><a href="#手动创建" class="headerlink" title="手动创建"></a>手动创建</h2><p>topic的手动创建可以通过linux命令来实现，也可以在console页面进行操作，命令操作相对于页面来说较麻烦一些，并且生产环境除非运维基本上不会有访问服务器的权限，所以这里只写控制台如何创建。</p><p>topic在控制台的创建界面:<br><img src="/2020/09/05/RocketMQ%E4%B8%BB%E9%A2%98%E5%88%9B%E5%BB%BA/topic%E5%88%9B%E5%BB%BA%E7%95%8C%E9%9D%A2.jpg" class="lazyload" data-srcset="/2020/09/05/RocketMQ%E4%B8%BB%E9%A2%98%E5%88%9B%E5%BB%BA/topic%E5%88%9B%E5%BB%BA%E7%95%8C%E9%9D%A2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><br><font size="4"><b>clusterName与BROKER_NAME</b></font>clusterName与BROKER_NAME选项必须填写一个，用于指定topic在哪些Broker节点上创建。如果仅填写clusterName选项(支持多选)，则选中的集群所属Broker节点都会创建此topic信息，这种方式也叫集群创建。如果仅填写BROKER_NAME选项(支持多选)，则只在选中的Broker节点中创建，这种方式也叫Broker创建。如果俩个有存在选项值，则取并集。<p><font size="4"><b>writeQueueNums(写队列数)</b></font><br>此参数决定了在每个选中的Broker节点中创建的队列数量，比如写队列数的值为4，在topic被创建后，涉及到的每个Broker对应的consumequeue文件夹下都会创建0、1、2、3四个文件夹(懒创建方式，只有消息投递到此文件夹才会被创建)，每个Producer启动后，都会从NameServer中获取到所有Broker的0、1、2、3号队列的路由信息，进行轮询投递消息。</p><p><font size="4"><b>readQueueNums(读队列数)</b></font><br>此参数决定某个Broker负责的某个topic，同一个组内最多可连接的消费者数，在集群正常运行期间此参数似乎没有存在的意义。假设某个Broker上的写队列数是4，那么涉及到的每个Broker节点中都会创建0、1、2、3四个队列。如果设置的读队列数小于写队列数(比如3)，那么同一组内的Consumer只会从NameServer拿到1、2、3三个队列的路由信息，队列号3永远无法被消费。如果设置的读队列数大于写队列数(比如5)，由于一个队列在同一时刻只会被一个消费者连接(不考虑消费组不同和广播消费模式的情况)，即使启动了5个消费者，仍然只有4个消费者可以正常工作，多出来的那个消费者不会被分配任何路由信息，即使启动也没有意义。</p><h2 id="扩容与缩容"><a href="#扩容与缩容" class="headerlink" title="扩容与缩容"></a>扩容与缩容</h2><p>按照上述的理论，writeQueueNums小于readQueueNums情况下最多造成资源浪费，大于readQueueNums情况下则会导致个别队列无法被Consumer连接消费，造成严重的消息堆积问题，writeQueueNums与readQueueNums的值只有保持一致才是合理的，为什么不将俩个参数选项合并为一个呢?</p><p>其实这么设计的目的是方便队列的缩容与扩容，思考一个问题，假设某个topic在每个Broker上创建了128个队列，如果在用户无感知的情况下缩小到64个，或者扩容到256个？</p><p><font size="4"><b>水平扩容</b></font><br>关于扩容，可以先将读队列数修改为256，修改后触发再均衡，将队列重新分配给所有Consumer，并且此时队列号128-155虽然分配了Consumer，但是不会有任何消息进入，因为写队列数仍然是128，Producer投递消息只会路由队列号0-127。然后修改写队列数为256，Producer从NameServer获取到最新的关于此topic的路由信息变为0-255，后续投递消息就会覆盖到扩容的队列，供Consumer进行消费。</p><p><font size="4"><b>水平缩容</b></font><br>关于缩容，可以先将写队列数修改为64，修改后会触发再均衡，将队列重新分配给所有Consumer，并且此时队列号64-127不会被路由到任何Producer，也就是说这些队列不会接收到新消息。由于读队列还是128，仍然可以继续消费队列号64-127的消息。直到队列号64-127全部消费完毕后(通过控制台查看)，修改读队列的值与写队列保持一致，Producer从NameServer获取到最新的关于此topic的路由信息变为0-63，后续不会对64-127号队列投递消息。</p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ(三)注册中心</title>
      <link href="2020/09/04/RocketMQ%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
      <url>2020/09/04/RocketMQ%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h2><p>NameServer作为一个十分重要的核心组件，在整个RockteMQ集群运作过程中发挥着重要作用，NameServer服务一旦宕机，整个集群就无法正常运转，因此一定要集群部署，这样才能保证高可用性。NameServer在CAP理论中强调AP，仅保证最终一致性，集群各节点彼此之间互不通信，也就是某一刻NameServer节点之间的数据并不完全相同，但这对消息发送不会造成任何影响。</p><h2 id="路由信息"><a href="#路由信息" class="headerlink" title="路由信息"></a>路由信息</h2><p>在RocketMQ源码中，namesrv模块的org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager类负责存储Broker集群各节点注册的路由信息:</p><p><img src="/2020/09/04/RocketMQ%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF.png" class="lazyload" data-srcset="/2020/09/04/RocketMQ%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><font size="4"><b>HashMap&lt;String, List<QueueData>&gt; topicQueueTable</QueueData></b></font><br>此变量以topic为单位，记录对应的所有队列信息，因为一个topic的数据可以分散到多个Broker中，所以topic与QueueData集合是一对多的关系，QueueData类数据结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class QueueData implements Comparable&lt;QueueData&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 队列所属的Broker名称 </span><br><span class="line">    private String brokerName;</span><br><span class="line">    &#x2F;&#x2F; 读队列数量 </span><br><span class="line">    private int readQueueNums;</span><br><span class="line">    &#x2F;&#x2F; 写队列数量 </span><br><span class="line">    private int writeQueueNums;</span><br><span class="line">    &#x2F;&#x2F; Topic的读写权限(2是写 4是读 6是读写) </span><br><span class="line">    private int perm;</span><br><span class="line">    &#x2F;&#x2F; 同步复制还是异步复制标记</span><br><span class="line">    private int topicSynFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="4"><b>HashMap&lt;String, BrokerData&gt; brokerAddrTable</b></font><br>此变量以Broker名称为单位，记录对应的所有主从节点信息，Broker名称与主从节点也是一对多的关系，不过主从节点集合被设计到BrokerData类中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class BrokerData implements Comparable&lt;BrokerData&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 所属集群名称</span><br><span class="line">    private String cluster;</span><br><span class="line">    &#x2F;&#x2F; broker名称</span><br><span class="line">    private String brokerName;</span><br><span class="line">    &#x2F;&#x2F; key为节点id，value为节点地址端口</span><br><span class="line">    private HashMap&lt;Long, String&gt; brokerAddrs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="4"><b>HashMap&lt;String, Set<String>&gt; clusterAddrTable</String></b></font><br>此变量以Broker集群名称为单位，记录每个集群对应的Broker名称集合。</p><p><font size="4"><b>brokerLiveTable</b></font><br>此变量以Broker地址端口为单位，记录每个Broker的实时信息，与BrokerLiveInfo类是一对一的关系:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class BrokerLiveInfo &#123;</span><br><span class="line">    &#x2F;&#x2F; 上次心跳时间戳</span><br><span class="line">    private long lastUpdateTimestamp;</span><br><span class="line">    &#x2F;&#x2F; 数据版本</span><br><span class="line">    private DataVersion dataVersion;</span><br><span class="line">    &#x2F;&#x2F; 长连接通道</span><br><span class="line">    private Channel channel;</span><br><span class="line">    &#x2F;&#x2F; Ha地址</span><br><span class="line">    private String haServerAddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="4"><b>HashMap&lt;String, List<String>&gt; filterServerTable</String></b></font><br>此变量以Broker地址端口为单位，记录每个Broker的消费者在进行消费时的过滤逻辑，后续会详细讲。</p><p class="p red">由clusterAddrTable的结构可以判断，一个注册中心集群可以包含多个Broker集群，同一个Broker名称可以出现在多个不同的Broker集群中。</p><p class="p red">不过我发现了一个奇怪的问题，我有一个名称为lvt-cluster的集群，内部有个broker-a的Broker，然后在test-cluster集群中也用broker-a这个名称启动了一个Broker，控制台能看到这俩个Broker，当我使用kill杀死test-cluster集群中的broker-a时，在控制台仍然存在，然后我又kill掉lvt-cluster集群中的broker-a，俩个Broker在控制台都消失了。再次启动lvt-cluster集群中的broker-a，又出现了2个Broker，直到我重启注册中心集群，才回归正常。</p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>Broker在启动的时候，会向NameServer注册自己的服务信息，由于NameServer支持集群部署，并且集群中各节点之间没有任何数据交互。因此每个Broker节点启动时，会获取NameSever的地址列表(乱序)，采用遍历列表的方式向每一个NameServer节点注册自己的信息。</p><p>启动并注册完毕后，Broker会启动一个定时任务，每隔30s定时向NameServer进行心跳更新。无论是启动时注册，还是心跳注册，NameServer接收到注册信息都不会持久化到本地，而是保存在上述的各个map中。</p><p>源码中Broker是通过NamesrvStartup类的main方法启动，main方法先是创建了一个BrokerController，然后调用其start()方法，在该方法中有如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (!messageStoreConfig.isEnableDLegerCommitLog()) &#123;</span><br><span class="line">    startProcessorByHa(messageStoreConfig.getBrokerRole());</span><br><span class="line">    handleSlaveSynchronize(messageStoreConfig.getBrokerRole());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 重点在这里</span><br><span class="line">    this.registerBrokerAll(true, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 开启定时任务 </span><br><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; Broker会每隔30s向NameSrv注册并更新自身topic信息,完成心跳功能</span><br><span class="line">                BrokerController.this.registerBrokerAll(true, false, brokerConfig.isForceRegister());</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                log.error(&quot;registerBrokerAll Exception&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 定时器延迟10秒后开始运行，间隔时间用函数绕了一圈，其实就是1000*30，单位毫秒</span><br><span class="line">    &#125;, 1000 * 10, Math.max(10000, Math.min(brokerConfig.getRegisterNameServerPeriod(), 60000)), TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>Broker的服务注册逻辑全部包含在BrokerController类的registerBrokerAll方法中，此方法并没有真正去处理注册的事情，而是委托doRegisterBrokerAll方法来处理，doRegisterBrokerAll也没有亲自去进行注册，而是委托内部的BrokerOuterAPI类的registerBrokerAll方法来处理:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;RegisterBrokerResult&gt; registerBrokerAll(</span><br><span class="line">    final String clusterName,</span><br><span class="line">    final String brokerAddr,</span><br><span class="line">    final String brokerName,</span><br><span class="line">    final long brokerId,</span><br><span class="line">    final String haServerAddr,</span><br><span class="line">    final TopicConfigSerializeWrapper topicConfigWrapper,</span><br><span class="line">    final List&lt;String&gt; filterServerList,</span><br><span class="line">    final boolean oneway,</span><br><span class="line">    final int timeoutMills,</span><br><span class="line">    final boolean compressed) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 使用内部类remotingClient获取NameServer集群中所有节点的IP地址</span><br><span class="line">    final List&lt;RegisterBrokerResult&gt; registerBrokerResultList &#x3D; Lists.newArrayList();</span><br><span class="line">    List&lt;String&gt; nameServerAddressList &#x3D; this.remotingClient.getNameServerAddressList();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果获取的集合不为空</span><br><span class="line">    if (nameServerAddressList !&#x3D; null &amp;&amp; nameServerAddressList.size() &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将Broker自身的各种信息写入requestHeader中</span><br><span class="line">        final RegisterBrokerRequestHeader requestHeader &#x3D; new RegisterBrokerRequestHeader();</span><br><span class="line">        requestHeader.setBrokerAddr(brokerAddr);</span><br><span class="line">        requestHeader.setBrokerId(brokerId);</span><br><span class="line">        requestHeader.setBrokerName(brokerName);</span><br><span class="line">        requestHeader.setClusterName(clusterName);</span><br><span class="line">        requestHeader.setHaServerAddr(haServerAddr);</span><br><span class="line">        requestHeader.setCompressed(compressed);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 将Broker的topic配置信息、过滤信息写入requestBody中</span><br><span class="line">        RegisterBrokerBody requestBody &#x3D; new RegisterBrokerBody();</span><br><span class="line">        requestBody.setTopicConfigSerializeWrapper(topicConfigWrapper);</span><br><span class="line">        requestBody.setFilterServerList(filterServerList);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 转码</span><br><span class="line">        final byte[] body &#x3D; requestBody.encode(compressed);</span><br><span class="line">        final int bodyCrc32 &#x3D; UtilAll.crc32(body);</span><br><span class="line">        requestHeader.setBodyCrc32(bodyCrc32);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 使用CountDownLatch机制 并行注册</span><br><span class="line">        final CountDownLatch countDownLatch &#x3D; new CountDownLatch(nameServerAddressList.size());</span><br><span class="line">        for (final String namesrvAddr : nameServerAddressList) &#123;</span><br><span class="line">            brokerOuterExecutor.execute(new Runnable() &#123;</span><br><span class="line">                &#x2F;&#x2F; 省略...</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 进入超时等待</span><br><span class="line">        try &#123;</span><br><span class="line">            countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return registerBrokerResultList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Broker将需要注册的信息整理好发送后，我们再来看看NameServer是如何接收的，这部分逻辑在RouteInfoManager类的registerBroker方法中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">public RegisterBrokerResult registerBroker(</span><br><span class="line">    final String clusterName,</span><br><span class="line">    final String brokerAddr,</span><br><span class="line">    final String brokerName,</span><br><span class="line">    final long brokerId,</span><br><span class="line">    final String haServerAddr,</span><br><span class="line">    final TopicConfigSerializeWrapper topicConfigWrapper,</span><br><span class="line">    final List&lt;String&gt; filterServerList,</span><br><span class="line">    final Channel channel) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建返回值</span><br><span class="line">    RegisterBrokerResult result &#x3D; new RegisterBrokerResult();</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 加锁</span><br><span class="line">            this.lock.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 获取Broker所属集群名称</span><br><span class="line">            Set&lt;String&gt; brokerNames &#x3D; this.clusterAddrTable.get(clusterName);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 初始化或保存Broker的集群名称</span><br><span class="line">            if (null &#x3D;&#x3D; brokerNames) &#123;</span><br><span class="line">                brokerNames &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">                this.clusterAddrTable.put(clusterName, brokerNames);</span><br><span class="line">            &#125;</span><br><span class="line">            brokerNames.add(brokerName);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 默认此Broker名称不是第一次注册</span><br><span class="line">            boolean registerFirst &#x3D; false;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 获取Broker名称对应的所有节点(主从)信息</span><br><span class="line">            BrokerData brokerData &#x3D; this.brokerAddrTable.get(brokerName);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果broker名称是第一次注册，初始化并标记</span><br><span class="line">            if (null &#x3D;&#x3D; brokerData) &#123;</span><br><span class="line">                registerFirst &#x3D; true;</span><br><span class="line">                brokerData &#x3D; new BrokerData(clusterName, brokerName, new HashMap&lt;Long, String&gt;());</span><br><span class="line">                this.brokerAddrTable.put(brokerName, brokerData);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 获取当前broker的所有主从节点Map&lt;brokerId, IP:PORT&gt;</span><br><span class="line">            Map&lt;Long, String&gt; brokerAddrsMap &#x3D; brokerData.getBrokerAddrs();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 遍历</span><br><span class="line">            Iterator&lt;Entry&lt;Long, String&gt;&gt; it &#x3D; brokerAddrsMap.entrySet().iterator();</span><br><span class="line">            while (it.hasNext()) &#123;</span><br><span class="line">                Entry&lt;Long, String&gt; item &#x3D; it.next();</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 如果要注册的broker的地址已经存在，但是id不同，这属于脏数据，需要删除掉</span><br><span class="line">                &#x2F;&#x2F; 主要考虑到服务更换brokerId后立刻重启的情况</span><br><span class="line">                if (null !&#x3D; brokerAddr &amp;&amp; brokerAddr.equals(item.getValue()) &amp;&amp; brokerId !&#x3D; item.getKey()) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 将当前Broker的IP地址注册到map中，如果put没有冲突也视为第一次注册</span><br><span class="line">            String oldAddr &#x3D; brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</span><br><span class="line">            registerFirst &#x3D; registerFirst || (null &#x3D;&#x3D; oldAddr);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果Broker是主节点并且对应名称是第一次注册，保存topic的配置信息</span><br><span class="line">            if (null !&#x3D; topicConfigWrapper</span><br><span class="line">                &amp;&amp; MixAll.MASTER_ID &#x3D;&#x3D; brokerId) &#123;</span><br><span class="line">                if (this.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion())</span><br><span class="line">                    || registerFirst) &#123;</span><br><span class="line">                    ConcurrentMap&lt;String, TopicConfig&gt; tcTable &#x3D;</span><br><span class="line">                        topicConfigWrapper.getTopicConfigTable();</span><br><span class="line">                    if (tcTable !&#x3D; null) &#123;</span><br><span class="line">                        for (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;</span><br><span class="line">                            this.createAndUpdateQueueData(brokerName, entry.getValue());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 保存心跳信息</span><br><span class="line">            BrokerLiveInfo prevBrokerLiveInfo &#x3D; this.brokerLiveTable.put(brokerAddr,</span><br><span class="line">                new BrokerLiveInfo(</span><br><span class="line">                    System.currentTimeMillis(),</span><br><span class="line">                    topicConfigWrapper.getDataVersion(),</span><br><span class="line">                    channel,</span><br><span class="line">                    haServerAddr));</span><br><span class="line">            if (null &#x3D;&#x3D; prevBrokerLiveInfo) &#123;</span><br><span class="line">                log.info(&quot;new broker registered, &#123;&#125; HAServer: &#123;&#125;&quot;, brokerAddr, haServerAddr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 保存过滤信息</span><br><span class="line">            if (filterServerList !&#x3D; null) &#123;</span><br><span class="line">                if (filterServerList.isEmpty()) &#123;</span><br><span class="line">                    this.filterServerTable.remove(brokerAddr);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    this.filterServerTable.put(brokerAddr, filterServerList);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果注册的broker是从节点，通过名称寻找对应主节点，并保存主节点的IP地址</span><br><span class="line">            if (MixAll.MASTER_ID !&#x3D; brokerId) &#123;</span><br><span class="line">                String masterAddr &#x3D; brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line">                if (masterAddr !&#x3D; null) &#123;</span><br><span class="line">                    BrokerLiveInfo brokerLiveInfo &#x3D; this.brokerLiveTable.get(masterAddr);</span><br><span class="line">                    if (brokerLiveInfo !&#x3D; null) &#123;</span><br><span class="line">                        result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line">                        result.setMasterAddr(masterAddr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            this.lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        log.error(&quot;registerBroker Exception&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span class="p red">服务注册的代码不是很难理解，就是往RouteInfoManager类的5个Map中塞数据，另外slave节点在注册后的返回值中，还会拿到对应master节点的IP地址，方便注册后展开数据同步操作。</span><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>Producer与Consumer在启动后会定时向NameServer获取路由信息，以保证后续工作的正常运行，定时任务代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void startScheduledTask() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 其他代码......</span><br><span class="line"></span><br><span class="line">    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                MQClientInstance.this.updateTopicRouteInfoFromNameServer();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.error(&quot;ScheduledTask updateTopicRouteInfoFromNameServer exception&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 10, this.clientConfig.getPollNameServerInteval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 其他代码......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码就写到这吧，写多了基本就没看的欲望了，Producer与Consumer在服务发现完毕后会得到TopicRouteData集合:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TopicRouteData extends RemotingSerializable &#123;</span><br><span class="line">    private String orderTopicConf;</span><br><span class="line">    private List&lt;QueueData&gt; queueDatas;</span><br><span class="line">    private List&lt;BrokerData&gt; brokerDatas;</span><br><span class="line">    private HashMap&lt;String&#x2F;* brokerAddr *&#x2F;, List&lt;String&gt;&#x2F;* Filter Server *&#x2F;&gt; filterServerTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span class="p red">通过queueDatas可以知道当前topic有多少个队列、每个队列所在的Broker服务名称，有了名称就可以通过brokerDatas找到对应的主从节点地址，有了地址就可以通过filterServerTable处理过滤逻辑、生产/消费消息。</span><h2 id="故障剔除"><a href="#故障剔除" class="headerlink" title="故障剔除"></a>故障剔除</h2><p>Broker节点每隔30秒会向NameServer发送一次心跳，并更新自身在brokerLiveTable中的心跳时间戳，NameServer节点每隔10秒会扫描一次brokerLiveTable，如果发现某个Broker的上次更新时间戳距离当前时间超过2分钟，则认为Broker已死亡，剔除其注册信息并关闭长连接。</p><p>故障节点剔除后并不会像Kafka那样采用再均衡策略通知Producer与Consumer，而是等待他们的服务发现机制自己去感知。这就意味着某个Broker节点挂了之后Producer与Consumer最长要等30秒才会感知到。</p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rocketmq(二)服务部署</title>
      <link href="2020/09/03/RocketMQ%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/"/>
      <url>2020/09/03/RocketMQ%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于RocketMQ是使用纯Java编写的，所以NameServer、Broker的运行必须依赖于JDK环境，安装过程中需要下载依赖，因此也必须要用到maven依赖，JDK就不写了，从maven的安装开始写。</p><h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><figure class="highlight plain"><figcaption><span>下载文件</span></figcaption><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;apache&#x2F;maven&#x2F;binaries&#x2F;apache-maven-3.2.2-bin.tar.gz</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>解压文件</span></figcaption><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-maven-3.2.2-bin.tar.gz</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>编辑环境变量:</span></figcaption><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>添加环境变量:</span></figcaption><table><tr><td class="code"><pre><span class="line">export MAVEN_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;apache-maven-3.2.2</span><br><span class="line">export PATH&#x3D;$MAVEN_HOME&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>刷新环境变量</span></figcaption><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>检查是否安装成功</span></figcaption><table><tr><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>进入配置文件夹</span></figcaption><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;apache-maven-3.2.2&#x2F;conf</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>编辑xml配置文件</span></figcaption><table><tr><td class="code"><pre><span class="line">vi setting.xml</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>修改镜像仓库</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line"> </span><br><span class="line">&lt;settings xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;SETTINGS&#x2F;1.0.0&quot;</span><br><span class="line">          xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">          xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;SETTINGS&#x2F;1.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;settings-1.0.0.xsd&quot;&gt;</span><br><span class="line">  </span><br><span class="line">   &lt;localRepository&gt;&#x2F;usr&#x2F;local&#x2F;repo&lt;&#x2F;localRepository&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;mirrors&gt;</span><br><span class="line">        &lt;mirror&gt;</span><br><span class="line">            &lt;id&gt;alimaven&lt;&#x2F;id&gt;</span><br><span class="line">            &lt;name&gt;aliyun maven&lt;&#x2F;name&gt;</span><br><span class="line">            &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">            &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt;       </span><br><span class="line">        &lt;&#x2F;mirror&gt;</span><br><span class="line">  &lt;&#x2F;mirrors&gt;</span><br><span class="line"> </span><br><span class="line">&lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure><h2 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h2><figure class="highlight plain"><figcaption><span>进入/apply/rocketmq/文件夹</span></figcaption><table><tr><td class="code"><pre><span class="line">cd &#x2F;apply&#x2F;rocketmq&#x2F;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>下载安装包</span></figcaption><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;mirrors.hust.edu.cn&#x2F;apache&#x2F;rocketmq&#x2F;4.7.1&#x2F;rocketmq-all-4.7.1-source-release.zip</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>解压安装包</span></figcaption><table><tr><td class="code"><pre><span class="line">unzip rocketmq-all-4.7.1-source-release.zip</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>重命名</span></figcaption><table><tr><td class="code"><pre><span class="line">mv rocketmq-all-4.7.1-source-release &#x2F;apply&#x2F;rocketmq&#x2F;broker-a</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>进入文件夹</span></figcaption><table><tr><td class="code"><pre><span class="line">cd &#x2F;apply&#x2F;rocketmq&#x2F;broker-a</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>下载依赖</span></figcaption><table><tr><td class="code"><pre><span class="line">mvn -Prelease-all -DskipTests clean install -U</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>进入执行文件夹</span></figcaption><table><tr><td class="code"><pre><span class="line">cd distribution&#x2F;target&#x2F;rocketmq-4.7.1&#x2F;rocketmq-4.7.1&#x2F;bin</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>编辑启动文件</span></figcaption><table><tr><td class="code"><pre><span class="line">vim runserver.sh</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>修改jvm启动参数</span></figcaption><table><tr><td class="code"><pre><span class="line">JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m -Xmn512m -XX:MetaspaceSize&#x3D;128m -XX:MaxMetaspaceSize&#x3D;320m&quot;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>创建conf文件夹</span></figcaption><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;rocketmq-data&#x2F;conf</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>创建properties</span></figcaption><table><tr><td class="code"><pre><span class="line">touch &#x2F;usr&#x2F;local&#x2F;rocketmq-data&#x2F;conf&#x2F;namesrv-a.properties</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>编辑properties</span></figcaption><table><tr><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;rocketmq-data&#x2F;conf&#x2F;namesrv-a.properties</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>添加端口号</span></figcaption><table><tr><td class="code"><pre><span class="line"># 服务端口号</span><br><span class="line">listenPort&#x3D;9876 </span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>进入执行文件夹</span></figcaption><table><tr><td class="code"><pre><span class="line">cd &#x2F;apply&#x2F;rocketmq&#x2F;namesrv-a&#x2F;distribution&#x2F;target&#x2F;rocketmq-4.7.1&#x2F;rocketmq-4.7.1&#x2F;bin</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>启动</span></figcaption><table><tr><td class="code"><pre><span class="line">nohup sh mqnamesrv -c &#x2F;usr&#x2F;local&#x2F;rocketmq-data&#x2F;conf&#x2F;namesrv-a.properties &amp;</span><br></pre></td></tr></table></figure><p class="p red">注:如果NameServer仅部署一台，或者每台都在不同的机器上，properties可以不配置(端口默认就是9876)，如果本地测试想要在一台服务器上配置多个，就需要区分端口</p><h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><figure class="highlight plain"><figcaption><span>进入/apply/rocketmq/文件夹</span></figcaption><table><tr><td class="code"><pre><span class="line">cd &#x2F;apply&#x2F;rocketmq&#x2F;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>下载安装包</span></figcaption><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;mirrors.hust.edu.cn&#x2F;apache&#x2F;rocketmq&#x2F;4.7.1&#x2F;rocketmq-all-4.7.1-source-release.zip</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>解压安装包</span></figcaption><table><tr><td class="code"><pre><span class="line">unzip rocketmq-all-4.7.1-source-release.zip</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>重命名</span></figcaption><table><tr><td class="code"><pre><span class="line">mv rocketmq-all-4.7.1-source-release &#x2F;apply&#x2F;rocketmq&#x2F;broker-a</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>进入文件夹</span></figcaption><table><tr><td class="code"><pre><span class="line">cd &#x2F;apply&#x2F;rocketmq&#x2F;broker-a</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>下载依赖</span></figcaption><table><tr><td class="code"><pre><span class="line">mvn -Prelease-all -DskipTests clean install -U</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>进入执行文件夹</span></figcaption><table><tr><td class="code"><pre><span class="line">cd distribution&#x2F;target&#x2F;rocketmq-4.7.1&#x2F;rocketmq-4.7.1&#x2F;bin</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>编辑启动文件</span></figcaption><table><tr><td class="code"><pre><span class="line">vim runbroker.sh</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>修改jvm启动参数</span></figcaption><table><tr><td class="code"><pre><span class="line">JAVA_OPT&#x3D;&quot;$&#123;JAVA_OPT&#125; -server -Xms256m -Xmx256m -Xmn512m&quot;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>创建store文件夹</span></figcaption><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;rocketmq-data&#x2F;store-broker-a</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>创建commitlog文件夹</span></figcaption><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;rocketmq-data&#x2F;store-broker-a&#x2F;commitlog</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>创建properties</span></figcaption><table><tr><td class="code"><pre><span class="line">touch &#x2F;usr&#x2F;local&#x2F;rocketmq-data&#x2F;conf&#x2F;broker-a.properties</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>编辑properties</span></figcaption><table><tr><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;rocketmq-data&#x2F;conf&#x2F;broker-a.properties</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>添加属性</span></figcaption><table><tr><td class="code"><pre><span class="line">#服务端口号</span><br><span class="line">listenPort&#x3D;10911</span><br><span class="line">#集群名</span><br><span class="line">brokerClusterName &#x3D; lvt-cluster</span><br><span class="line">#broker服务名</span><br><span class="line">brokerName &#x3D; broker-a</span><br><span class="line">#0表示master，大于0表示各个slave</span><br><span class="line">brokerId &#x3D; 0</span><br><span class="line">#删除文件时间点，默认凌晨 4点</span><br><span class="line">deleteWhen &#x3D; 04</span><br><span class="line">#文件保留时间,默认48小时</span><br><span class="line">fileReservedTime &#x3D; 48</span><br><span class="line">#Broker角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">brokerRole &#x3D; ASYNC_MASTER</span><br><span class="line">#刷盘方式</span><br><span class="line">#- ASYNC_FLUSH 异步刷盘</span><br><span class="line">#- SYNC_FLUSH 同步刷盘</span><br><span class="line">flushDiskType &#x3D; ASYNC_FLUSH</span><br><span class="line">#公网</span><br><span class="line">brokerIP1 &#x3D; 172.0.0.1</span><br><span class="line">#注册中心地址，多个使用;分开</span><br><span class="line">namesrvAddr&#x3D;172.0.0.1:9876</span><br><span class="line">#是否自动创建，生产建议关闭</span><br><span class="line">autoCreateTopicEnable&#x3D;true</span><br><span class="line">#持久化消息存储根路径</span><br><span class="line">storePathRootDir&#x3D;&#x2F;usr&#x2F;local&#x2F;rocketmq-data&#x2F;store-broker-a</span><br><span class="line">#commitLog文件存储路径</span><br><span class="line">storePathCommitLog&#x3D;&#x2F;usr&#x2F;local&#x2F;rocketmq-data&#x2F;store-broker-a&#x2F;commitlog</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>进入执行文件夹</span></figcaption><table><tr><td class="code"><pre><span class="line">cd &#x2F;apply&#x2F;rocketmq&#x2F;broker-a&#x2F;distribution&#x2F;target&#x2F;rocketmq-4.7.1&#x2F;rocketmq-4.7.1&#x2F;bin</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>启动</span></figcaption><table><tr><td class="code"><pre><span class="line">nohup sh mqbroker -c &#x2F;usr&#x2F;local&#x2F;rocketmq-data&#x2F;conf&#x2F;broker-a.properties &amp;</span><br></pre></td></tr></table></figure><p class="p red">注:在网上看到很多资料将配置写在broker.conf中，上述的不是方式不会读取这个配置文件，如果这么做也不会报错，因为这些参数全部自带默认值。</p><p class="p red">另外在配置属性中关于store的一些路径只能设置storePathRootDir、storePathCommitLog这俩个，其他的写进去会导致项目无法启动(如果写的路径是错的则不会，应该是没检测到路径就改用默认值了)。</p><p class="p red">还有个奇怪的事情，我在腾讯云部署的伪Broker集群，发现不同的节点端口号不能相邻，否则会报端口占用，目前是各服务的端口号隔几百。</p><h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><figure class="highlight plain"><figcaption><span>进入git网址，下载源码(点击Download ZIP)</span></figcaption><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;rocketmq-externals.git</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>上传到服务器/apply/rocketmq文件夹，并解压</span></figcaption><table><tr><td class="code"><pre><span class="line">unzip &#x2F;apply&#x2F;rocketmq&#x2F;rocketmq-externals-master.zip</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>重命名文件夹</span></figcaption><table><tr><td class="code"><pre><span class="line">mv &#x2F;apply&#x2F;rocketmq&#x2F;rocketmq-externals-master console</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>创建数据文件夹</span></figcaption><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;rocketmq-data&#x2F;console-data</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>编辑application.properties</span></figcaption><table><tr><td class="code"><pre><span class="line">vim &#x2F;apply&#x2F;rocketmq&#x2F;console&#x2F;rocketmq-console&#x2F;src&#x2F;main&#x2F;resources&#x2F;application.properties</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>修改属性</span></figcaption><table><tr><td class="code"><pre><span class="line"># 注册中心地址端口</span><br><span class="line">rocketmq.config.namesrvAddr&#x3D;172.0.0.1:9876</span><br><span class="line"># 存放数据路径</span><br><span class="line">rocketmq.config.dataPath&#x3D;&#x2F;usr&#x2F;local&#x2F;rocketmq-data&#x2F;console-data</span><br><span class="line"># 是否需要登陆</span><br><span class="line">rocketmq.config.loginRequired&#x3D;true</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>编辑users.properties</span></figcaption><table><tr><td class="code"><pre><span class="line">vim &#x2F;apply&#x2F;rocketmq&#x2F;console&#x2F;rocketmq-console&#x2F;src&#x2F;main&#x2F;resources&#x2F;users.properties</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>设置登录控制台的账号密码(注释的汉字别打进去，否则下面编译不通过)</span></figcaption><table><tr><td class="code"><pre><span class="line"># 设置管理员，格式:username&#x3D;password[,N]  其中N是可选项:0为普通用户 1为管理员</span><br><span class="line">admin&#x3D;admin,1</span><br><span class="line"># 普通成员</span><br><span class="line">member&#x3D;member</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>进入解压文件夹</span></figcaption><table><tr><td class="code"><pre><span class="line">cd &#x2F;apply&#x2F;rocketmq&#x2F;console&#x2F;rocketmq-console</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>执行编译(一定要编辑完配置在编译，否则配置无效)</span></figcaption><table><tr><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip&#x3D;true</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>进入jar包文件夹</span></figcaption><table><tr><td class="code"><pre><span class="line">cd &#x2F;apply&#x2F;rocketmq&#x2F;console&#x2F;rocketmq-console&#x2F;target</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>启动服务</span></figcaption><table><tr><td class="code"><pre><span class="line">nohup java -jar rocketmq-console-ng-2.0.0.jar &amp;</span><br></pre></td></tr></table></figure><p class="p red">注:如果rocketmq.config.loginRequired设置为false，则不需要编辑users.properties设置登录用的账号密码。在设置为true的情况下，如果不编辑users.properties文件设置账号密码，会有个默认账号可以直接登录(admin/admin)，生产环境为了安全起见，建议自定义账号密码。</p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ(一)架构原理</title>
      <link href="2020/09/01/RocketMQ%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/"/>
      <url>2020/09/01/RocketMQ%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RocketMQ是阿里巴巴开源的消息中间件，使用Java语言开发，具有高吞吐量、高可用性，适合大规模分布式系统应用的特点。设计方面参考了kafka的整体机制和架构设计，并在此基础上添加了分布式事务、定时消息、消费失败重试、回溯消息等功能，虽然在吞吐量上无法企及kafka，但是扩展的诸多功能相对于kafka来说，更能胜任电商、金融等领域的复杂业务场景。</p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p><font size="4"><b>Broker:</b></font><br>Broker是集群中最核心的，也是最复杂的组件，负责消息的存储、投递、查询，以及保证服务的高可用，支持容错机制、灾备机制、报警机制和丰富的监控指标。</p><p><font size="4"><b>NameServer:</b></font><br>NameServer可以看作是RocketMQ的注册中心，类似于Dubbo、kafka的注册中心zookeeper，broker启动后会将自身管理的topic-queue信息注册到NameServer，为Producer或Consumer提供路由。</p><p>Name Server集群实例之间不会互相通讯，但是Broker会向所有的Name注册路由信息，所以每个NameServer实例上都保存了完整的路由信息。</p><p><font size="4"><b>Producer:</b></font><br>Producer是发布消息的角色，在程序启动后通过NameServer获取所有Broker的路由信息，通过多种负载均衡的方式，选择相应的Broker Server 集群中的Queue发送消息。Producer 在发送消息时，支持快速失败，并且是低延迟的。</p><p><font size="4"><b>Consumer:</b></font><br>Consumer是消费消息的角色，支持PUSH和PULL两种获取消息模式，支持集群和广播两种消费消息模式。</p><h2 id="消息领域模型"><a href="#消息领域模型" class="headerlink" title="消息领域模型"></a>消息领域模型</h2><p><font size="4"><b>Topic:</b></font><br>Topic的作用是将整个RocketMQ集群的消息进行划分，使不同类型的消息区分开来，以便于消费者针对不同的消息类型做不同的业务处理。</p><p><font size="4"><b>Tag:</b></font><br>Tag可以看作是消息的二级分类，一般在相同业务模块中通过引入标签来标记不同用途的消息，另外RocketMQ允许消费者按照Tag对消息进行过滤，也可以通过Tag过滤不需要的数据。</p><p><font size="4"><b>Message:</b></font><br>Message就是我们发送或消费的消息，用户在发送消息的时候可以设置messageKey，也就是消息的唯一识别MessageId，便于后续的查询和追踪。</p><p><font size="4"><b>Producer Group:</b></font><br>开发者在启动Producer时可以指定一个生产组，如果没有指定会自动生成一个(默认为DEFAULT_PRODUCER)。Producer Group主要用于推送事务消息，比如Producer在投递事务消息时宕机，本地事务回滚，可以继续联系该组下的另外一个生产者实例，不至于导致业务走不下去。</p><p><font size="4"><b>Consumer Group:</b></font><br>开发者在启动Producer时可以指定一个消费组，用于负载均衡共同消费消息。</p><h2 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h2><p><img src="/2020/09/01/RocketMQ%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/RocketMQ%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84.png" class="lazyload" data-srcset="/2020/09/01/RocketMQ%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/RocketMQ%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><font size="4"><b>Broker特点:</b></font><br>Broker服务分为Master与Slave，一个Master可以对应多个Slaver，Master与Slaver的对应关系通过指定相同的BrokerName、不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slaver。</p><p><font size="4"><b>Producer特点:</b></font><br>Producer服务会随机与NameServer集群中的一个节点建立长连接，定期从NameServer获取topic-queue路由信息，然后与topic-queue所在的 BrokerServer的Master节点建立长连接，并且会定时向Master发送心跳。Producer集群完全是无状态的，可以随意集群部署。</p><p><font size="4"><b>Consumer特点:</b></font><br>Consumer服务会随机与NameServer集群中的一个节点建立长连接，定期从NameServer获取topic-queue路由信息，然后与topic-queue所在的BrokerServer的Master节点建立长连接，并且会定时向Master和Salve发送心跳。</p><p>Consumer既可以从Master订阅消息，也可以从Salve订阅消息，Consumer在获取消息的时候，BrokerServer的Master节点会根据获取消息的偏移量与最大偏移量的距离、服务器是否可读等因素建议Consumer下次是从 Master或者Salve获取消息。</p><h2 id="topic分布"><a href="#topic分布" class="headerlink" title="topic分布"></a>topic分布</h2><p>集群中所有topic都是以queue(1个或多个)的形式分散存储在各broker节点中，其中每个queue仅仅保存topic的一部分消息数据。这种架构设计与redis、elasticsearch的分片模式很相似，可以在整个RocketMQ集群服务运行过程中动态改变queue的数量，来控制同一时刻topic的并行处理能力。</p><p>假设一个Broker集群有3个节点，并且整个集群存储了3个topic:</p><table><thead><tr><th>topic名称</th><th>queue数量</th></tr></thead><tbody><tr><td>red</td><td>4</td></tr><tr><td>blue</td><td>5</td></tr><tr><td>green</td><td>6</td></tr></tbody></table><p>topic在Broker的分布图:<br><img src="/2020/09/01/RocketMQ%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/topic%E5%88%86%E5%B8%83%E5%9B%BE.png" class="lazyload" data-srcset="/2020/09/01/RocketMQ%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/topic%E5%88%86%E5%B8%83%E5%9B%BE.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><span class="p red">注:不同的master节点存储的topic-queue数据完全不一致，而master与对应的slave节点负责的数据完全一致</span>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流(十五) DirectByteBuffer</title>
      <link href="2020/06/03/IO%E6%B5%81-DirectByteBuffer/"/>
      <url>2020/06/03/IO%E6%B5%81-DirectByteBuffer/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>DirectByteBuffer是直接缓冲区，<span class="p red">也就是说缓冲的数据并不在JVM堆内，而是在内核内存中。</span>在执行IO操作时，也就省去了从堆内存到JNI内存、从JNI内存到内核内存两次拷贝，效率大大提高。但堆外内存的回收不受GC的影响，需要在Java层面自己去管理。</p><p>DirectByteBuffer的底层通过mmap()系统函数实现，可以通过<span class="p red">文件映射</span>或<span class="p red">匿名映射</span>的方式申请堆外内存，重写ByteBuffer类的抽象方法时，也都是直接对内存地址进行操作。</p><h2 id="2-映射方式"><a href="#2-映射方式" class="headerlink" title="2.映射方式"></a>2.映射方式</h2><h3 id="2-1-文件映射"><a href="#2-1-文件映射" class="headerlink" title="2.1 文件映射"></a>2.1 文件映射</h3><p>对磁盘文件的映射，是将磁盘文件的整体或部分区域，映射到进程的虚拟地址空间，这块虚拟地址存在与之对应的一块磁盘地址。在Java中，文件映射通过FileChannel类实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建随机访问文件对象，设置为可读(r)可写(w)</span></span><br><span class="line">    RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;/文件路径&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件通道对象</span></span><br><span class="line">    FileChannel fileChannel = raf.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建映射缓冲区，映射区域为文件的全部地址，并且支持读和写</span></span><br><span class="line">    MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, (<span class="keyword">int</span>) fc.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>FileChannel类的map()方法，虽然映射大小在方法参数中是long类型，但内部的校验逻辑却不允许值超出<span class="p red">Integer.MAX_VALUE</span>，也就是单次最多映射2个G大小(2^32个字节)，如果文件超出2G需要分成多段映射。Java层面并没有对映射的总大小进行限制，使用不当会引起<span class="p red">本机内存溢出。</span><h3 id="2-2-匿名映射"><a href="#2-2-匿名映射" class="headerlink" title="2.2 匿名映射"></a>2.2 匿名映射</h3><p>内存映射可以不依赖磁盘文件，本质上是按照申请大小在物理内存(内存条)上选择一块区域，映射到进程的虚拟地址空间，不关联其他任何设备源，在Linux系统中通过malloc()函数实现。在Java中，ByteBuffer提供了静态方法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>匿名映射的总大小受<span class="p blue">JVM参数:-XX:MaxDirectMemorySize</span>限制，默认和JVM堆大小保持一致，如果申请时超出限制则<span class="p red">JVM堆内存溢出</span>。这只是JVM层面的限制，当请求到达操作系统层面，还会存在本机的RAM、SWAP、CPU寻址空间等限制。<h2 id="3-MappedByteBuffer"><a href="#3-MappedByteBuffer" class="headerlink" title="3.MappedByteBuffer"></a>3.MappedByteBuffer</h2><p>MappedByteBuffer是DirectByteBuffer的抽象父类，但内部所有功能都是针对文件映射设计的，如果是通过匿名映射方式创建，就没有对应的磁盘文件，那么调用MappedByteBuffer方法会报错，具体的细节在下面源码中会讲解。</p><h3 id="3-1-SWAP机制"><a href="#3-1-SWAP机制" class="headerlink" title="3.1 SWAP机制"></a>3.1 SWAP机制</h3><p>SWAP机制是操作系统对运行内存使用率的优化，当操作系统的物理内存不够使用时，会将一部分暂时不会被使用的内存释放出来，也就是写在硬盘上，以供当前运行的程序使用，这个现象称为<span class="p red">换出</span>。那些被释放的空间可能来自一些很长时间没有什么操作的程序，等到那些程序要运行时，再从硬盘的Swap分区中，将原先保存的数据加载回物理内存，这个现象称为<span class="p red">换入</span>。</p><p>并不是所有的内存数据都会被交换到Swap分区中，有相当一部分数据被直接交换到文件系统。例如通过文件映射生成的内存，当内存使用紧张时，临时交换到硬盘的Swap分区没有意义，可以直接刷回对应的文件所在地址，下次恢复直接根据文件地址读取数据到内存即可；通过匿名映射生成的内存，不会像前者那样有个地方可以持久化，因此必须要交换到Swap分区。</p><p><img src="/2020/06/03/IO%E6%B5%81-DirectByteBuffer/SWAP%E5%88%86%E5%8C%BA%E4%BA%A4%E6%8D%A2.png" class="lazyload" data-srcset="/2020/06/03/IO%E6%B5%81-DirectByteBuffer/SWAP%E5%88%86%E5%8C%BA%E4%BA%A4%E6%8D%A2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h3 id="3-2-缺页机制"><a href="#3-2-缺页机制" class="headerlink" title="3.2 缺页机制"></a>3.2 缺页机制</h3><p>现在的操作系统基本都采用分页的形式管理内存，这个分页机制与文件系统的PageCache很相似，但完全是两个不同的东西。对于文件映射出来的内存想要持久化到硬盘，是将数据委托给文件系统，而多数文件系统会先将数据写入PageCache，然后在合适的时候刷回硬盘。内存中的数据无论回到文件系统、还是SWAP分区，都是以页为单位进行IO。</p><p>在创建DirectByteBuffer后，并不会直接分配物理内存，当第一次访问数据地址时，操作系统会产生一个缺页异常，触发中断后将数据从硬盘加载到物理内存中，后续还有可能又被换入Swap分区。MappedByteBuffer提供了相关方法，检查当前映射的数据是否已加载到物理内存，或者手动加载到物理内存中。</p><h3 id="3-3-成员变量和构造器"><a href="#3-3-成员变量和构造器" class="headerlink" title="3.3 成员变量和构造器"></a>3.3 成员变量和构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBuffer</span> <span class="keyword">extends</span> <span class="title">ByteBuffer</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span> unused;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FileDescriptor fd;</span><br><span class="line"></span><br><span class="line">MappedByteBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap, FileDescriptor fd)&#123;</span><br><span class="line">        <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">        <span class="keyword">this</span>.fd = fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">MappedByteBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123;</span><br><span class="line">        <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">        <span class="keyword">this</span>.fd = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>MappedByteBuffer共有两个构造器，第一个构造器供文件映射创建时使用，需要指定磁盘文件的描述符对象；第二个构造器供匿名映射创建时使用，不需要指定磁盘文件的描述符。<p>成员变量unused好像没啥用，不过这个fd很有意思，FileChannel类的map()方法中，并没有将真正的描述符对象传入构造器，而是创建了一个新的描述符对象，里面的描述符值永远是-1。其实读完源码就会明白，fd的作用只是通过是否为null来判断创建的方式。</p><h3 id="3-4-native方法"><a href="#3-4-native方法" class="headerlink" title="3.4 native方法"></a>3.4 native方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前映射的区域是否已经加载到物理内存(内存条)上</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isLoaded0</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> length, <span class="keyword">int</span> pageCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定部分的映射加载到物理内存(内存条)上</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">load0</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层调用msync()系统函数刷盘，可以指定刷盘的映射区域范围，提高效率</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">force0</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">long</span> length)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-5-private方法"><a href="#3-5-private方法" class="headerlink" title="3.5 private方法"></a>3.5 private方法</h3><p><strong>①映射校验</strong>，如果fd为null，代表当前类是通过匿名映射创建的，如果fd不为null，代表当前类是通过文件映射创建的。MappedByteBuffer类所有对外提供的功能都是针对文件映射的，因此所有public修饰方法的第一行代码，都会调用此方法验证当前类的创建方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkMapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><strong>②映射内存的偏移量</strong>，FileChannel类的map()方法可以通过position参数，指定映射的起始地址，也就是说address不一定刚好在某个页的开始位置，此方法就是用于计算address的所在页，与页开始位置的字节距离:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">mappingOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> offset = address % ps;</span><br><span class="line">    <span class="keyword">return</span> (offset &gt;= <span class="number">0</span>) ? offset : (ps + offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设选择一个6KB大小的磁盘文件，通过map()方法进行映射，position设置为2、size设置为1024，偏移量如图:<br><img src="/2020/06/03/IO%E6%B5%81-DirectByteBuffer/%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84-%E5%81%8F%E7%A7%BB%E9%87%8F.png" class="lazyload" data-srcset="/2020/06/03/IO%E6%B5%81-DirectByteBuffer/%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84-%E5%81%8F%E7%A7%BB%E9%87%8F.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><br><br><strong>③映射内存的访问地址</strong>，在指定position值映射文件时，address不一定正好落在某个页的起始位置，但内存映射的最小单位为页，必然会被加载到虚拟内存以及物理内存中。因此想要得到实际映射地址值，需要根据映射偏移量，往前推一段距离:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">mappingAddress</span><span class="params">(<span class="keyword">long</span> mappingOffset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> address - mappingOffset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设选择一个6KB大小的磁盘文件，通过map()方法进行映射，position设置为2、size设置为1024，实际映射地址如图:<br><img src="/2020/06/03/IO%E6%B5%81-DirectByteBuffer/%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84-%E5%AE%9E%E9%99%85%E6%98%A0%E5%B0%84%E5%9C%B0%E5%9D%80.png" class="lazyload" data-srcset="/2020/06/03/IO%E6%B5%81-DirectByteBuffer/%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84-%E5%AE%9E%E9%99%85%E6%98%A0%E5%B0%84%E5%9C%B0%E5%9D%80.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><br><br><strong>④映射内存的地址长度</strong>，在偏移量大于零的情况下，实际映射内存地址肯定要比address小一些，那么地址的长度也是一样的道理。address对应的长度就是容量，需要在加上偏移量值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">mappingLength</span><span class="params">(<span class="keyword">long</span> mappingOffset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span>)capacity() + mappingOffset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设选择一个6KB大小的磁盘文件，通过map()方法进行映射，position设置为2、size设置为1024，实际映射长度如图:<br><img src="/2020/06/03/IO%E6%B5%81-DirectByteBuffer/%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84-%E5%AE%9E%E9%99%85%E6%98%A0%E5%B0%84%E9%95%BF%E5%BA%A6.png" class="lazyload" data-srcset="/2020/06/03/IO%E6%B5%81-DirectByteBuffer/%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84-%E5%AE%9E%E9%99%85%E6%98%A0%E5%B0%84%E9%95%BF%E5%BA%A6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h3 id="3-6-public方法"><a href="#3-6-public方法" class="headerlink" title="3.6 public方法"></a>3.6 public方法</h3><p><strong>判断当前对象映射的文件地址，是否已经加载到物理地址(内存条)中:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLoaded</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须是文件映射创建的缓冲区</span></span><br><span class="line">    checkMapped();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓冲区为空，直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> ((address == <span class="number">0</span>) || (capacity() == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取映射区域的偏移量</span></span><br><span class="line">    <span class="keyword">long</span> offset = mappingOffset();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取映射的长度</span></span><br><span class="line">    <span class="keyword">long</span> length = mappingLength(offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定映射的区域范围，判断是否加载到物理地址中</span></span><br><span class="line">    <span class="keyword">return</span> isLoaded0(mappingAddress(offset), length, Bits.pageCount(length));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><strong>将当前对象映射的文件地址，加载到物理地址(内存条)中:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MappedByteBuffer <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须是文件映射创建的缓冲区</span></span><br><span class="line">    checkMapped();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓冲区为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((address == <span class="number">0</span>) || (capacity() == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取偏移量、映射长度</span></span><br><span class="line">    <span class="keyword">long</span> offset = mappingOffset();</span><br><span class="line">    <span class="keyword">long</span> length = mappingLength(offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过偏移量计算出实际地址，进行加载</span></span><br><span class="line">    load0(mappingAddress(offset), length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取默认页大小</span></span><br><span class="line">    Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前映射长度需要几页</span></span><br><span class="line">    <span class="keyword">int</span> count = Bits.pageCount(length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实际地址</span></span><br><span class="line">    <span class="keyword">long</span> a = mappingAddress(offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将每一页的起始字节数据读取一遍，好像是给unused赋值的，没看懂...</span></span><br><span class="line">    <span class="keyword">byte</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        x ^= unsafe.getByte(a);</span><br><span class="line">        a += ps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unused != <span class="number">0</span>)</span><br><span class="line">        unused = x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><strong>将映射内存区域的内容，持久化到磁盘上，底层通过msync()系统函数:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MappedByteBuffer <span class="title">force</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须是文件映射创建的缓冲区</span></span><br><span class="line">    checkMapped();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在缓冲数据</span></span><br><span class="line">    <span class="keyword">if</span> ((address != <span class="number">0</span>) &amp;&amp; (capacity() != <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取偏移量</span></span><br><span class="line">        <span class="keyword">long</span> offset = mappingOffset();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据偏移量计算出的起始地址、实际长度，将该区域的内存数据刷回磁盘</span></span><br><span class="line">        force0(fd, mappingAddress(offset), mappingLength(offset));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-DirectByteBuffer"><a href="#4-DirectByteBuffer" class="headerlink" title="4.DirectByteBuffer"></a>4.DirectByteBuffer</h2><h3 id="4-1-成员变量"><a href="#4-1-成员变量" class="headerlink" title="4.1 成员变量"></a>4.1 成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectByteBuffer</span> <span class="keyword">extends</span> <span class="title">MappedByteBuffer</span> <span class="keyword">implements</span> <span class="title">DirectBuffer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此类用于直接访问系统资源</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Bits.unsafe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JVM中一个对象由头、实例数据、对齐填充组成，此方法可以看作是对象头的长度</span></span><br><span class="line">    <span class="comment">// 对象头后面就是真实的数据，这里视为第一个元素在数组中的起始坐标，用于后续读写数据的位置参考</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> arrayBaseOffset = (<span class="keyword">long</span>)unsafe.arrayBaseOffset(<span class="keyword">byte</span>[].class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否按照非对齐访问，比如存储6个字节，分配的地址值如果永远是6的倍数，那就是对齐访问</span></span><br><span class="line">    <span class="comment">// 内存是不是对齐访问，是由操作系统决定的，用于减少CPU的读写效率</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> unaligned = Bits.unaligned();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和堆外内存释放有关，下面会讲</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object att;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前对象被回收后，堆外内存释放对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cleaner cleaner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-构造器"><a href="#4-2-构造器" class="headerlink" title="4.2 构造器"></a>4.2 构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父类MappedByteBuffer的构造器</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接内存是否要页对齐，这个返回值和操作系统有关系</span></span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取默认的页大小(通常为4096，也就是4KB)</span></span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要页对齐，最终映射的内存大小要比实际申请的大小，多出一个默认页的大小</span></span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JVM控制可申请直接内存的总大小，每次申请时需要调用此方法，检查剩余可申请的直接内存容量，是否足够本次分配</span></span><br><span class="line">    <span class="comment">// 如果分配成功，JVM会更新已分配直接内存大小记录，如果不够分配，则抛出异常</span></span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用Unsafe类，匿名映射一块指定大小的内存，并返回映射地址</span></span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        <span class="comment">// 映射失败，先将JVM刚刚加上的已分配的直接内存的大小减掉，在抛出异常</span></span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将地址所有值都设置为0</span></span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要页对齐，但申请的内存大小不是默认页大小的整数倍，利用上面多申请的一页内存，将内存地址填充对齐</span></span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是整数倍则直接使用</span></span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个直接内存的回收对象，用于直接内存的回收，Cleaner类下面会单独讲</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和其他缓冲区没任何关系，所以设置为null</span></span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-读写方法"><a href="#4-2-读写方法" class="headerlink" title="4.2 读写方法"></a>4.2 读写方法</h3><p><br><strong>重写ByteBuffer的三个读取方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从映射区域读取单个字节数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((unsafe.getByte(ix(nextGetIndex()))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从映射区域读取i个字节数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((unsafe.getByte(ix(checkIndex(i)))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从映射区域的offset坐标，批量读取length个字节并填装到dst数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当读取的元素数量超过默认阈值</span></span><br><span class="line">    <span class="keyword">if</span> (((<span class="keyword">long</span>)length &lt;&lt; <span class="number">0</span>) &gt; Bits.JNI_COPY_TO_ARRAY_THRESHOLD) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 老规矩，调用Buffer的静态方法校验坐标</span></span><br><span class="line">        checkBounds(offset, length, dst.length);</span><br><span class="line">        <span class="keyword">int</span> pos = position();</span><br><span class="line">        <span class="keyword">int</span> lim = limit();</span><br><span class="line">        <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取的坐标范围最多到limit限制值</span></span><br><span class="line">        <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (length &gt; rem)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部采用Unsafe.copyMemory()方法进行拷贝</span></span><br><span class="line">        Bits.copyToArray(ix(pos), dst, arrayBaseOffset,</span><br><span class="line">                             (<span class="keyword">long</span>)offset &lt;&lt; <span class="number">0</span>,</span><br><span class="line">                             (<span class="keyword">long</span>)length &lt;&lt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 更新读取进度</span></span><br><span class="line">        position(pos + length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当读取的元素数量低于默认阈值，调用Buffer的一个个读取方式，消耗成本更低</span></span><br><span class="line">        <span class="keyword">super</span>.get(dst, offset, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><strong>重写ByteBuffer的四个写入方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将单个字节写入映射区域</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    unsafe.putByte(ix(nextPutIndex()), ((x)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将单个字节写入映射区域</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">byte</span> x)</span> </span>&#123;</span><br><span class="line">    unsafe.putByte(ix(checkIndex(i)), ((x)));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字节缓冲对象的数据写入映射区域</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(ByteBuffer src)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果参数缓冲对象是DirectByteBuffer类型</span></span><br><span class="line">    <span class="keyword">if</span> (src <span class="keyword">instanceof</span> DirectByteBuffer) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能是自己</span></span><br><span class="line">        <span class="keyword">if</span> (src == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转化成DirectByteBuffer引用</span></span><br><span class="line">        DirectByteBuffer sb = (DirectByteBuffer)src;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取参数缓冲区对象的 读取位置、边界值</span></span><br><span class="line">        <span class="keyword">int</span> spos = sb.position();</span><br><span class="line">        <span class="keyword">int</span> slim = sb.limit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能越界</span></span><br><span class="line">        <span class="keyword">assert</span> (spos &lt;= slim);</span><br><span class="line">        <span class="keyword">int</span> srem = (spos &lt;= slim ? slim - spos : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前也就是要写入的缓冲区的 读取位置、边界值</span></span><br><span class="line">        <span class="keyword">int</span> pos = position();</span><br><span class="line">        <span class="keyword">int</span> lim = limit();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 也不能越界</span></span><br><span class="line">        <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line">        <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (srem &gt; rem)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将参数缓冲区的position坐标往后，直到limit坐标的数据，写入当前缓冲区的映射内存中</span></span><br><span class="line">        unsafe.copyMemory(sb.ix(spos), ix(pos), (<span class="keyword">long</span>)srem &lt;&lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新参数缓冲区的读取进度</span></span><br><span class="line">        sb.position(spos + srem);</span><br><span class="line">        <span class="comment">// 更新当前缓冲区的读取进度</span></span><br><span class="line">        position(pos + srem);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (src.hb != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果hb数组不为空，那就从数组中读取对应的数据，写入当前缓冲区的映射内存中</span></span><br><span class="line">        <span class="keyword">int</span> spos = src.position();</span><br><span class="line">        <span class="keyword">int</span> slim = src.limit();</span><br><span class="line">        <span class="keyword">assert</span> (spos &lt;= slim);</span><br><span class="line">        <span class="keyword">int</span> srem = (spos &lt;= slim ? slim - spos : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        put(src.hb, src.offset + spos, srem);</span><br><span class="line">        src.position(spos + srem);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果参数缓冲区无法预判什么类型的，就调用父类的方法一个个循环写入</span></span><br><span class="line">        <span class="keyword">super</span>.put(src);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((<span class="keyword">long</span>)length &lt;&lt; <span class="number">0</span>) &gt; Bits.JNI_COPY_FROM_ARRAY_THRESHOLD) &#123;</span><br><span class="line">        checkBounds(offset, length, src.length);</span><br><span class="line">        <span class="keyword">int</span> pos = position();</span><br><span class="line">        <span class="keyword">int</span> lim = limit();</span><br><span class="line">        <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line">        <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (length &gt; rem)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Bits.copyFromArray(src, arrayBaseOffset,</span><br><span class="line">                               (<span class="keyword">long</span>)offset &lt;&lt; <span class="number">0</span>,</span><br><span class="line">                               ix(pos),</span><br><span class="line">                               (<span class="keyword">long</span>)length &lt;&lt; <span class="number">0</span>);</span><br><span class="line">        position(pos + length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.put(src, offset, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p class="p red">基本上和HeapByteBuffer的重写逻辑差不多，只不过HeapByteBuffer的position对应数组的坐标，而DirectByteBuffer的position对应映射地址的偏移量。</p><h3 id="4-3-复制方法"><a href="#4-3-复制方法" class="headerlink" title="4.3 复制方法"></a>4.3 复制方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于当前缓冲区，从position开始往后切割一个缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">slice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="keyword">this</span>.position();</span><br><span class="line">    <span class="keyword">int</span> lim = <span class="keyword">this</span>.limit();</span><br><span class="line">    <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line">    <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> off = (pos &lt;&lt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">assert</span> (off &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(<span class="keyword">this</span>, -<span class="number">1</span>, <span class="number">0</span>, rem, rem, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于当前缓冲区，复制一个缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(<span class="keyword">this</span>, <span class="keyword">this</span>.markValue(), <span class="keyword">this</span>.position(), <span class="keyword">this</span>.limit(), <span class="keyword">this</span>.capacity(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于当前缓冲区，复制一个只读缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBufferR(<span class="keyword">this</span>, <span class="keyword">this</span>.markValue(), <span class="keyword">this</span>.position(), <span class="keyword">this</span>.limit(), <span class="keyword">this</span>.capacity(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-其他方法"><a href="#4-4-其他方法" class="headerlink" title="4.4 其他方法"></a>4.4 其他方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pos = position();</span><br><span class="line">    <span class="keyword">int</span> lim = limit();</span><br><span class="line">    <span class="keyword">assert</span> (pos &lt;= lim);</span><br><span class="line">    <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    unsafe.copyMemory(ix(pos), ix(<span class="number">0</span>), (<span class="keyword">long</span>)rem &lt;&lt; <span class="number">0</span>);</span><br><span class="line">    position(rem);</span><br><span class="line">    limit(capacity());</span><br><span class="line">    discardMark();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-堆外内存释放"><a href="#5-堆外内存释放" class="headerlink" title="5.堆外内存释放"></a>5.堆外内存释放</h2><p>JVM可以回自动收堆内的DirectByteBuffer对象，但对应的堆外内存的释放必须通过Unsafe类的freeMemory()方法，而DirectByteBuffer类并没有封装相关方法供开发者使用完毕后调用，而是在对象创建的时候就生成一个钩子函数，当DirectByteBuffer被GC回收时触发，释放对应的堆外内存。</p><h3 id="5-1-Deallocator"><a href="#5-1-Deallocator" class="headerlink" title="5.1 Deallocator"></a>5.1 Deallocator</h3><p>DirectByteBuffer对象的构造器中，会将自身以及一个Deallocator对象封装成一个Cleaner实例，用于后续的堆外内存回收:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建DirectByteBuffer时调用</span></span><br><span class="line">cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建DirectByteBufferR时调用</span></span><br><span class="line">cleaner = Cleaner.create(<span class="keyword">this</span>, unmapper);</span><br></pre></td></tr></table></figure><br><p>Deallocator是DirectByteBuffer的私有内部类，在创建时需要指定堆外内存的信息，并将堆外内存释放的逻辑代码封装在run()方法内部，供Cleaner调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deallocator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Deallocator</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> size, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> (address != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子函数执行逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果address为0，说明已经清理过了</span></span><br><span class="line">        <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定堆外地址，释放内存</span></span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将地址内容作废</span></span><br><span class="line">        address = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从JVM的计数器中，减去释放的内存大小</span></span><br><span class="line">        Bits.unreserveMemory(size, capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-Cleaner"><a href="#5-2-Cleaner" class="headerlink" title="5.2 Cleaner"></a>5.2 Cleaner</h3><p>Cleaner类的源码就不写了，它本质上是个虚引用对象，并且顶层继承是Reference抽象类，Reference抽象类内部有个静态的单向链表，当某个DirectByteBuffer实例除了Reference实现类之外，没有其他强引用时，这些Reference实现类会被JVM放入Reference抽象类的静态单向链表。</p><p>Reference抽象类的内部还有一个静态代码块，初始化一个名叫ReferenceHandler的线程，这个线程是个优先级很高的守护线程，启动后会不停的循环上述的静态单向链表，如果不为空就根据情况作出对应的逻辑处理:<br><img src="/2020/06/03/IO%E6%B5%81-DirectByteBuffer/Cleaner%E8%99%9A%E5%BC%95%E7%94%A8.png" class="lazyload" data-srcset="/2020/06/03/IO%E6%B5%81-DirectByteBuffer/Cleaner%E8%99%9A%E5%BC%95%E7%94%A8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><br><p class="p red">从流程图中可以看出，JDK对Cleaner类型的虚引用做了特殊处理，强转并调用clean()方法，到这里就触发DirectByteBuffer实例创建时注册的钩子函数，使堆内对象与对应的堆外内存一起被释放。关于虚引用的原理，这里讲的比较简单，如果想要掌握具体的实现，还得去看Reference源码。</p><h3 id="5-3-att属性"><a href="#5-3-att属性" class="headerlink" title="5.3 att属性"></a>5.3 att属性</h3><p>堆外内存释放还有个细节，例如创建一个DirectByteBuffer实例记作A，调用A的slice()或duplicate()或asReadOnlyBuffer()方法生成实例B，此时A和B内部的address是同一块地址，当A除了虚引用Cleaner外没有其他引用时，A的Cleaner触发钩子函数，如果此时实例B仍在使用，会导致内部的address失效，造成程序错误。</p><p>DirectByteBuffer的解决办法，是为slice()、duplicate()、asReadOnlyBuffer()方法专门提供一个构造器，将实例A初始化为实例B的att属性，如果B还在使用时，就会强引用A，那么就不会触发A的Cleaner的钩子函数。</p><!-- 内存特别小不适合，初始化时间长，不如用堆内 -->]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> io流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流(十四) HeapByteBuffer</title>
      <link href="2020/06/02/IO%E6%B5%81-HeapByteBuffer/"/>
      <url>2020/06/02/IO%E6%B5%81-HeapByteBuffer/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>HeapByteBuffer即<span class="p red">堆内字节缓冲区</span>，缓冲数据存储在父类ByteBuffer的hb属性中，内存空间的申请与释放完全由JVM负责，不用考虑内存回收的问题。在向IO设备写入数据时，需要将字节数组从JVM拷贝到Linux内核，而JVM除了CMS收集器，在GC时都有几率改变堆对象的内存地址，而内核对这种改变是无法感知的，会导致拷贝到Linux过程中出错。</p><p>因此HeapByteBuffer向IO设备写入数据时，会先将字节数组从JVM堆内拷贝到堆外，堆外就是Java进程的非JVM区域的用户空间，最后在从堆外拷贝到Linux内核空间。因此HeapByteBuffer相对于MappedByteBuffer、DirectByteBuffer来说，使用简单但效率低。</p><h2 id="2-构造与创建方式"><a href="#2-构造与创建方式" class="headerlink" title="2.构造与创建方式"></a>2.构造与创建方式</h2><h3 id="2-1-构造器"><a href="#2-1-构造器" class="headerlink" title="2.1 构造器"></a>2.1 构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HeapByteBuffer(<span class="keyword">int</span> cap, <span class="keyword">int</span> lim) &#123;</span><br><span class="line"><span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, lim, cap, <span class="keyword">new</span> <span class="keyword">byte</span>[cap], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HeapByteBuffer(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> off, <span class="keyword">int</span> len) &#123;</span><br><span class="line"><span class="keyword">super</span>(-<span class="number">1</span>, off, off + len, buf.length, buf, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">HeapByteBuffer</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap, <span class="keyword">int</span> off)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(mark, pos, lim, cap, buf, off);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HeapByteBuffer的构造器逻辑非常简单，就是初始化必要的属性值，与ByteBuffer、Buffer一样不对外提供访问权限，因此也无法通过继承的形式，重写部分方法的功能。</p><h3 id="2-2-创建方式"><a href="#2-2-创建方式" class="headerlink" title="2.2 创建方式"></a>2.2 创建方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">slice</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb, -<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">this</span>.remaining(), <span class="keyword">this</span>.remaining(), <span class="keyword">this</span>.position() + offset);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(hb, <span class="keyword">this</span>.markValue(), <span class="keyword">this</span>.position(), <span class="keyword">this</span>.limit(), <span class="keyword">this</span>.capacity(), offset);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBufferR(hb, <span class="keyword">this</span>.markValue(), <span class="keyword">this</span>.position(), <span class="keyword">this</span>.limit(), <span class="keyword">this</span>.capacity(), offset);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这三个方法都是对ByteBuffer抽象方法的重写，主要的作用之前也提过了，接下来写个demo看看这三个方法的创建效果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)<span class="number">7</span>);</span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)<span class="number">8</span>);</span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    byteBuffer.mark();</span><br><span class="line"></span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)<span class="number">10</span>);</span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)<span class="number">11</span>);</span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)<span class="number">12</span>);</span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">    ByteBuffer slice = byteBuffer.slice();</span><br><span class="line">    ByteBuffer duplicate = byteBuffer.duplicate();</span><br><span class="line">    ByteBuffer asReadOnlyBuffer = byteBuffer.asReadOnlyBuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原始缓冲区和新创建的三个缓冲区主要属性值:</p><table><thead><tr><th>缓冲区</th><th>position</th><th>limit</th><th>capacity</th><th>mark</th><th>offset</th><th>hb</th></tr></thead><tbody><tr><td>byteBuffer</td><td>7</td><td>10</td><td>10</td><td>3</td><td>0</td><td>[7, 8, 9, 10, 11, 12, 13, 0, 0, 0]</td></tr><tr><td>slice</td><td>0</td><td>3</td><td>3</td><td>0</td><td>7</td><td>[7, 8, 9, 10, 11, 12, 13, 0, 0, 0]</td></tr><tr><td>duplicate</td><td>7</td><td>10</td><td>10</td><td>3</td><td>0</td><td>[7, 8, 9, 10, 11, 12, 13, 0, 0, 0]</td></tr><tr><td>asReadOnlyBuffer</td><td>7</td><td>10</td><td>10</td><td>3</td><td>0</td><td>[7, 8, 9, 10, 11, 12, 13, 0, 0, 0]</td></tr></tbody></table><p>duplicate()方法与asReadOnlyBuffer()方法，对于关键的属性是完全复制，slice()方法则是将新建缓冲区的position强制设置为0，mark强制设置为-1，但offset设置为原缓冲区的position值。也就是说slice()方法创建出来的缓冲区，还是按照原缓冲区的位置继续往后读写。</p><p>slice翻译成中文是切/割的意思，所以slice()方法的本质，就是将原缓冲区的数据切出一部分建立新的缓冲区。虽然在最终效果上新的缓冲区的hb属性仍然包含全部数据，但由于核心属性的限制，新缓冲区对hb数组能读写的范围有限，只能是原缓冲区未读写部分，也就是将原缓冲区position以及往后的位置切了下来。</p><p class="p blue">以上面的代码为例，未读写部分即hb数组的7-9坐标，切出来的缓冲区的offset值为7，这个值没有任何地方可以修改，由于每次读写都是基于position + offset的位置，因此hb数组0-6坐标是没办法操作的。capacity值为3，也没办法进行修改，因此limit即使修改也只能改成1-3，数组可操作坐标就不会超出9。</p><h2 id="3-功能方法"><a href="#3-功能方法" class="headerlink" title="3.功能方法"></a>3.功能方法</h2><h3 id="3-1-读写方法"><a href="#3-1-读写方法" class="headerlink" title="3.1 读写方法"></a>3.1 读写方法</h3><figure class="highlight java"><figcaption><span>读取相关方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">// 真正的读写位置，需要加上offset</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> i + offset;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 读取一个元素，通过nextGetIndex()方法拿到的位置，还需要加上offset才是最终的操作位置</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> hb[ix(nextGetIndex())];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 和上面的一样，不过是指定数组坐标，不过posiiton也会递增i</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> hb[ix(checkIndex(i))];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 从hb的offset坐标开始，批量读取length个字节到dst数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       checkBounds(offset, length, dst.length);</span><br><span class="line">       <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">       System.arraycopy(hb, ix(position()), dst, offset, length);</span><br><span class="line">       position(position() + length);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>写入方法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 将src数组从offset坐标开始，往后length个元素写入缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    checkBounds(offset, length, src.length);</span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    System.arraycopy(src, offset, hb, ix(position()), length);</span><br><span class="line">    position(position() + length);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将src缓冲区的数据写入当前缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(ByteBuffer src)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是堆内缓冲区，直接复制数组</span></span><br><span class="line">    <span class="keyword">if</span> (src <span class="keyword">instanceof</span> HeapByteBuffer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (src == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        HeapByteBuffer sb = (HeapByteBuffer)src;</span><br><span class="line">        <span class="keyword">int</span> n = sb.remaining();</span><br><span class="line">        <span class="keyword">if</span> (n &gt; remaining())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">        System.arraycopy(sb.hb, sb.ix(sb.position()),</span><br><span class="line">                         hb, ix(position()), n);</span><br><span class="line">        sb.position(sb.position() + n);</span><br><span class="line">        position(position() + n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是堆外缓冲区，将当前缓冲区的数组作为参数，批量写入</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (src.isDirect()) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = src.remaining();</span><br><span class="line">        <span class="keyword">if</span> (n &gt; remaining())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">        src.get(hb, ix(position()), n);</span><br><span class="line">        position(position() + n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.put(src);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于批量读写的相关方法，ByteBuffer其实已经基于单个读写方法进行封装了，HeapByteBuffer为了提高效率进行了重写，将所有for循环形式的数组复制，改用System.arraycopy()方法代替，提高执行效率。剩下的就是一些读写时必要的校验、对position属性的维护等细节，基本没什么阅读难度。</p><h3 id="3-2-其他方法"><a href="#3-2-其他方法" class="headerlink" title="3.2 其他方法"></a>3.2 其他方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">compact</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从hb数组的第position + offset个元素开始，往后remaining()个元素</span></span><br><span class="line">    <span class="comment">// 复制到hb的offset～ remaining()坐标，不包括remaining()</span></span><br><span class="line">    System.arraycopy(hb, ix(position()), hb, ix(<span class="number">0</span>), remaining());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置下次读写位置</span></span><br><span class="line">    position(remaining());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置边界值</span></span><br><span class="line">    limit(capacity());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空标记坐标</span></span><br><span class="line">    discardMark();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的只有compact()方法，Buffer抽象类提供了3种清理缓冲区数据的方法，但Buffer并不知道缓冲数据的具体情况，因此清理的方式比较简单粗暴，直接将position重置为0，取消mark坐标等，虽然缓冲区的数据仍然存在，但是后面持续的写入，会将原有数据全部覆盖掉。</p><p>HeapByteBuffer类已经能确定缓冲数据存储的内存位置、单位，因此可以提供更<span class="p red">精准的清理功能</span>，这个功能就是compact()方法，下面是使用demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个容量为10的缓冲区</span></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入7个字节</span></span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)<span class="number">1</span>);</span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)<span class="number">2</span>);</span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)<span class="number">3</span>);</span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)<span class="number">4</span>);</span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)<span class="number">5</span>);</span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)<span class="number">6</span>);</span><br><span class="line">    byteBuffer.put((<span class="keyword">byte</span>)<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先将position重置为0</span></span><br><span class="line">    byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取2次，保证缓冲区即存在已读数据、也存在未读数据</span></span><br><span class="line">    byteBuffer.get();</span><br><span class="line">    byteBuffer.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理缓冲区</span></span><br><span class="line">    byteBuffer.compact();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印缓冲数据情况</span></span><br><span class="line">    System.out.println( Arrays.toString(byteBuffer.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行到每个步骤时，缓冲区对象的内部属性变化:<br><img src="/2020/06/02/IO%E6%B5%81-HeapByteBuffer/compact.png" class="lazyload" data-srcset="/2020/06/02/IO%E6%B5%81-HeapByteBuffer/compact.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p class="p red">图中可以看出，comapct()方法只是将原position位置往后的多个元素，挪到数组的开始位置，其他位置的元素不发生任何变化。因此无论是comapct()方法，还是Buffer提供的clear()、flip()、rewind()方法，都是在读完需要写入的时候使用。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> io流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流(十三) ByteBuffer</title>
      <link href="2020/05/31/IO%E6%B5%81-ByteBuffer/"/>
      <url>2020/05/31/IO%E6%B5%81-ByteBuffer/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>上一章提到Buffer作为抽象类，仅仅定义了数据的容量管理，以及对读写位置的部分规则约定，并且提供了除boolean类型外，剩余七种基本数据类型的读写实现类，这七种实现类提供的API，除了读写的单位不同，其他地方几乎一样。</p><p>Buffer的所有子类中，其中最特别的就是ByteBuffer，因为其他基本数据类型都可以转化为byte，因此ByteBuffer除了提供字节类型的读写操作外，还提供了其他六种基本数据类型的重载方法，所以学习缓冲区，只要掌握ByteBuffer以及子类即可。</p><h2 id="2-Buffer抽象父类"><a href="#2-Buffer抽象父类" class="headerlink" title="2.Buffer抽象父类"></a>2.Buffer抽象父类</h2><h3 id="2-1-成员变量与构造器"><a href="#2-1-成员变量与构造器" class="headerlink" title="2.1 成员变量与构造器"></a>2.1 成员变量与构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> address;</span><br><span class="line"></span><br><span class="line">    Buffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cap &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Negative capacity: &quot;</span> + cap);</span><br><span class="line">        <span class="keyword">this</span>.capacity = cap;</span><br><span class="line">        limit(lim);</span><br><span class="line">        position(pos);</span><br><span class="line">        <span class="keyword">if</span> (mark &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mark &gt; pos)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;mark &gt; position: (&quot;</span></span><br><span class="line">                                                   + mark + <span class="string">&quot; &gt; &quot;</span> + pos + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.mark = mark;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果手动设置的下次读写位置，不能超出边界值</span></span><br><span class="line">        <span class="keyword">if</span> ((newPosition &gt; limit) || (newPosition &lt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        position = newPosition;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动设置的下次读写位置，取消标记</span></span><br><span class="line">        <span class="keyword">if</span> (mark &gt; position) mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界值不能溢出最大容量</span></span><br><span class="line">        <span class="keyword">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        limit = newLimit;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果下个读写位置已超出limit，强制设置为limit</span></span><br><span class="line">        <span class="keyword">if</span> (position &gt; limit) position = limit;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果标记位置已超出边界，取消标记</span></span><br><span class="line">        <span class="keyword">if</span> (mark &gt; limit) mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mark = position;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = mark;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有标记或因为上面两个方法被取消，不允许回归标记位</span></span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">        position = m;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这啥？直接把缓冲区搞废掉？ </span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">truncate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mark = -<span class="number">1</span>;</span><br><span class="line">        position = <span class="number">0</span>;</span><br><span class="line">        limit = <span class="number">0</span>;</span><br><span class="line">        capacity = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消标记位置</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">discardMark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mark = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color:red">capacity(容量)</span>，缓冲区能够容纳的数据元素的最大数量。这个变量在创建一个Buffer实现类时指定，并且在创建完成后永远不能被修改。当缓冲区被填满后，需要手动调用API进行清理，后续才能继续往缓冲区写数据。</p><p><span style="color:red">limit(边界)</span>，缓冲区最多可读或写的元素数量，由于元素坐标是从0开始，limit也可以解释为第一个不能被读或写的位置。例如创建缓冲区时指定capacity=1024，那么limit默认值也是1024，可写入的数组坐标是0～1023，当limit值被设置为512时，可写入的数组坐标变为0～511，之后的数组坐标都无法进行读写，就是说读写的坐标必须小于limit值，否则报错。</p><p><span style="color:red">position(位置)</span>，下一个要读取或写入的元素坐标值。每次调用put()或子类的get()方法，都会自动的计算更新position值，因为position是从0开始的，因此最大值为capacity-1。</p><p><span style="color:red">mark(标记)</span>，标记数组中的某个坐标位置。具体作用和InputStream实现类一样，使用mark()方法配合reset()方法覆盖position值，实现对系统资源的重复读取。</p><p><span style="color:red">address(堆外地址)</span>，如果Buffer的最底层实现类为堆外内存，此属性为Buffer实现类在堆外申请的内存空间地址，所有的读写等操作都是针对这个地址对应的内存数据。</p><h3 id="2-2-抽象方法"><a href="#2-2-抽象方法" class="headerlink" title="2.2 抽象方法"></a>2.2 抽象方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">array</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><span style="color:red">isReadOnly()抽象方法，缓冲区是否为只读状态。</span>常用的HeapByteBuffer、DirectByteBuffer类都是读写缓冲区，JDK也为我们提供了对应的只读类，比如HeapByteBuffer对应的HeapByteBufferR，结尾的R就是只读的意思，HeapByteBufferR类重写此方法固定返回false，并且调用put相关方法都会抛出异常。</p><p><span style="color:red">hasArray()抽象方法，是否由可访问数组支持。</span>如果子类是HeapByteBuffer这种基于数组维护缓冲数据的，并且不是只读状态，重写时返回true。像DirectByteBuffer等类是将缓冲数据放在堆外，内存地址通过代码进行管理，没有数组这个概念，则重写时需要返回false，代表不支持数组相关操作。</p><p><span style="color:red">array()抽象方法，返回缓冲区的数组对象。</span>如果子类在重写hasArray()方法时，将返回值定义为true，重写此方法一定会返回一个数组对象，如果重写的hasArray()方法返回false，则需要重写此方法时抛出异常。因此通过多态形式操作缓冲区对象，调用此方法前一定要调用hasArray()进行安全校验。</p><p><span style="color:red">arrayOffset()抽象方法，返回缓冲区数组内第一个元素的下坐标。</span>这个方法和array()方法类似，都是获取缓冲数组的相关信息，每次读取缓冲区数据时，读取的坐标为position + arrayOffset()。</p><h3 id="2-3-读写信息相关方法"><a href="#2-3-读写信息相关方法" class="headerlink" title="2.3 读写信息相关方法"></a>2.3 读写信息相关方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">remaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> limit - position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position &lt; limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color:red">flip()方法</span>，将Buffer从写模式切换到读模式。首先limit被设置为当前position的值，然后将position设置为0，这就意味着接下来的读取坐标范围，不会超出调用此方法前写入的最大坐标。因此每次切换读模式，一定要手动将读完的数据清除，否则下次position重置为0后，数据会重复读取。既然读完会被清理掉，那么将mark标记作废，也就理所当然了。</p><p><span style="color:red">rewind()方法</span>，也是将Buffer从写模式切换到读模式。比flip()方法少了一个步骤，就是没有重置limit的值，这意味着接下来能读取的坐标范围，取决于之前设置的limit值，有可能接下里的读取操作无法读完之前写入的数据，也有可能会读到没有写入数据的位置(返回基础数据类型的默认值)。</p><p><span style="color:red">clear()方法</span>，也是将Buffer从写模式切换到读模式。与前俩个方法相比，此方法直接将可读的坐标范围开到最大，即使某些坐标没有写入元素也会被读取，返回对应实现类的默认值，例如ByteBuffer子类未写入的坐标默认值是0。 </p><p><span style="color:red">remaining()方法</span>，返回目前还有多少个位置可以提供读写，由于可读写的位置受limit参数限制，所以还有多少个位置能提供读写，需要用limit减去已读写的数量。</p><p><span style="color:red">hasRemaining()方法</span>，是否还有可提供读写的位置，由于可读写的位置受limit参数限制，所以是否能继续读写，是根据位置是否到达limit决定。</p><h3 id="2-4-读写操作相关方法"><a href="#2-4-读写操作相关方法" class="headerlink" title="2.4 读写操作相关方法"></a>2.4 读写操作相关方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 获取下次读取的位置值，如果超出边界值则抛出异常，方法返回后position递增1</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下次读取的位置值，跳过nb个元素，如果超出边界值则抛出异常，position递增nb</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextGetIndex</span><span class="params">(<span class="keyword">int</span> nb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (limit - position &lt; nb)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line">    <span class="keyword">int</span> p = position;</span><br><span class="line">    position += nb;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下次写入的位置值，如果超出边界值则抛出异常，方法返回后position递增1</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下次写入的位置值，跳过nb个元素，如果超出边界值则抛出异常，position递增nb</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">(<span class="keyword">int</span> nb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (limit - position &lt; nb)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="keyword">int</span> p = position;</span><br><span class="line">    position += nb;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数i为读写的位置值，如果小于0或者超出边界，则超出正常范围，抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">0</span>) || (i &gt;= limit))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数i为读写的位置值，nb为跳过的元素数量，如果小于0或者超出边界，则超出正常范围，抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> nb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">0</span>) || (nb &gt; limit - i))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果将长度为size的数组，从off坐标开始，往后len个元素写入缓冲区，验证是否符合范围要求</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkBounds</span><span class="params">(<span class="keyword">int</span> off, <span class="keyword">int</span> len, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((off | len | (off + len) | (size - (off + len))) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class="p red">Buffer作为一个抽象类，无法确定读写的数据类型、堆内还是堆外存储数据，因此读写相关的方法都是辅助性质的，仅支持读写操作时位置的维护与校验工作。</p><h3 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h3><p>Buffer抽象类作为缓冲区的顶层抽象类，没有提供任何关于读写操作的方法，也没有定义任何存储缓冲数据的数组，仅仅定义了堆外缓冲区实现类会用到的内存地址，这主要是因为读写数据的类型有很多，不同的数据类型对应的方法参数不同，Buffer无法进行抽象。</p><p>Buffer在NIO设计中的职责，是将数据类型以外的操作规范进行定义，并让所有子类继承并遵循这套规范，比如定义缓冲区的大小并强制不能修改、每次读写前对位置的校验与新位置计算、读取的边界限制、数据元素重读等。</p><h2 id="3-ByteBuffer抽象类"><a href="#3-ByteBuffer抽象类" class="headerlink" title="3.ByteBuffer抽象类"></a>3.ByteBuffer抽象类</h2><h3 id="3-1-成员变量与创建方式"><a href="#3-1-成员变量与创建方式" class="headerlink" title="3.1 成员变量与创建方式"></a>3.1 成员变量与创建方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span> <span class="keyword">extends</span> <span class="title">Buffer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] hb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isReadOnly;</span><br><span class="line"></span><br><span class="line">    ByteBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap, <span class="keyword">byte</span>[] hb, <span class="keyword">int</span> offset)&#123;</span><br><span class="line">        <span class="keyword">super</span>(mark, pos, lim, cap);</span><br><span class="line">        <span class="keyword">this</span>.hb = hb;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ByteBuffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123;</span><br><span class="line">        <span class="keyword">this</span>(mark, pos, lim, cap, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(array, offset, length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException x) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> wrap(array, <span class="number">0</span>, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color:red">成员变量hb，缓冲区数组对象。</span>只有HeapByteBuffer才会用到，堆外缓冲区的数据不在JVM内存中，而是Buffer类的address变量指向的堆外内存地址。作为HeapByteBuffer<br>最核心的属性，所有的读写或其他操作，都是围绕此数组进行实现。</p><p><span style="color:red">成员变量offset，数组第一个读写元素的下坐标。</span>ByteBuffer的所有子类每次读写数据时，真正读写的位置由position + offset决定，offset只有在使用slice()新建缓冲区时才有可能变成非0值。</p><p><span style="color:red">成员变量isReadOnly，缓冲区是否为只读状态。</span>此属性并没有被final修饰，但没有对外提供任何修改的方法，因此也是在构造器的初始化中决定的。</p><p><span style="color:red">allocateDirect()静态方法，创建一个DirectByteBuffer缓冲区。</span>创建的堆外缓冲区除了容量，其他的成员变量均使用默认值。</p><p><span style="color:red">allocate()静态方法，创建一个HeapByteBuffer缓冲区。</span>创建的堆外缓冲区除了容量，其他的成员变量均使用默认值。</p><p><span style="color:red">wrap()静态方法，创建一个HeapByteBuffer缓冲区。</span>将数组从offset位置开始，往后的length个元素作为HeapByteBuffer的缓冲区数组，由于参数有可能造成下坐标越界，因此方法内部会捕获异常。</p><h3 id="3-2-抽象方法"><a href="#3-2-抽象方法" class="headerlink" title="3.2 抽象方法"></a>3.2 抽象方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">slice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">duplicate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">asReadOnlyBuffer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">compact</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isDirect</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><span style="color:red">slice()抽象方法，基于当前缓冲区新建一个缓冲区。</span>新缓冲区的缓冲数据为此缓冲区的数据内容，也就是说俩个缓冲区指向一个内存地址读写数据，一个缓冲区写入数据，在另一个缓冲区中立刻生效，但俩个缓冲区的position、limit、mark相互独立，并且会重置这几个属性的值，由于堆内堆外对内存地址的维护有差异，需要子类去重写。</p><p><span style="color:red">duplicate()抽象方法，基于当前缓冲区复制一个缓冲区。</span>复制出来的缓冲区仍然和原缓冲区共享数据，position、limit、mark、capacity属性完全复制，由于堆内堆外对内存地址的维护有差异，需要子类去重写。</p><p><span style="color:red">asReadOnlyBuffer()抽象方法，基于当前缓冲区复制一个只读缓冲区。</span>HeapByteBuffer、DirectByteBuffer等子类都会衍生出一个名称R结尾的子类(例如HeapByteBufferR)，R结尾的子类就是父类的只读类，将父类关于写入的方法统统重写抛出异常，因此重写asReadOnlyBuffer()方法，就是创建当前缓冲区对应的R结尾名称类，各种属性全部复制之前的。</p><p><span style="color:red">get()与put()相关抽象方法，读写缓冲区数据。</span>ByteBuffer只是确定了读写操作以字节为单位进行，但是具体写到堆内还是堆外无法确定，因此设计为抽象类供子类重写。</p><p><span style="color:red">compact()抽象方法，清理已读写的缓冲数据。</span>如果已读写的数据后续不会用到，可以使用此方法可以将position往前位置的数据清理掉，清理完成后position值将重置为0。仍然是因为无法确定清理的是堆内还是堆外数据，因此设计为抽象类供子类重写。</p><p><span style="color:red">isDirect()抽象方法，是否为直接缓冲区。</span>true则表示直接缓冲区，数据存储在堆外，false则表示非直接缓冲区，数据存储在JVM堆中，需要子类重写。</p><h3 id="3-3-读写相关方法"><a href="#3-3-读写相关方法" class="headerlink" title="3.3 读写相关方法"></a>3.3 读写相关方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Buffer的静态方法校验坐标</span></span><br><span class="line">    checkBounds(offset, length, dst.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果剩余未读的元素数量，少于需要读取的元素数量，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferUnderflowException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从缓冲区的offset坐标开始，读取length个字节到dst数组</span></span><br><span class="line">    <span class="keyword">int</span> end = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        dst[i] = get();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓冲区的0坐标开始，读取dst.length个字节到dst数组</span></span><br><span class="line">    <span class="keyword">return</span> get(dst, <span class="number">0</span>, dst.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(ByteBuffer src)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能自己向自己写入数据</span></span><br><span class="line">    <span class="keyword">if</span> (src == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 只读状态不允许写入数据</span></span><br><span class="line">    <span class="keyword">if</span> (isReadOnly())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="comment">// 即将要写入的字节数量</span></span><br><span class="line">    <span class="keyword">int</span> n = src.remaining();</span><br><span class="line">    <span class="comment">// 不能大于当前元素可以写入的字节数量</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">    <span class="comment">// 逐个写入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        put(src.get());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Buffer的静态方法校验坐标</span></span><br><span class="line">    checkBounds(offset, length, src.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即将写入的字节数量，不能超出当前缓冲区可以写入的数量</span></span><br><span class="line">    <span class="keyword">if</span> (length &gt; remaining())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从src数组的offset坐标开始，往后length个元素写入当前缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> end = offset + length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">        <span class="keyword">this</span>.put(src[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将src数组的所有元素写入当前缓冲区</span></span><br><span class="line">    <span class="keyword">return</span> put(src, <span class="number">0</span>, src.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class="p red">每种类型的缓冲区，都有批量读写的场景，所有的批量读写都是基于单个元素读写实现，因此ByteBuffer对单个读写方法进行封装，实现对批量读写的支持，具体如何单个读写的，让子类自己重写实现，减少代码的冗余，有点类似于设计模式中的模板模式。</p><h3 id="3-4-array相关方法"><a href="#3-4-array相关方法" class="headerlink" title="3.4 array相关方法"></a>3.4 array相关方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (hb != <span class="keyword">null</span>) &amp;&amp; !isReadOnly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] array() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hb == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">return</span> hb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">arrayOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hb == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    <span class="keyword">if</span> (isReadOnly)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReadOnlyBufferException();</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class="p red">如果成员变量hb不等于null，说明缓冲区是基于堆内数组建立的，但仅有这个条件，还不能对外提供数组信息的访问，因为在代码中拿到数组的引用，就意味着可以随意修改内部坐标值，所以还需要保证缓冲区不是只读状态(isReadOnly=false)。</p><h3 id="3-5-其他方法"><a href="#3-5-其他方法" class="headerlink" title="3.5 其他方法"></a>3.5 其他方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(getClass().getName());</span><br><span class="line">    sb.append(<span class="string">&quot;[pos=&quot;</span>);</span><br><span class="line">    sb.append(position());</span><br><span class="line">    sb.append(<span class="string">&quot; lim=&quot;</span>);</span><br><span class="line">    sb.append(limit());</span><br><span class="line">    sb.append(<span class="string">&quot; cap=&quot;</span>);</span><br><span class="line">    sb.append(capacity());</span><br><span class="line">    sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p = position();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = limit() - <span class="number">1</span>; i &gt;= p; i--)</span><br><span class="line">        h = <span class="number">31</span> * h + (<span class="keyword">int</span>)get(i);</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object ob)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == ob)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(ob <span class="keyword">instanceof</span> ByteBuffer))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    ByteBuffer that = (ByteBuffer)ob;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.remaining() != that.remaining())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="keyword">this</span>.position();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.limit() - <span class="number">1</span>, j = that.limit() - <span class="number">1</span>; i &gt;= p; i--, j--)</span><br><span class="line">        <span class="keyword">if</span> (!equals(<span class="keyword">this</span>.get(i), that.get(j)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ByteBuffer that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">this</span>.position() + Math.min(<span class="keyword">this</span>.remaining(), that.remaining());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.position(), j = that.position(); i &lt; n; i++, j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = compare(<span class="keyword">this</span>.get(i), that.get(j));</span><br><span class="line">        <span class="keyword">if</span> (cmp != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> cmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.remaining() - that.remaining();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h3><p>ByteBuffer定义了toString()、hashCode()、equals()、compareTo()等常规方法的具体实现外，最重要的是定义了一系列的读写抽象方法，这主要是因为缓冲区的数据可能在堆内，也可以在堆外，ByteBuffer无法同时实现，只能对其抽象让子类实现。</p><p>ByteBuffer在NIO设计中的职责，是将byte相关的读写方法进行抽象，如果是在堆内存储数据，则所有的读写方法都围绕成员变量hb操作，如果是在堆外存储数据，则所有的读写方法都围绕成员变量address对应的内存地址操作。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> io流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流(十二) Java中的NIO体系</title>
      <link href="2020/05/29/IO%E6%B5%81-Java%E4%B8%AD%E7%9A%84NIO%E4%BD%93%E7%B3%BB/"/>
      <url>2020/05/29/IO%E6%B5%81-Java%E4%B8%AD%E7%9A%84NIO%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>Java的NIO是指JDK1.4版本开始，提供全新的IO处理方式的类集合，这些类被放在Java.nio包下，NIO是<span class="p red">Non-Blocking—IO</span>的简称，也就是<span class="p red">非阻塞IO</span>。相对于java.io包下传统IO类的清一色同步阻塞的特点，NIO支持采用非阻塞IO的方式处理问题，并且内部还细分为同步非阻塞(NIO)、异步非阻塞(AIO)。</p><p>还有些文章将NIO理解为<span class="p red">New IO的简称</span>，相比于Java.io包下的传统IO，NIO除了对原有功能进行改进外，还提供了很多更高级的功能，因此这么说是合理的。</p><h2 id="2-核心类"><a href="#2-核心类" class="headerlink" title="2.核心类"></a>2.核心类</h2><!-- Java的非阻塞IO流(NIO)是面向缓冲区的、基于通道的IO方式，核心由Buffer(缓冲区)、Channel(通道)、Selector(选择器)三大类组成。Channel是IO设备的连接对象，类似传统IO的流对象，所有读写代码都是对Buffer的调用，数据可以从Channel读到Buffer中，也可以从Buffer写到Channel中，Selector则用于IO多路复用模型中的事件监听。![图片](./IO流-Java中的NIO体系/NIO三大组件关系.png) --><h3 id="2-1-Buffer-缓冲区"><a href="#2-1-Buffer-缓冲区" class="headerlink" title="2.1 Buffer(缓冲区)"></a>2.1 Buffer(缓冲区)</h3><p>NIO之所以称为面向缓冲的IO方式，是因为开发者无法直接操作Channel对象，Buffer的子类都提供了很多读写相关的方法，程序中对Channel涉及的读写操作，都是通过调用Buffer的API间接操作。而Buffer的本质就是申请一块既可以读也可以写的内存空间，用于Java进程和IO设备发生读写时，与内核之间的数据双向拷贝。</p><p>更直接的说，<span class="p red">就是单个Buffer对象既可以读数据，也可以写数据</span>。这也是NIO与传统IO的一个明显的区别，传统IO读和写必须创建俩个不同的Stream，而NIO只需要创建一个Channel搭配Buffer即可:</p><p><img src="/2020/05/29/IO%E6%B5%81-Java%E4%B8%AD%E7%9A%84NIO%E4%BD%93%E7%B3%BB/Buffer%E4%B8%8EChannel%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE.png" class="lazyload" data-srcset="/2020/05/29/IO%E6%B5%81-Java%E4%B8%AD%E7%9A%84NIO%E4%BD%93%E7%B3%BB/Buffer%E4%B8%8EChannel%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><!-- ```Java 核心成员变量、重点方法的源码public abstract class Buffer {    private int mark = -1;    private int position = 0;    private int limit;    private int capacity;    public final Buffer flip() {        limit = position;        position = 0;        mark = -1;        return this;    }    public final Buffer rewind() {        position = 0;        mark = -1;        return this;    }    public final Buffer clear() {        position = 0;        limit = capacity;        mark = -1;        return this;    }}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;span style&#x3D;&quot;color:red&quot;&gt;capacity(容量)&lt;&#x2F;span&gt;，缓冲区能够容纳的数据元素的最大数量。这个变量在创建一个Buffer实现类时指定，并且在创建完成后永远不能被修改。当缓冲区被填满后，需要手动调用API进行清理，后续才能继续往缓冲区写数据。</span><br><span class="line"></span><br><span class="line">&lt;span style&#x3D;&quot;color:red&quot;&gt;limit(上界)&lt;&#x2F;span&gt;，缓冲区的第一个不能被读或写的位置。例如创建缓冲区时指定capacity&#x3D;1024，那么limit默认值也是1024，可写入的数组坐标是0～1023，当limit值被设置为512时，可写入的数组坐标变为0～511，之后的数组坐标都无法进行读写，就是说读写的坐标必须小于limit值，否则报错。</span><br><span class="line"></span><br><span class="line">&lt;span style&#x3D;&quot;color:red&quot;&gt;position(位置)&lt;&#x2F;span&gt;，下一个要读取或写入的元素坐标值。每次调用put()或子类的get()方法，都会自动的计算更新position值，因为position是从0开始的，因此最大值为capacity-1。</span><br><span class="line"></span><br><span class="line">&lt;span style&#x3D;&quot;color:red&quot;&gt;mark(标记)&lt;&#x2F;span&gt;，标记数组中的某个坐标位置。具体作用和InputStream实现类一样，配合reset()方法覆盖position值，实现对系统资源的重复读取。</span><br><span class="line"></span><br><span class="line">&lt;span style&#x3D;&quot;color:red&quot;&gt;flip()方法&lt;&#x2F;span&gt;，将Buffer从写模式切换到读模式。首先limit被设置为当前position的值，然后将position设置为0，这就意味着接下来的读取坐标范围，不会超出调用此方法前写入的最大坐标。因此每次切换读模式，一定要手动将读完的数据清除，否则下次position重置为0后，数据会重复读取。既然读完会被清理掉，那么将mark标记作废，也就理所当然了。</span><br><span class="line"></span><br><span class="line">&lt;span style&#x3D;&quot;color:red&quot;&gt;rewind()方法&lt;&#x2F;span&gt;，也是将Buffer从写模式切换到读模式。比flip()方法少了一个步骤，就是没有重置limit的值，这意味着接下来能读取的坐标范围，取决于之前设置的limit值，好像用处不大。</span><br><span class="line"></span><br><span class="line">&lt;span style&#x3D;&quot;color:red&quot;&gt;clear()方法&lt;&#x2F;span&gt;，也是将Buffer从写模式切换到读模式。与前俩个方法相比，此方法直接将可读的坐标范围开到最大，即使某些坐标没有写入元素也会被读取，返回对应实现类的默认值，例如ByteBuffer子类未写入的坐标默认值是0。 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Buffer抽象类除了上述的内容外，还包括mark()、reset()方法支持的重复读取功能，每次读写需要的坐标边界校验等，就忽略不写了。从源码中可看出Buffer并没有提供具体的、关于读写的API，而是定义了一套读写操作需要注意的规则，真正的读写行为由子类自己定义实现， --&gt;</span><br><span class="line"></span><br><span class="line">Buffer的主要子类关系图:</span><br><span class="line">![图片](.&#x2F;IO流-Java中的NIO体系&#x2F;temp.jpeg)</span><br><span class="line"></span><br><span class="line">上图可以看出，NIO中提供了七种基本数据类型(布尔除外)的读写实现，然而Buffer的直接子类仍然是抽象类，所有关于读写的方法均为抽象方法，这些抽象类除了参数的引用类型和返回值外，其他地方几乎一致。每个直接子类都会衍生出&#123;%span red, 堆内缓冲%&#125;、&#123;%span red, 直接缓冲%&#125;、&#123;%span red, 内存映射缓冲%&#125;三种主要的具体实现类(其他的忽略不写了)，三种缓冲类型的特点如下:</span><br><span class="line"></span><br><span class="line">| 缓冲类型 | 申请内存的位置 | 特点 |</span><br><span class="line">|  ----  | ----  | ----  |</span><br><span class="line">| 堆内缓冲 | JVM堆 | 是默认的、最常用的使用类型 |</span><br><span class="line">| 直接缓冲 | 进程在JVM堆外的虚拟地址空间 | 避免在JVM堆和Native堆中来回复制数据 |</span><br><span class="line">| 内存映射缓冲 | 进程在JVM堆外的虚拟地址空间(与真实地址映射) | 够避免数据在内核态和用户态来回复制数据 |</span><br><span class="line"></span><br><span class="line">### 2.2 Channel(通道)</span><br><span class="line">Channel即通道，类似传统IO的Stream对象，内部包含一个打开的文件描述符，可以通过调用API完成相关的IO操作。不同点在于流对象是单向的，也就是说单个流对象要么只能从设备读数据(inputStream)，要么只能往设备写数据(OutputStream)，而Channel对象是双向的，借助Buffer类，单个对象既可以读也可以写。</span><br><span class="line"></span><br><span class="line">Channel接口非常简单，仅提供了关于连接设备的手动关闭、是否打开、是否关闭方法，这主要是因为具体的连接目标可能是硬盘、可能是网卡，实现类的差异过大，无法进行抽象，常用的Channel实现类如下:</span><br><span class="line"></span><br><span class="line">![图片](.&#x2F;IO流-Java中的NIO体系&#x2F;temp.jpeg)</span><br><span class="line"></span><br><span class="line">&lt;!-- Channel接口最常用的四个实现类:</span><br><span class="line">- FileChannel: 与文件建立读写通道</span><br><span class="line">- SocketChannel: 通过TCP网络协议，建立读写通道(客户端)</span><br><span class="line">- ServerSocketChannel: 通过TCP网络协议，建立读写通道(服务端)</span><br><span class="line">- DatagramChannel: 通过UDP网络协议，建立读写通道 --&gt;</span><br><span class="line"></span><br><span class="line">### 2.3 Selector(选择器)</span><br><span class="line">Selector即选择器，只有在多路复用IO模型中才会用到，主要作用是监听Java进程中，所有Socket描述符的IO事件，减少网络IO处理过程中的CPU开销，本质上是解决服务端C10K问题。常用的实现类:</span><br><span class="line"></span><br><span class="line">![图片](.&#x2F;IO流-Java中的NIO体系&#x2F;temp.jpeg)</span><br><span class="line"></span><br><span class="line">## 3.同步非阻塞IO</span><br><span class="line"></span><br><span class="line">同步非阻塞IO的特点是&#123;%span red, 同步%&#125;与&#123;%span red, 非阻塞%&#125;。一般应用程序会通过某种轮询的方式，请求内核获取某个IO设备是否可读，内核对于这个请求总会立刻响应。当内核发现IO设备可读时，会将数据从硬件设备拷贝到内核内存，也就是我们常说的&#123;%span red, 准备阶段%&#125;，这期间返回给应用程序的结果仍然是不可读。</span><br><span class="line"></span><br><span class="line">直到内核将数据从硬件设备拷贝完毕后，应用程序轮询获得的结果就是可读，此时应用程序需要将数据从内核态拷贝到用户态，Java代码会在拷贝过程中阻塞，直到拷贝完毕。</span><br><span class="line"></span><br><span class="line">因此Java中非阻塞IO的特点是，前半阶段非阻塞，后半阶段阻塞，只要不是完全非阻塞，那就只能视为同步，而不是异步，所以这些类称为同步非阻塞IO。如图:</span><br><span class="line">![图片](.&#x2F;IO流-Java中的NIO体系&#x2F;同步非阻塞IO工作过程.png)</span><br><span class="line"></span><br><span class="line">### 3.1 普通非阻塞IO(网络)</span><br><span class="line"></span><br><span class="line">普通非阻塞IO通常适用于客户端连接数量较少、数据传输较为频繁的场景。下面用Java代码简单实现一个服务端基于Linux的非阻塞IO模型，处理多个客户端的请求:</span><br><span class="line">&#96;&#96;&#96;Java 服务端代码</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 1.创建服务端socket通道</span><br><span class="line">        ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2.切换非阻塞模式</span><br><span class="line">        serverSocketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3.给创建的服务端socket通道，申请一个端口</span><br><span class="line">        serverSocketChannel.bind(new InetSocketAddress(9898));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4.进入无脑循环</span><br><span class="line">        while(true)&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 检查有没有来自客户端的连接</span><br><span class="line">            SocketChannel clientChannel &#x3D; serverSocketChannel.accept();</span><br><span class="line">            if(clientChannel &#x3D;&#x3D; null)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 获取客户端的ip、端口</span><br><span class="line">            SocketAddress remoteAddress &#x3D; clientChannel.getRemoteAddress();</span><br><span class="line">            System.out.println(&quot;获取到客户端的连接请求:&quot; + remoteAddress.toString());</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果连接成功，分配一个线程，监听客户端发送的数据</span><br><span class="line">            if(clientChannel.finishConnect())&#123;</span><br><span class="line">                distributeMonitor(clientChannel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void distributeMonitor(SocketChannel socketChannel) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            ByteBuffer buf &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line"></span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        int len &#x3D; socketChannel.read(buf);</span><br><span class="line">                        if(len &#x3D;&#x3D; -1)&#123;</span><br><span class="line">                            socketChannel.close();</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        buf.flip();</span><br><span class="line">                        System.out.println(&quot;获取到客户端的请求，参数:&quot; + new String(buf.array(), 0, len));</span><br><span class="line"></span><br><span class="line">                        buf.clear();</span><br><span class="line">                        socketChannel.write(Charset.forName(&quot;UTF-8&quot;).encode(&quot;response data...&quot;));</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        System.out.println(&quot;与客户端连接断开...&quot;);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>客户端代码(可以启动多个)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.本地创建一个网络通道</span></span><br><span class="line">    SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.切换非阻塞模式</span></span><br><span class="line">    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.指定服务端的地址和端口，尝试建立连接</span></span><br><span class="line">    socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9898</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.如果连接成功，</span></span><br><span class="line">    <span class="keyword">if</span>(socketChannel.finishConnect())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟发送数据</span></span><br><span class="line">        send(socketChannel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配一个线程，监听服务端返回的数据</span></span><br><span class="line">        distributeMonitor(socketChannel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止main方法执行完，上面创建的socketChannel被回收，导致服务端连接报错</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(SocketChannel socketChannel)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String message = <span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次请求...&quot;</span>;</span><br><span class="line">                    ByteBuffer byteBuffer = ByteBuffer.wrap(message.getBytes());</span><br><span class="line">                    socketChannel.write(byteBuffer);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;与服务端连接断开...&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">distributeMonitor</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> len = socketChannel.read(buf);</span><br><span class="line">                    <span class="keyword">if</span>(len == -<span class="number">1</span>)&#123;</span><br><span class="line">                        socketChannel.close();</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    buf.flip();</span><br><span class="line">                    System.out.println(<span class="string">&quot;获取到客户端的请求，参数:&quot;</span> + <span class="keyword">new</span> String(buf.array(), <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">                    buf.clear();</span><br><span class="line">                    socketChannel.write(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).encode(<span class="string">&quot;response data...&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;与服务端连接断开...&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><p><strong>服务端的控制台打印:</strong><br>获取到客户端的连接请求:/127.0.0.1:51292<br>获取到客户端的请求，参数:第1次请求…<br>获取到客户端的请求，参数:第2次请求…<br>获取到客户端的请求，参数:第3次请求…</p><p><strong>客户端的控制台打印:</strong><br>接收到服务端响应结果:response data…<br>接收到服务端响应结果:response data…<br>接收到服务端响应结果:response data…</p><p class='p red'>每个客户端与服务端成功建立连接后，服务端在Linux操作系统中都会生成一个新的socket描述符，用于维护与客户端的TCP通道的数据传输，由于无法得知每个客户端会在什么时候发送请求，因此服务端需要为每个socket描述符分配一个线程，不停的进行轮询检查，是否有可读的数据。</p><p class='p red'>当大量的客户端请求服务端建立连接，服务端所在服务器就需要创建大量的线程进行轮询检查，对CPU的压力非常大。如果这些客户端发送网络请求的频率不高，就意味着这么多线程一直在空耗CPU资源，即使CPU能扛住压力，也会造成大量的资源浪费。</p><h3 id="3-2-多路复用IO-网络"><a href="#3-2-多路复用IO-网络" class="headerlink" title="3.2 多路复用IO(网络)"></a>3.2 多路复用IO(网络)</h3><p>多路复用IO在NIO技术中应用最广泛，例如在线聊天、RocketMQ等场景的服务端，这些场景的特点是与客户端建立的都是TCP连接，虽然连接数多但网络请求的频率不是很高。下面用Java代码简单实现一个服务端基于Linux的多路复用IO模型，处理多个客户端的请求:</p><figure class="highlight java"><figcaption><span>服务端代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.创建服务端socket通道</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.切换非阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.给创建的服务端socket通道，申请一个端口</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.创建选择器，用于检测每个客户端发过来的网络请求</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.将通道注册到选择器上，并指定监听事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.进入无脑循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.检查监听的事件</span></span><br><span class="line">            <span class="keyword">int</span> selectCount = selector.select();</span><br><span class="line">            <span class="keyword">if</span> (selectCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8.获取监听到的事件</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9.获取迭代器并循环</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 10.获取就绪事件key</span></span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 11.从迭代器中删除此事件，防止后续重复处理</span></span><br><span class="line">                iterator.remove();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 12.如果是来自客户端的连接事件</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                    acceptHandler(serverSocketChannel, selector);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 13.如果是可读事件</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                    readHandler(selectionKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptHandler</span><span class="params">(ServerSocketChannel serverSocketChannel,Selector selector)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.接收客户端的连接请求，返回值SocketChannel是与此客户端的网络通道socket描述符</span></span><br><span class="line">        SocketChannel acceptSocketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.设置为非阻塞</span></span><br><span class="line">        acceptSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.与客户端连接成功，后续就可能收到该客户端发送的请求，因此需要将此通道注册到选择器上，并且仅监听读事件</span></span><br><span class="line">        acceptSocketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.获取事件的Channel，并转化为SocketChannel</span></span><br><span class="line">        SocketChannel readableSocketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建读取数据用的缓冲区</span></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.获取请求参数</span></span><br><span class="line">        <span class="keyword">int</span> len = readableSocketChannel.read(buf);</span><br><span class="line">        <span class="keyword">if</span>(len == -<span class="number">1</span>)&#123;</span><br><span class="line">            readableSocketChannel.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将buf从写模式变成读模式，并打印请求参数</span></span><br><span class="line">        buf.flip();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取到客户端的请求，参数:&quot;</span> + <span class="keyword">new</span> String(buf.array(), <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读完需要清理(防止重复处理)，并发送响应数据</span></span><br><span class="line">        buf.clear();</span><br><span class="line">        readableSocketChannel.write(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).encode(<span class="string">&quot;response data...&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>客户端代码(启动多个)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.本地创建一个网络通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.切换非阻塞模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.注册与服务端连接成功的事件监听</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.指定服务端的地址和端口，尝试建立连接</span></span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9898</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.进入无脑循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.检查监听的事件，这个方法在任何条件下都是阻塞的，直到查询出事件</span></span><br><span class="line">            <span class="keyword">int</span> selectCount = selector.select();</span><br><span class="line">            <span class="keyword">if</span> (selectCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8.获取监听到的事件</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9.获取迭代器并循环</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 10.获取就绪事件key</span></span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 11.从迭代器中删除此事件，防止后续重复处理</span></span><br><span class="line">                iterator.remove();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 12.如果是来自客户端的连接事件</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isConnectable()) &#123;</span><br><span class="line">                    connectableHandler(selectionKey, selector);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 13.如果是可读事件</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                    readHandler(selectionKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">connectableHandler</span><span class="params">(SelectionKey selectionKey, Selector selector)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将通道转化为SocketChannel类型</span></span><br><span class="line">        SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果与服务端连接成功，</span></span><br><span class="line">        <span class="keyword">if</span>(socketChannel.finishConnect())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 后续向服务端发送请求会收到响应数据，因此需要将此通道注册到选择器上，监听读事件获取响应数据</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟请求，发送到服务端</span></span><br><span class="line">            send(socketChannel);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;与服务端连接成功，注册可读事件，并发送请求...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readHandler</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.获取事件的Channel，并转化为SocketChannel</span></span><br><span class="line">        SocketChannel readableSocketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建读取数据用的缓冲区</span></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.获取请求参数</span></span><br><span class="line">        <span class="keyword">int</span> len = readableSocketChannel.read(buf);</span><br><span class="line">        <span class="keyword">if</span>(len == -<span class="number">1</span>)&#123;</span><br><span class="line">            readableSocketChannel.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buf.flip();</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到服务端响应结果:&quot;</span> + <span class="keyword">new</span> String(buf.array(),<span class="number">0</span>,len));</span><br><span class="line">        buf.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(SocketChannel socketChannel)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String message = <span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次请求...&quot;</span>;</span><br><span class="line">                        ByteBuffer byteBuffer = ByteBuffer.wrap(message.getBytes());</span><br><span class="line"></span><br><span class="line">                        socketChannel.write(byteBuffer);</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务端的控制台打印:</strong><br>与客户端连接成功，注册可读事件…<br>获取到客户端的请求，参数:第1次请求…<br>获取到客户端的请求，参数:第2次请求…<br>获取到客户端的请求，参数:第3次请求…</p><p><strong>客户端的控制台打印:</strong><br>与服务端连接成功，注册可读事件，并发送请求…<br>接收到服务端响应结果:response data…<br>接收到服务端响应结果:response data…<br>接收到服务端响应结果:response data…</p><p class='p red'>无论上层如何实现，服务端对于每一个与客户端的TCP通道，都需要轮询去检查我们关注的事件，只不过多路复用IO模型将这件事情交给内核去处理，检查效率自然要比在应用程序快很多，而服务端的Java代码只需要开启一个线程去盯着内核的检查结果。</p><p class='p red'>多路复用IO模型仅适合客户端连接数多、请求频率低的场景，如果连接数少可以直接用普通非阻塞IO模型，实现更简单；如果请求频率高，单个线程处理较慢，会影响响应速度。当然也并不是只能开一个线程，也可以开10个或者再多一点，将channel分组处理。</p><h3 id="3-3-信号驱动IO-网络"><a href="#3-3-信号驱动IO-网络" class="headerlink" title="3.3 信号驱动IO(网络)"></a>3.3 信号驱动IO(网络)</h3><p>信号驱动IO模型本质上是利用内核的信号检测机制，避免了程序在数据准备阶段的轮询检查，而是通过内核回调的机制通知程序，因此服务端与客户端的每个TCP通道，都需要向内核注册一个信号处理器，用于回调:</p><figure class="highlight java"><figcaption><span>信号量处理器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketReadableSignalHandler</span> <span class="keyword">implements</span> <span class="title">SignalHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel SOCKET_CHANNEL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer BUFFER;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketReadableSignalHandler</span><span class="params">(SocketChannel socketChannel, <span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.SOCKET_CHANNEL = socketChannel;</span><br><span class="line">        <span class="keyword">this</span>.BUFFER = ByteBuffer.allocate(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Signal signal)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 只处理SIGIO信号量，SIGIO信号量在Mac系统中的名称为IO</span></span><br><span class="line">            <span class="keyword">if</span>(!Objects.equals(signal.getName(), <span class="string">&quot;IO&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只有连接完成才处理</span></span><br><span class="line">            <span class="keyword">if</span>(!SOCKET_CHANNEL.finishConnect())&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读到了数据才处理</span></span><br><span class="line">            <span class="keyword">int</span> len = SOCKET_CHANNEL.read(BUFFER);</span><br><span class="line">            <span class="keyword">if</span>(len == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印请求参数</span></span><br><span class="line">            BUFFER.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;获取到客户端的请求，参数:&quot;</span> + <span class="keyword">new</span> String(BUFFER.array(), <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清空缓冲区，并发送响应数据</span></span><br><span class="line">            BUFFER.clear();</span><br><span class="line">            SOCKET_CHANNEL.write(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).encode(<span class="string">&quot;response data...&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向内核注册监听的信号事件，例如SIGIO信号量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSignal</span><span class="params">(String signalName)</span> </span>&#123;</span><br><span class="line">        Signal signal = <span class="keyword">new</span> Signal(signalName);</span><br><span class="line">        Signal.handle(signal, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>服务端代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建服务端socket通道</span></span><br><span class="line">    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.切换非阻塞模式</span></span><br><span class="line">    serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.给创建的服务端socket通道，申请一个端口</span></span><br><span class="line">    serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.进入无脑循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查有没有来自客户端的连接</span></span><br><span class="line">        SocketChannel clientChannel = serverSocketChannel.accept();</span><br><span class="line">        <span class="keyword">if</span>(clientChannel == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向内核注册SIGIO信号量的监听(SIGIO信号在Mac系统的名称为IO)</span></span><br><span class="line">        SocketReadableSignalHandler signalHandler = <span class="keyword">new</span> SocketReadableSignalHandler(clientChannel, <span class="number">1024</span>);</span><br><span class="line">        signalHandler.registerSignal(<span class="string">&quot;IO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></br><p class='p red'>客户端的代码就不写了，因为关于此模型我一直没实现想要的效果，换句话说就是无论客户端怎么发送请求，服务端的handler都收不到信号。之前看Linux的相关文章，都表示handler是基于某个socket描述符进行监听，但是Java的API在注册handler时，根本就没有关于socket的参数。可能TCP在这块很少应用，导致很多技术网站都找不到这块资料，后续搞明白了再回来更新。</p><h3 id="3-4-其他细节"><a href="#3-4-其他细节" class="headerlink" title="3.4 其他细节"></a>3.4 其他细节</h3><p><strong>1.将channel对象的configureBlocking设置为true或false的区别是什么?</strong></p><table><thead><tr><th>configureBlocking</th><th>受影响的方法名称</th><th>调用效果</th></tr></thead><tbody><tr><td>true</td><td>connect</td><td>方法进入阻塞，直到连接出结果为止(成功或异常等)</td></tr><tr><td>true</td><td>read</td><td>方法进入阻塞， 直到有可读数据并读出为止</td></tr><tr><td>true</td><td>write</td><td>方法进入阻塞，直到Buffer将数据写入channel</td></tr><tr><td>false</td><td>connect</td><td>方法立刻返回，后续读写数据前需要调用finishConnect()方法，确定是否成功建立连接</td></tr><tr><td>false</td><td>read</td><td>方法立刻返回，读取Biffer内容判断是否有可读数据</td></tr><tr><td>false</td><td>write</td><td>方法立刻返回</td></tr></tbody></table><p></br><strong>2.关于非阻塞IO，为什么只提网络IO而不提磁盘IO?</strong></p><p>这主要是因为网络IO(TCP、UDP等)都是长连接，建立连接后的任何一个时间点，都有可能发生网络请求，因此为了保证接收到请求后，立刻做出响应，这就需要借助一些方式，不停的对网卡设备进行检查。上述的IO模型，本质上就是操作系统提供的几种方式，开发者可以根据实际场景，选择合适的方案，尽可能的在检查过程中减少CPU的消耗。</p><p>而磁盘IO是与硬盘设备建立连接，不存在设备不可读的情况，并且文件有多少数据可读就摆在那，一般的场景也不会考虑到文件被修改后，需要立刻做出回应的场景。因此在进行磁盘IO时，往往都是使用传统的同步阻塞IO，代码实现起来非常简单，在确保每次都能读到数据的情况下，执行效率相对NIO也要高一些。</p><p>如果有大文件读取这种场景，NIO还是具有一定的发挥空间，可以利用MappedByteBuffer的内存映射机制，减少一次内核态到用户态的拷贝，提升读取效率。但内存映射需要额外开辟内存，大小受进程虚拟地址空间、操作系统限制。</p><p></br><strong>3.数据的发送与响应之间没有任何关系，客户端如何区分每次请求对应的响应数据?</strong></p><p>无论是TCP还是UDP网络协议，都属于网络七层协议中的第四层(传输层)，传输层只是建立服务端与客户端之间的桥梁，使其能够相互传输数据，并不关心这些数据所代表的含义，以及每次传输之间的联系，NIO完全具备这个能力。如果想要实现问题中的效果，只能通过第五层(会话层)、第六层(表示层)、第七层(应用层)网络协议实现。</p><p><span style="color:red">会话层</span>以部分RPC协议(有些RPC在第七层)为例，通俗说就是定义一套收发送数据的规范，基本由RPC协议头、RPC协议体组成，RPC协议头包含消息长度、消息ID、序列化方式等信息，每次请求时生成一个消息ID，服务端响应时带上请求时的消息ID，这样就可以进行关联。很多RPC框架除此之外还会提供其他丰富的功能，比如调用时的动态寻址、负载均衡、超时重连等，例如Java中的Dubbo框架。</p><p><span style="color:red">表示层</span>可以对会话层继续封装，也可以忽略会话层，直接对传输层进行封装，提供一些文件加密解密、压缩解压等处理逻辑，这一层协议在工作中确实从来没接触过，就不说了。</p><p><span style="color:red">应用层</span>最常见的就是http、https协议，https是对会话层的ssl或tls协议进行封装，支持加密传输、身份认证等功能，防止敏感数据被第三方截取或伪装请求，而http协议忽略会话层、表示层，直接对传输层进行封装，连接简单但不安全。在http1.0中，客户端每次向服务端发送请求，都会创建新的TCP连接，收到响应后再断开连接，因为每次连接都只有一次请求和响应，所以无需进行区分。</p><p>http1.1中默认使用长连接，可以修改header头中的Connection改变连接方式(默认keep-alive，改成close即可变成短连接)，如果是长连接那么TCP连接会保持一段时间，也就是说一次TCP连接可以多次HTTP请求。区分起来也非常简单，http1.1中单个TCP上的多次请求是必须按照顺序来的，因此客户端记住请求的顺序，然后接受响应时按顺序匹配即可。</p><p>http2.0增加了多路复用功能，说白了就是解决http1.1版本只能顺序处理请求，效率低的缺点，提高网络传输的并发能力。客户端将请求的数据分割成多个帧，并且为这组帧分配一个id，这些帧可以乱序发送，最后收到的响应也是多段帧数据，然后通过每个帧上的id标识组装响应结果，通过id匹配到请求的发起者。</p><p class='p red'>由此可以看出，传输层网络协议很难直接在项目中应用，上述的几种网络IO模型代码也很难在实际场景中直接使用，通常都是使用别人封装好的工具或框架，例如gRPC、HttpClients、netty等。</p><h2 id="4-异步非阻塞IO"><a href="#4-异步非阻塞IO" class="headerlink" title="4.异步非阻塞IO"></a>4.异步非阻塞IO</h2><p>暂无</p>-->]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> io流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流(十一) 缓冲字符流</title>
      <link href="2020/05/27/IO%E6%B5%81-%E7%BC%93%E5%86%B2%E5%AD%97%E7%AC%A6%E6%B5%81/"/>
      <url>2020/05/27/IO%E6%B5%81-%E7%BC%93%E5%86%B2%E5%AD%97%E7%AC%A6%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h2 id="2-BufferedReader"><a href="#2-BufferedReader" class="headerlink" title="2.BufferedReader"></a>2.BufferedReader</h2><h2 id="3-BufferedWriter"><a href="#3-BufferedWriter" class="headerlink" title="3.BufferedWriter"></a>3.BufferedWriter</h2>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> io流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流(十) 转换流</title>
      <link href="2020/05/26/IO%E6%B5%81-%E8%BD%AC%E6%8D%A2%E6%B5%81/"/>
      <url>2020/05/26/IO%E6%B5%81-%E8%BD%AC%E6%8D%A2%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>InputStreamReader即转换输入流，OutputStreamWriter即转换输出流，<span class="p red">转换流是从字节流到字符流的桥接器</span>，它通过指定的字符集读取字节数据并解码为字符。在使用过程中，我们可以通过名称明确指定一个字符集，如果不指定则使用当前操作系统默认的字符集。</p><h2 id="2-InputStreamReader"><a href="#2-InputStreamReader" class="headerlink" title="2.InputStreamReader"></a>2.InputStreamReader</h2><h2 id="3-OutputStreamWriter"><a href="#3-OutputStreamWriter" class="headerlink" title="3.OutputStreamWriter"></a>3.OutputStreamWriter</h2>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> io流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流(九) 字符编码流</title>
      <link href="2020/05/25/IO%E6%B5%81-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%B5%81/"/>
      <url>2020/05/25/IO%E6%B5%81-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><h2 id="2-StreamEncoder"><a href="#2-StreamEncoder" class="headerlink" title="2.StreamEncoder"></a>2.StreamEncoder</h2><h2 id="3-StreamDecoder"><a href="#3-StreamDecoder" class="headerlink" title="3.StreamDecoder"></a>3.StreamDecoder</h2>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> io流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流(八) 缓冲处理字节流</title>
      <link href="2020/05/22/IO%E6%B5%81-%E7%BC%93%E5%86%B2%E5%A4%84%E7%90%86%E5%AD%97%E8%8A%82%E6%B5%81/"/>
      <url>2020/05/22/IO%E6%B5%81-%E7%BC%93%E5%86%B2%E5%A4%84%E7%90%86%E5%AD%97%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>BufferedInputStream、BufferedOutputStream是带有缓冲区的字节处理流，默认的缓冲区字节数组大小为8192(8KB)，通过装饰器模式对InputStream、OutputStream的功能进行增强，每次读写都是基于内部缓冲区操作，当缓冲区存储的字节超过一定数量时，才会进行真正的磁盘IO，这样能够有效减少磁盘的访问次数，从而提高读写的性能。</p><p class="p red">虽然缓冲处理流能装饰一切InputStream、OutputStream的子类，但是对序列化流、数据处理流等的装饰毫无意义，因为读写规则比较特殊，对数组字节流的装饰更是画蛇添足，因为这种流本身就基于内存。因此缓冲处理流的装饰对象基本都是文件、网络等，这种场景才能减少与操作系统或IO设备的交互次数。</p><h2 id="2-简单使用"><a href="#2-简单使用" class="headerlink" title="2.简单使用"></a>2.简单使用</h2><h3 id="2-1-数据写入"><a href="#2-1-数据写入" class="headerlink" title="2.1 数据写入"></a>2.1 数据写入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件输入流</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;you path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建缓冲输入流，进行装饰 </span></span><br><span class="line">BufferedInputStream bufis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建缓冲</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始读取</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>((len = bufis.read(bytes))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">       &#125;</span><br><span class="line">       bufis.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-数据读取"><a href="#2-2-数据读取" class="headerlink" title="2.2 数据读取"></a>2.2 数据读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件输入流</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;you path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建缓冲输入流，进行装饰 </span></span><br><span class="line">BufferedOutputStream bufos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建缓冲</span></span><br><span class="line">bufos.write(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 落盘</span></span><br><span class="line">       bufos.flush();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 关闭流</span></span><br><span class="line">       bufis.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="3-BufferedInputStream"><a href="#3-BufferedInputStream" class="headerlink" title="3.BufferedInputStream"></a>3.BufferedInputStream</h2><h3 id="3-1-成员变量"><a href="#3-1-成员变量" class="headerlink" title="3.1 成员变量"></a>3.1 成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓冲区字节数组的默认大小，可以通过构造器初始化，覆盖此值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲区最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_BUFFER_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部缓冲区</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">byte</span> buf[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新缓存成员变量引用指向在堆中的实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span></span><br><span class="line">       AtomicReferenceFieldUpdater&lt;BufferedInputStream, <span class="keyword">byte</span>[]&gt; bufUpdater =</span><br><span class="line">       AtomicReferenceFieldUpdater.newUpdater</span><br><span class="line">       (BufferedInputStream.class,  <span class="keyword">byte</span>[].class, <span class="string">&quot;buf&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 缓冲区中可用的字节数量(包括已读和未读的)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下次read读取的缓冲区坐标</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持重复读取情况下，重置后从该坐标重复读取，mark坐标以及往后的字节需要保留，用于reset后仍然能读到</span></span><br><span class="line"><span class="comment">// 但是缓冲区不可能为了这段数据无限扩容，字节总数超过marklimit，mark标记会变得无效</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> markpos = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mark后缓冲区能保存的字节，在数量上的极限</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> marklimit;</span><br></pre></td></tr></table></figure><h3 id="3-2-mark-amp-reset"><a href="#3-2-mark-amp-reset" class="headerlink" title="3.2 mark &amp; reset"></a>3.2 mark &amp; reset</h3><p>BufferedInputStream支持流的<span class="p red">重复读取</span>，而这个功能就是通过mark和reset方法进行实现。以单字节方式读取一段缓冲流为例:<br><img src="/2020/05/22/IO%E6%B5%81-%E7%BC%93%E5%86%B2%E5%A4%84%E7%90%86%E5%AD%97%E8%8A%82%E6%B5%81/%E6%A0%87%E8%AE%B0%E4%B8%8E%E9%87%8D%E7%BD%AE%E8%BF%87%E7%A8%8B.png" class="lazyload" data-srcset="/2020/05/22/IO%E6%B5%81-%E7%BC%93%E5%86%B2%E5%A4%84%E7%90%86%E5%AD%97%E8%8A%82%E6%B5%81/%E6%A0%87%E8%AE%B0%E4%B8%8E%E9%87%8D%E7%BD%AE%E8%BF%87%E7%A8%8B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>方法源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span> </span>&#123;</span><br><span class="line">    marklimit = readlimit;</span><br><span class="line">    markpos = pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    getBufIfOpen();</span><br><span class="line">    <span class="keyword">if</span> (markpos &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Resetting to invalid mark&quot;</span>);</span><br><span class="line">    pos = markpos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class="p red">mark与reset方法是InputStream提供的接口，在这里讲解主要是因为使用标记后，会让BufferedInputStream的缓冲区管理变得复杂，因此只有搞清楚这块的逻辑，才能研究接下来的方法。</p><h3 id="3-3-fill"><a href="#3-3-fill" class="headerlink" title="3.3 fill"></a>3.3 fill</h3><p>在读取数据时，<span class="p red">如果缓冲区的数据已经全部读完</span>，则需要将缓冲区的字节重新填装，fill方法就是通过数据滑动的方式实现缓冲区填装，方法的具体源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前缓冲区数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] buffer = getBufIfOpen();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果markpos小于0，代表此对象没有调用过mark方法，或者mark后已经被重置过了</span></span><br><span class="line">      <span class="keyword">if</span> (markpos &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 将下次读取的坐标设置为0，也就是第一个坐标，具体的最后会讲</span></span><br><span class="line">          pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果被mark方法标记，并且下次读取坐标超出缓冲区的范围</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (pos &gt;= buffer.length)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果mark的缓冲区坐标大于0，调用mark方法后再调用read肯定会进入此方法</span></span><br><span class="line">          <span class="comment">// 从mark坐标开始往右的元素都要保存，否则reset后无法从mark坐标重读读取</span></span><br><span class="line">          <span class="keyword">if</span> (markpos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 计算从缓冲区的最右边开始，往左多少个元素需要保存</span></span><br><span class="line">              <span class="keyword">int</span> sz = pos - markpos;</span><br><span class="line">              <span class="comment">// 将buffer右端需要保存的所有字节，滑动到最左端</span></span><br><span class="line">              System.arraycopy(buffer, markpos, buffer, <span class="number">0</span>, sz);</span><br><span class="line">              <span class="comment">// 下次读取的坐标仍然从标记后开始</span></span><br><span class="line">              pos = sz;</span><br><span class="line">              <span class="comment">// 到此mark标记涉及的字节元素都保存下来了，可以将markpos=0</span></span><br><span class="line">              markpos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// mark后第二次read会进入此if，如果缓冲区足够大，可以支撑marklimit个字节的读取，直接重置</span></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length &gt;= marklimit) &#123;</span><br><span class="line">              <span class="comment">// 直接重置markpos是-1，左滑后设置是0</span></span><br><span class="line">              markpos = -<span class="number">1</span>;</span><br><span class="line">              pos = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">// 执行到此if判断，说明缓冲区容纳不下marklimit个字节，如果没法扩容只能抛异常</span></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length &gt;= MAX_BUFFER_SIZE) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError(<span class="string">&quot;Required array size too large&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 到这里表示缓冲区容纳不下marklimit个元素供重置后读取，但还可以扩容，因此必须扩容</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果2倍扩容后不超过最大容量限制，则进行2倍扩容，否则使用最大容量</span></span><br><span class="line">              <span class="keyword">int</span> nsz = (pos &lt;= MAX_BUFFER_SIZE - pos) ?</span><br><span class="line">                      pos * <span class="number">2</span> : MAX_BUFFER_SIZE;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 如果计算后的新容量大于marklimit，则使用marklimit</span></span><br><span class="line">              <span class="keyword">if</span> (nsz &gt; marklimit)</span><br><span class="line">                  nsz = marklimit;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 将最终确定的容量大小进行数组的创建</span></span><br><span class="line">              <span class="keyword">byte</span> nbuf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[nsz];</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 将字节数据拷贝到扩容后的缓冲区中</span></span><br><span class="line">              System.arraycopy(buffer, <span class="number">0</span>, nbuf, <span class="number">0</span>, pos);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 使用CAS方式将扩容后的缓冲区赋值到成员变量</span></span><br><span class="line">              <span class="keyword">if</span> (!bufUpdater.compareAndSet(<span class="keyword">this</span>, buffer, nbuf)) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Stream closed&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 将扩容后的缓冲区赋值给局部变量</span></span><br><span class="line">              buffer = nbuf;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 先将可读取字节数设置为已读取的数量</span></span><br><span class="line">      count = pos;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用装饰输入流的read方法，向缓冲区填装数据</span></span><br><span class="line">      <span class="keyword">int</span> n = getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果从装饰的输入流中读到数据，那么可读字节总数就变成已读+装饰输入流读出的数量</span></span><br><span class="line">      <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">          count = n + pos;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码有点晦涩难懂，首先缓冲区在没字节可读的情况下才会调用fill()，如果此BufferedInputStream对象没有调用过mark，那么处理起来是最简单的，把下次读取的坐标设置为缓冲区的首坐标(pos=0)，从装饰器的输入流中读取缓冲区大小的字节，将缓冲区以覆盖形式填满新字节，下次从头读取。</p><p>被mark调用过就比较麻烦，可以看看<span class="p blue">else if (pos >= buffer.length)</span>执行流程图:<br><img src="/2020/05/22/IO%E6%B5%81-%E7%BC%93%E5%86%B2%E5%A4%84%E7%90%86%E5%AD%97%E8%8A%82%E6%B5%81/mark%E5%90%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A1%AB%E8%A3%85.png" class="lazyload" data-srcset="/2020/05/22/IO%E6%B5%81-%E7%BC%93%E5%86%B2%E5%A4%84%E7%90%86%E5%AD%97%E8%8A%82%E6%B5%81/mark%E5%90%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A1%AB%E8%A3%85.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h3 id="3-3-read-单字节"><a href="#3-3-read-单字节" class="headerlink" title="3.3 read(单字节)"></a>3.3 read(单字节)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// count值代表了缓冲区已存字节的数量，pos大于等于此之值，代表缓冲区的数据已经读完了</span></span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">        <span class="comment">// 重新填装</span></span><br><span class="line">        fill();</span><br><span class="line">        <span class="comment">// 填装后如果还是如此，说明已经读完了，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据pos读取缓冲区单个字节，高位补零后返回，pos递增1</span></span><br><span class="line">    <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-read-多字节"><a href="#3-4-read-多字节" class="headerlink" title="3.4 read(多字节)"></a>3.4 read(多字节)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查缓冲区是否被关闭</span></span><br><span class="line">    getBufIfOpen();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验参数</span></span><br><span class="line">    <span class="keyword">if</span> ((off | len | (off + len) | (b.length - (off + len))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据len长度循环，直到读取len个字节为止</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用私有方法尽量读</span></span><br><span class="line">        <span class="keyword">int</span> nread = read1(b, off + n, len - n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没读取到直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (nread &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (n == <span class="number">0</span>) ? nread : n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取到就将读取的字节数量记录下来</span></span><br><span class="line">        n += nread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取完成后返回</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt;= len)</span><br><span class="line">            <span class="keyword">return</span> n;   </span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 如果装饰的输入流没关闭，但是没字节可以读了，直接返回</span></span><br><span class="line">        InputStream input = in;</span><br><span class="line">        <span class="keyword">if</span> (input != <span class="keyword">null</span> &amp;&amp; input.available() &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有方法一次读取多个字节(尽量读，有可能填装完还读不满len):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">read1</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出缓冲区可读字节中，还未读取的数量</span></span><br><span class="line">    <span class="keyword">int</span> avail = count - pos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有可读的字节</span></span><br><span class="line">    <span class="keyword">if</span> (avail &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果想要读取的长度大于等于缓冲区长度，并且没有被mark标记</span></span><br><span class="line">        <span class="comment">// 缓冲区无法容纳(不扩容情况下)，直接从装饰的流中一次性读取，减少数组copy带来的性能消耗</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt;= getBufIfOpen().length &amp;&amp; markpos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 读取并返回</span></span><br><span class="line">            <span class="keyword">return</span> getInIfOpen().read(b, off, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里只能填装了</span></span><br><span class="line">        fill();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次计算可读字节</span></span><br><span class="line">        avail = count - pos;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有表示已经读完</span></span><br><span class="line">        <span class="keyword">if</span> (avail &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算可以读取的字节数量(不能超过最大字节数)</span></span><br><span class="line">    <span class="keyword">int</span> cnt = (avail &lt; len) ? avail : len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向缓冲区中读取数据</span></span><br><span class="line">    System.arraycopy(getBufIfOpen(), pos, b, off, cnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回读取的字节</span></span><br><span class="line">    pos += cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-BufferedOutputStream"><a href="#4-BufferedOutputStream" class="headerlink" title="4.BufferedOutputStream"></a>4.BufferedOutputStream</h2><p>缓冲处理输出流相对输入流来说，不用考虑mark后字节的保存情况，也不用考虑缓冲区的扩容情况，唯一要考虑的就是写完后需要手动flush，确保缓冲区数据都刷新到装饰的输入流，因为写入时只有缓冲区满了才会自动刷新。</p><h3 id="4-1-成员变量"><a href="#4-1-成员变量" class="headerlink" title="4.1 成员变量"></a>4.1 成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 缓冲区</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span> buf[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已写入字节数量</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><h3 id="4-2-write-单字节"><a href="#4-2-write-单字节" class="headerlink" title="4.2 write(单字节)"></a>4.2 write(单字节)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果字节已写满缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= buf.length) &#123;</span><br><span class="line">        <span class="comment">// 刷新缓冲字节(到磁盘等)</span></span><br><span class="line">        flushBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新写入的字节放入缓冲区，count递增1</span></span><br><span class="line">    buf[count++] = (<span class="keyword">byte</span>)b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用私有方法，将写入缓冲区的字节数组同步到装饰的输出流:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 在缓冲区存在字节的情况下</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 将缓冲区字节写入内部装饰的输出流</span></span><br><span class="line">        out.write(buf, <span class="number">0</span>, count);</span><br><span class="line">        <span class="comment">// 缓冲区字节数量归零</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-write-多字节"><a href="#4-3-write-多字节" class="headerlink" title="4.3 write(多字节)"></a>4.3 write(多字节)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果要批量写入的字节数量大于缓冲区容量</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt;= buf.length) &#123;</span><br><span class="line">        <span class="comment">// 刷新缓冲区</span></span><br><span class="line">        flushBuffer();</span><br><span class="line">        <span class="comment">// 不会扩容，而是直接写入装饰的输出流</span></span><br><span class="line">        out.write(b, off, len);</span><br><span class="line">        <span class="comment">// 结束</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要批量写入的字节数量大于缓冲区剩余容量，仍然刷新缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; buf.length - count) &#123;</span><br><span class="line">        flushBuffer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将要批量写入的字节数组拷贝到缓冲区</span></span><br><span class="line">    System.arraycopy(b, off, buf, count, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区字节数量递增1</span></span><br><span class="line">    count += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> io流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流(七) 数据处理字节流</title>
      <link href="2020/05/19/IO%E6%B5%81-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AD%97%E8%8A%82%E6%B5%81/"/>
      <url>2020/05/19/IO%E6%B5%81-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AD%97%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>DataInputStream即数据输入流，DataOutputStream即数据输出流，允许应用程序以<span class="p red">与机器无关方式</span>从底层输入流中读取<span class="p red">Java基本数据类型</span>。这俩个类分别继承FilterInput/OutputStream，内部采用装饰器模式对Input/OutputStream的功能进行增强。</p><p>与机器无关是因为Java基础数据类型结构简单，转化为字节并存储的逻辑也相对简单，其他机器或语言可以轻松复原。另外数据处理流通过UTF-8编码封装了对String类型的读写，UTF-8编码在各机器或者语言都是通用的，因此字符串的处理也不受平台的影响。</p><h2 id="2-简单使用"><a href="#2-简单使用" class="headerlink" title="2.简单使用"></a>2.简单使用</h2><h3 id="2-1-数据写入"><a href="#2-1-数据写入" class="headerlink" title="2.1 数据写入"></a>2.1 数据写入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 基于文件输出流，创建数据处理输出流</span></span><br><span class="line">       FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;you path&quot;</span>);</span><br><span class="line">       DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(fos);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 写入基本数据类型</span></span><br><span class="line">       dos.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">       dos.writeChar(<span class="string">&#x27;哈&#x27;</span>);</span><br><span class="line">       dos.writeByte(<span class="number">7</span>);</span><br><span class="line">       dos.writeShort(<span class="number">12</span>);</span><br><span class="line">       dos.writeInt(<span class="number">25</span>);</span><br><span class="line">       dos.writeLong(<span class="number">39</span>);</span><br><span class="line">       dos.writeFloat(<span class="number">4.1f</span>);</span><br><span class="line">       dos.writeDouble(<span class="number">9.8</span>);</span><br><span class="line">       dos.writeUTF(<span class="string">&quot;IO流&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>查看生成的文件内容:<br><img src="/2020/05/19/IO%E6%B5%81-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AD%97%E8%8A%82%E6%B5%81/%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5.png" class="lazyload" data-srcset="/2020/05/19/IO%E6%B5%81-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AD%97%E8%8A%82%E6%B5%81/%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>对应结构:<br><img src="/2020/05/19/IO%E6%B5%81-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AD%97%E8%8A%82%E6%B5%81/%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/2020/05/19/IO%E6%B5%81-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AD%97%E8%8A%82%E6%B5%81/%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>首次写入不同的基本数据类型，生成文件的默认编码集也不同，例如写入boolean、char字母或数字、正整数等类型生成的文件是<span class="p red">binary编码</span>，这种编码通过文本编辑器打开文件后，会以上图所示的16进制正常展示。</p><p>写入char汉字生成的文件是<span class="p red">iso-8859-1编码(不支持中文表达)</span>，因此打开的文件内容是乱码。最后Double、Int负数、UTF等类型是<span class="p red">unkown-8bit编码</span>，文本编辑器软件仍然无法正常识别并展示，还是会出现奇奇怪怪的字符。</p><p>Mac笔记本可以通过<span class="p blue">file -I 文件路径</span>查看文件的编码集，如果文件的编码集无法被文本编辑器正常显示(我使用的是Sublime Text，也可能是文本编辑器的原因)，通过<span class="p blue">hexdump -v 文件路径</span>命令查看原始16进制内容，得到上图的查看效果。</p><h3 id="2-2-数据读取"><a href="#2-2-数据读取" class="headerlink" title="2.2 数据读取"></a>2.2 数据读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于文件输入流，创建数据处理输入流</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;you path&quot;</span>);</span><br><span class="line">    DataInputStream dis = <span class="keyword">new</span> DataInputStream(fis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取基本数据类型</span></span><br><span class="line">    System.out.println(dos.readBoolean());</span><br><span class="line">    System.out.println(dos.readChar());</span><br><span class="line">    System.out.println(dos.readByte());</span><br><span class="line">    System.out.println(dos.readShort());</span><br><span class="line">    System.out.println(dos.readInt());</span><br><span class="line">    System.out.println(dos.readLong());</span><br><span class="line">    System.out.println(dos.readFloat());</span><br><span class="line">    System.out.println(dos.readDouble());</span><br><span class="line">    System.out.println(dis.readUTF());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class="p red">注: DataOutputStream是将基本数据类型转化为字节挨个存储，因此DataInputStream在读取数据时，要遵循写入时的顺序，否则会读取失败。</p><h2 id="3-DataOutputStream"><a href="#3-DataOutputStream" class="headerlink" title="3.DataOutputStream"></a>3.DataOutputStream</h2><p>先从写入开始研究，提供的写入方法整体比较多，但万变不离其宗，都是转化为字节然后调用内部装饰的InputStream类进行字节写入，就简单研究几个有代表性的方法。</p><h3 id="3-1-writeBoolean"><a href="#3-1-writeBoolean" class="headerlink" title="3.1 writeBoolean"></a>3.1 writeBoolean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeBoolean</span><span class="params">(<span class="keyword">boolean</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// boolean占用1bit，为了方便管理，这里使用1字节存储</span></span><br><span class="line">    out.write(v ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 将写入的字节数量纪录到计数器中</span></span><br><span class="line">    incCount(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">incCount</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算递增后的值</span></span><br><span class="line">    <span class="keyword">int</span> temp = written + value;</span><br><span class="line">    <span class="comment">// 如果超过int类型最大值，则停止递增</span></span><br><span class="line">    <span class="keyword">if</span> (temp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        temp = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始递增</span></span><br><span class="line">    written = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-writeInt"><a href="#3-2-writeInt" class="headerlink" title="3.2 writeInt"></a>3.2 writeInt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int类型占用4字节，因此需要把int值拆成4份字节，然后从高位到低位逐次写入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 从左开始取二进制的0-8位，位与运算成字节，写入输出流</span></span><br><span class="line">    out.write((v &gt;&gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="comment">// 从左开始取二进制的8-16位，位与运算成字节，写入输出流</span></span><br><span class="line">    out.write((v &gt;&gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="comment">// 从左开始取二进制的16-24位，位与运算成字节，写入输出流</span></span><br><span class="line">    out.write((v &gt;&gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="comment">// 从左开始取二进制的24-32位，位与运算成字节，写入输出流</span></span><br><span class="line">    out.write((v &gt;&gt;&gt;  <span class="number">0</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    <span class="comment">// 递增4字节</span></span><br><span class="line">    incCount(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>例如现在写入一个值为<span class="p blue">330067683</span>的int数据类型:<br><img src="/2020/05/19/IO%E6%B5%81-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AD%97%E8%8A%82%E6%B5%81/writeInt%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="lazyload" data-srcset="/2020/05/19/IO%E6%B5%81-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AD%97%E8%8A%82%E6%B5%81/writeInt%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p class="p red">类似的还有char、byte、sort、long这四个基本类型的写入，都是直接将对应二进制以字节为单位进行拆分，然后调用内部装饰OutputStream类的write单字节逐次写入。long类型稍微特殊一点，是将拆分的8个字节放进数组中批量写入，只和操作系统交互一次。</p><h3 id="3-3-writeFloat"><a href="#3-3-writeFloat" class="headerlink" title="3.3 writeFloat"></a>3.3 writeFloat</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeFloat</span><span class="params">(<span class="keyword">float</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 将浮点类型转化为int，然后调用writeInt方法</span></span><br><span class="line">    writeInt(Float.floatToIntBits(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">floatToIntBits</span><span class="params">(<span class="keyword">float</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用native方法，将浮点数字转化为正数</span></span><br><span class="line">    <span class="keyword">int</span> result = floatToRawIntBits(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是无效的数字(NaN)，返回0x7fc00000</span></span><br><span class="line">    <span class="keyword">if</span> ( ((result &amp; FloatConsts.EXP_BIT_MASK) ==</span><br><span class="line">          FloatConsts.EXP_BIT_MASK) &amp;&amp;</span><br><span class="line">         (result &amp; FloatConsts.SIGNIF_BIT_MASK) != <span class="number">0</span>)</span><br><span class="line">        result = <span class="number">0x7fc00000</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-writeUTF"><a href="#3-4-writeUTF" class="headerlink" title="3.4 writeUTF"></a>3.4 writeUTF</h3><p>writeUTF方法并没有真正写入，而是将自身作为参数交给静态方法处理:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String str)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    writeUTF(str, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>真正处理写入逻辑的静态方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正使用UTF-8编码处理字符串的静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">writeUTF</span><span class="params">(String str, DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取要写入的字符串的长度 </span></span><br><span class="line">    <span class="keyword">int</span> strlen = str.length();</span><br><span class="line">    <span class="comment">// 转化为utf编码后的长度计数器</span></span><br><span class="line">    <span class="keyword">int</span> utflen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// c用于遍历字符串的循环中赋值，记录当前char类型的数值</span></span><br><span class="line">    <span class="comment">// count表示写入缓冲区的字节位置</span></span><br><span class="line">    <span class="keyword">int</span> c, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环字符串的每个字符，判断字符对应的utf编码长度，并递增到utflen变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strlen; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取字符并赋值给当前变量c</span></span><br><span class="line">        c = str.charAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0x007F为ASCII编码表的最大值，代表当前字符在ASCII编码表范围内，可以用1个字节表示，utf长度视为1</span></span><br><span class="line">        <span class="keyword">if</span> ((c &gt;= <span class="number">0x0001</span>) &amp;&amp; (c &lt;= <span class="number">0x007F</span>)) &#123;</span><br><span class="line">            utflen++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 值大于0x07FF就是汉字，需要用3个字节表示，utf长度视为3</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; <span class="number">0x07FF</span>) &#123;</span><br><span class="line">            utflen += <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0x007F和0x07FF之间是其他特殊符号，需要用2个字节表示，utf长度视为2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            utflen += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串转化为utf编码的长度，不能超过65535，这是因为字符串的长度会采用2个字节在文件中标记</span></span><br><span class="line">    <span class="comment">// 65535是2字节的最大值，16进制也就是0xFFFF</span></span><br><span class="line">    <span class="keyword">if</span> (utflen &gt; <span class="number">65535</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</span><br><span class="line">            <span class="string">&quot;encoded string too long: &quot;</span> + utflen + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临时缓冲区，用于非DataOutputStream的装饰输出流</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytearr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果DataOutputStream内部装饰的输出流还是是一个DataOutputStream</span></span><br><span class="line">    <span class="keyword">if</span> (out <span class="keyword">instanceof</span> DataOutputStream) &#123;</span><br><span class="line">        <span class="comment">// 强转引用类型</span></span><br><span class="line">        DataOutputStream dos = (DataOutputStream)out;</span><br><span class="line">        <span class="comment">// 使用内部的成员变量建立缓存，长度不够就进行扩容</span></span><br><span class="line">        <span class="keyword">if</span>(dos.bytearr == <span class="keyword">null</span> || (dos.bytearr.length &lt; (utflen+<span class="number">2</span>)))</span><br><span class="line">            dos.bytearr = <span class="keyword">new</span> <span class="keyword">byte</span>[(utflen*<span class="number">2</span>) + <span class="number">2</span>];</span><br><span class="line">        bytearr = dos.bytearr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 内部装饰的输出流不是DataOutputStream，就需要创建临时缓冲区</span></span><br><span class="line">        bytearr = <span class="keyword">new</span> <span class="keyword">byte</span>[utflen+<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将utf编码长度拆成2个字节，写入缓冲区</span></span><br><span class="line">    bytearr[count++] = (<span class="keyword">byte</span>) ((utflen &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    bytearr[count++] = (<span class="keyword">byte</span>) ((utflen &gt;&gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始循环每个字符，并写入缓冲区，遇到需要2个字节表示的字符时循环终止，</span></span><br><span class="line">    <span class="comment">// 也就是说如果你写入的都是ASCII编码表的简单字符，这个循环就能完成</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;strlen; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果字符范围超出ASCII编码表范围，单个字符无法用单字节表示，终止循环</span></span><br><span class="line">       c = str.charAt(i);</span><br><span class="line">       <span class="keyword">if</span> (!((c &gt;= <span class="number">0x0001</span>) &amp;&amp; (c &lt;= <span class="number">0x007F</span>))) <span class="keyword">break</span>;</span><br><span class="line">       <span class="comment">// 将单字符的字节值写入缓冲区</span></span><br><span class="line">       bytearr[count++] = (<span class="keyword">byte</span>) c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果上个循环中途被终止，那么表示字符串中有需要2或3个字节表示的字符</span></span><br><span class="line">    <span class="keyword">for</span> (;i &lt; strlen; i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提取字符</span></span><br><span class="line">        c = str.charAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是ASCII编码表范围内的，直接写入单字节</span></span><br><span class="line">        <span class="keyword">if</span> ((c &gt;= <span class="number">0x0001</span>) &amp;&amp; (c &lt;= <span class="number">0x007F</span>)) &#123;</span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) c;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符在(0x07FF - 0xFFFF]前闭后开区间，为占用3个字节的汉字，最大值为1111111111111111(共16位)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; <span class="number">0x07FF</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一个字节存4位，或运算0xC0，就是在这4位前面拼1110，最终就是1110 xxxx</span></span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) (<span class="number">0xE0</span> | ((c &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x0F</span>));</span><br><span class="line">            <span class="comment">// 第二个字节存6位，或运算0x80，就是在这6位前面拼10，最终就是10xx xxxx</span></span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) (<span class="number">0x80</span> | ((c &gt;&gt;  <span class="number">6</span>) &amp; <span class="number">0x3F</span>));</span><br><span class="line">            <span class="comment">// 第三个字节存6位，或运算0x80，就是在这6位前面拼10，最终就是10xx xxxx</span></span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) (<span class="number">0x80</span> | ((c &gt;&gt;  <span class="number">0</span>) &amp; <span class="number">0x3F</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符在(0x007F - 0x07FF]前闭后开区间，为占用2个字节的符号，最大值为11111111111(共11位)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第一个字节存前5位，或运算0xC0，就是在这5位前面拼110，最终就是110x xxxx</span></span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) (<span class="number">0xC0</span> | ((c &gt;&gt;  <span class="number">6</span>) &amp; <span class="number">0x1F</span>));</span><br><span class="line">            <span class="comment">// 第二个字节存后6位，或运算0x80，就是在这6位前面拼10，最终就是10xx xxxx</span></span><br><span class="line">            bytearr[count++] = (<span class="keyword">byte</span>) (<span class="number">0x80</span> | ((c &gt;&gt;  <span class="number">0</span>) &amp; <span class="number">0x3F</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将缓冲数据写入输出流</span></span><br><span class="line">    out.write(bytearr, <span class="number">0</span>, utflen+<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回写入的字节数</span></span><br><span class="line">    <span class="keyword">return</span> utflen + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class="p red">字符串的存储，本质上就是内部char数组的存储，由于char类型占2字节，可能是ASCII表符号，可能是其他特殊符号，也可能是汉字。对于特殊符号、汉字需要拆成多个字节存储，但每个字节只存储最多6位，空余的位做特殊标记，方便DataInputStream读取时能够识别二进制的类型。</p><h2 id="4-DataInputStream"><a href="#4-DataInputStream" class="headerlink" title="4.DataInputStream"></a>4.DataInputStream</h2><h3 id="4-1-readBoolean"><a href="#4-1-readBoolean" class="headerlink" title="4.1 readBoolean"></a>4.1 readBoolean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 读取一个字节</span></span><br><span class="line">    <span class="keyword">int</span> ch = in.read();</span><br><span class="line">    <span class="comment">// 如果按照写入的顺序进行读取，这里只可能是0或1，不可能小于0</span></span><br><span class="line">    <span class="keyword">if</span> (ch &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">    <span class="comment">// 根据是否等于0决定布尔值</span></span><br><span class="line">    <span class="keyword">return</span> (ch != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-readInt"><a href="#4-2-readInt" class="headerlink" title="4.2 readInt"></a>4.2 readInt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 逐次读取4个字节</span></span><br><span class="line">    <span class="keyword">int</span> ch1 = in.read();</span><br><span class="line">    <span class="keyword">int</span> ch2 = in.read();</span><br><span class="line">    <span class="keyword">int</span> ch3 = in.read();</span><br><span class="line">    <span class="keyword">int</span> ch4 = in.read();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果按照写入的顺序进行读取，这4个字节都不可能小于0</span></span><br><span class="line">    <span class="keyword">if</span> ((ch1 | ch2 | ch3 | ch4) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字节按照顺序升位后相加，得到最终结果</span></span><br><span class="line">    <span class="keyword">return</span> ((ch1 &lt;&lt; <span class="number">24</span>) + (ch2 &lt;&lt; <span class="number">16</span>) + (ch3 &lt;&lt; <span class="number">8</span>) + (ch4 &lt;&lt; <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-readFloat"><a href="#4-3-readFloat" class="headerlink" title="4.3 readFloat"></a>4.3 readFloat</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 读取一个int值，然后使用java自带的静态方法转化为float </span></span><br><span class="line">    <span class="keyword">return</span> Float.intBitsToFloat(readInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-readUTF"><a href="#4-4-readUTF" class="headerlink" title="4.4 readUTF"></a>4.4 readUTF</h3><p>writeUTF方法并没有真正读取，而是将自身作为参数交给静态方法处理:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readUTF(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>真正处理读取逻辑的静态方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String <span class="title">readUTF</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先读取2个字节，确定这次读取字符串的字节长度</span></span><br><span class="line">    <span class="keyword">int</span> utflen = in.readUnsignedShort();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临时数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytearr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">char</span>[] chararr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果输入流是DataInputStream，从内部成员变量取出要写入的数据</span></span><br><span class="line">    <span class="keyword">if</span> (in <span class="keyword">instanceof</span> DataInputStream) &#123;</span><br><span class="line">        DataInputStream dis = (DataInputStream)in;</span><br><span class="line">        <span class="keyword">if</span> (dis.bytearr.length &lt; utflen)&#123;</span><br><span class="line">            dis.bytearr = <span class="keyword">new</span> <span class="keyword">byte</span>[utflen*<span class="number">2</span>];</span><br><span class="line">            dis.chararr = <span class="keyword">new</span> <span class="keyword">char</span>[utflen*<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        chararr = dis.chararr;</span><br><span class="line">        bytearr = dis.bytearr;</span><br><span class="line">    <span class="comment">// 否则创建新的缓冲区</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bytearr = <span class="keyword">new</span> <span class="keyword">byte</span>[utflen];</span><br><span class="line">        chararr = <span class="keyword">new</span> <span class="keyword">char</span>[utflen];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义变量</span></span><br><span class="line">    <span class="keyword">int</span> c, char2, char3;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> chararr_count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据utflen读取字符串的全部字节，并放入bytearr数组中</span></span><br><span class="line">    in.readFully(bytearr, <span class="number">0</span>, utflen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环字符串的每一个字符，并逐次放入chararr数组中，遇到值超过ASCII编码表最大值的时候终止</span></span><br><span class="line">    <span class="keyword">while</span> (count &lt; utflen) &#123;</span><br><span class="line">        c = (<span class="keyword">int</span>) bytearr[count] &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">127</span>) <span class="keyword">break</span>;</span><br><span class="line">        count++;</span><br><span class="line">        chararr[chararr_count++]=(<span class="keyword">char</span>)c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果字符串中存在。字符值超过ASCII编码表最大值，继续循环</span></span><br><span class="line">    <span class="keyword">while</span> (count &lt; utflen) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字节转化为int</span></span><br><span class="line">        c = (<span class="keyword">int</span>) bytearr[count] &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将值右移4位</span></span><br><span class="line">        <span class="keyword">switch</span> (c &gt;&gt; <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果值c在16进制[0001 - 007F]闭区间范围内，二进制范围就是[00000001 - 01111111]</span></span><br><span class="line">            <span class="comment">// 右移4位后范围在[0000 - 0111]闭区间，也就是0～7之间，肯定是单字节</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">case</span> <span class="number">6</span>: <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                count++;</span><br><span class="line">                chararr[chararr_count++]=(<span class="keyword">char</span>)c;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果值c位移4位后是二进制1100或者1101，也就是12或13，那么肯定是2字节特殊符号的第一个字节</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>: <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">                <span class="comment">// 递增2，也就是读取进度直接跨2个字节</span></span><br><span class="line">                count += <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// 如果超出长度，那么肯定数据有问题，抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; utflen)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</span><br><span class="line">                        <span class="string">&quot;malformed input: partial character at end&quot;</span>);</span><br><span class="line">                <span class="comment">// count减1就是取符号的第一个字节，校验二进制是不是110开头的</span></span><br><span class="line">                char2 = (<span class="keyword">int</span>) bytearr[count-<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 如果第一个字节不是110开头，那么连续读的2个字节就不是一个特殊符号</span></span><br><span class="line">                <span class="keyword">if</span> ((char2 &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</span><br><span class="line">                        <span class="string">&quot;malformed input around byte &quot;</span> + count);</span><br><span class="line">                <span class="comment">// 将两个字节合并，复原成char放入chararr数组</span></span><br><span class="line">                chararr[chararr_count++]=(<span class="keyword">char</span>)(((c &amp; <span class="number">0x1F</span>) &lt;&lt; <span class="number">6</span>) |</span><br><span class="line">                                                (char2 &amp; <span class="number">0x3F</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果值c位移4位后是二进制1110，也就是14，那么肯定是3字节汉字的第一个字节</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line">                <span class="comment">// 递增3，也就是读取进度直接跨3个字节</span></span><br><span class="line">                count += <span class="number">3</span>;</span><br><span class="line">                <span class="comment">// 如果超出长度，那么肯定数据有问题，抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (count &gt; utflen)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</span><br><span class="line">                        <span class="string">&quot;malformed input: partial character at end&quot;</span>);</span><br><span class="line">                <span class="comment">// 读取第一个字节和第二个字节</span></span><br><span class="line">                char2 = (<span class="keyword">int</span>) bytearr[count-<span class="number">2</span>];</span><br><span class="line">                char3 = (<span class="keyword">int</span>) bytearr[count-<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 如果第一个字节不是1110开头，第二个字节不是10开头，那么连续读的3个字节就不是汉字，抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (((char2 &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>) || ((char3 &amp; <span class="number">0xC0</span>) != <span class="number">0x80</span>))</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</span><br><span class="line">                        <span class="string">&quot;malformed input around byte &quot;</span> + (count-<span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 将这3个字节合并成char，并放入chararr数组</span></span><br><span class="line">                chararr[chararr_count++]=(<span class="keyword">char</span>)(((c     &amp; <span class="number">0x0F</span>) &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">                                                ((char2 &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">6</span>)  |</span><br><span class="line">                                                ((char3 &amp; <span class="number">0x3F</span>) &lt;&lt; <span class="number">0</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 不是上述的情况，那么肯定输数据有问题，抛出异常</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">/* 10xx xxxx,  1111 xxxx */</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UTFDataFormatException(</span><br><span class="line">                    <span class="string">&quot;malformed input around byte &quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将char数组转化为字符串，并返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chararr, <span class="number">0</span>, chararr_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> io流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流(六) 序列化流</title>
      <link href="2020/05/16/IO%E6%B5%81-%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E8%8A%82%E6%B5%81/"/>
      <url>2020/05/16/IO%E6%B5%81-%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>ObjectInputStream即对象输入流，ObjectOutputStream即对象输出流，俩者的主要功能是实现java对象和二进制字节数组的相互转化，也就是常说的序列化与反序列化，前提是java对象必须实现<span class="p red">Serializable接口</span>。</p><h2 id="2-序列化"><a href="#2-序列化" class="headerlink" title="2.序列化"></a>2.序列化</h2><h3 id="2-1-什么时候需要序列化"><a href="#2-1-什么时候需要序列化" class="headerlink" title="2.1 什么时候需要序列化?"></a>2.1 什么时候需要序列化?</h3><span class="p red">当你想要持久化某个对象的时候</span>，可以先将对象序列化为字节数组，然后使用文件流存储到磁盘中，在必要的时候在反序列化在内存中还原对象。这个一般在早期单体项目的时候会用到，比如登录会话Session存储在内存中，项目上线重启后Session消失，总不能每次都让用户重新登录吧，因此会采用序列化将所有登录信息对象持久化。现在稍大的项目都会涉及redis等缓存中间件，所以不需要考虑上述的问题。<br><p>另外一重要使用场景就是<span class="p red">RPC框架的数据传输</span>，很多RPC框架的远程调用基于Socket长连接实现，Socket的请求接收是基于Byte数组实现，因此各服务间的远程调用携带DTO时，需要将DTO实体类进行序列化后发送、反序列化后接受。以Dubbo为例:<br><img src="/2020/05/16/IO%E6%B5%81-%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E8%8A%82%E6%B5%81/RPC%E5%BA%8F%E5%88%97%E5%8C%96.png" class="lazyload" data-srcset="/2020/05/16/IO%E6%B5%81-%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E8%8A%82%E6%B5%81/RPC%E5%BA%8F%E5%88%97%E5%8C%96.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h3 id="2-2-如何实现序列化"><a href="#2-2-如何实现序列化" class="headerlink" title="2.2 如何实现序列化?"></a>2.2 如何实现序列化?</h3><p>创建一个需要序列化的实体类，然后实现Serializable接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">613249252820610829L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br>将Book实体类序列化并存储到本地文件，然后在内存中读取恢复:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实体</span></span><br><span class="line">Book book = <span class="keyword">new</span> Book();</span><br><span class="line">       book.setId(<span class="number">17L</span>);</span><br><span class="line">       book.setName(<span class="string">&quot;Spring源码深度解析&quot;</span>);</span><br><span class="line">       book.setAuthor(<span class="string">&quot;郝佳&quot;</span>);</span><br><span class="line"></span><br><span class="line">       Book book2 = <span class="keyword">new</span> Book();</span><br><span class="line">       book2.setId(<span class="number">32L</span>);</span><br><span class="line">       book2.setName(<span class="string">&quot;Bruce Eckel&quot;</span>);</span><br><span class="line">       book2.setAuthor(<span class="string">&quot;Think in Java&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 以文件输出流为基础，创建序列化输出流</span></span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;file path&quot;</span>);</span><br><span class="line">       ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(fileOutputStream);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将对象序列化，写入指定的文件中，支持顺序写入多个</span></span><br><span class="line">       objectOutputStream.writeObject(book);</span><br><span class="line">       objectOutputStream.writeObject(book2);</span><br><span class="line">       objectOutputStream.writeInt(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 以文件输入流为基础，创建序列化输入流</span></span><br><span class="line">       FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;file path&quot;</span>);</span><br><span class="line">       ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(fileInputStream);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 按顺序反序列化多个对象，并打印</span></span><br><span class="line">       Object obj = objectInputStream.readObject();</span><br><span class="line">       Object obj2 = objectInputStream.readObject();</span><br><span class="line">       <span class="keyword">int</span> num objectInputStream.readInt();</span><br><span class="line">       System.out.println(obj.toString());</span><br><span class="line">       System.out.println(obj2.toString());</span><br><span class="line">       System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br>序列化是一个笼统的概念，具体的实现有很多种，以RPC远程调用为场景，这种设计就是约定一个规则(或者说算法)，使两个jvm进程共享一个对象结构，A服务按照这个规则序列化，B服务按照约定好的规则反序列化，最终还原对象。Java提供的序列化方式是为了避免重复造轮子，毕竟使用序列化的场景很多，但这种方式也存在缺点，例如不能跨平台，因为ObjectOutputStream的序列化规则，只有它自己和ObjectInputStream知道，因此反序列化只能依靠ObjectInputStream。</p><p>采用二进制流的形式序列化的还有很多，就是各自采用不同的算法实现。除此之外还有XML序列化，以及当前最流行的JSON序列化，这些序列化方式相对于二进制流来说更轻量级、更灵活、序列化后占用空间更少，因为序列化时无需存储对象结构信息，只需要在序列化时提供结构，当然缺点是内容易读容易被截取，敏感参数需要加密。</p><h3 id="2-2-Serializable接口"><a href="#2-2-Serializable接口" class="headerlink" title="2.2 Serializable接口"></a>2.2 Serializable接口</h3><p>当你点开这个接口的源码时，发现里面啥也没有，注释倒是一大堆。这其实就是一个标记，告诉jvm哪些类支持被原生方法序列化，看到这里我很是疑惑，jvm运行时每个对象都有被序列化的可能，并且也不会因为实现了Serializable接口就消耗额外的资源(有也是极少)，为什么不直接设计成所有类都支持序列化，这样还能减少开发者的工作量。</p><p>网上很多说序列化安全问题，也提出了一些案列，我觉得其他如json序列化也会存在这些问题。另外一个原因就是考虑到特殊类比如Thread、Socket、System等，类的创建依赖本地操作系统分配的资源，这些类的实例远程传递到另一个服务器后，即使反序列化也没有任何意义，所以在使用层面直接禁止掉。</p><p>所以类的序列化可能没有意义或者带来一些麻烦，jvm就将哪些类可以序列化的决定权交给开发者，如果开发者将某个类实现了Serializable接口，就代表你是知道风险的情况下对此类使用序列化，需要自己考虑可能出现的后果。</p><h3 id="2-4-序列化注意项"><a href="#2-4-序列化注意项" class="headerlink" title="2.4 序列化注意项"></a>2.4 序列化注意项</h3><p>如果类实现了Serializable接口，子类不需要实现接口也可以序列化，子类进行反序列化时只会还原自身的属性，<span class="p red">父类属性忽略、静态和常量忽略(serialVersionUID除外)</span>，如果子类自己的普通属性也想忽略，在属性前添加<span class="p red">transient</span>修饰符即可。</p><p>序列化与反序列化操作可能由不同的jvm进程完成，例如RPC的消费者执行序列化、提供者执行反序列化，这俩项目中关于某个序列化类的class结构就无法保证一致，因此遇到class结构不一致时，会根据具体的差异情况，选择不同的处理结果。</p><p>以上述的Book对象为例，在消费者服务简称A、在提供者服务简称B，内容不一致时，RPC调用的反序列化结果:</p><table><thead><tr><th>差异场景</th><th>处理方式</th></tr></thead><tbody><tr><td>A和B的serialVersionUID不同</td><td>InvalidClassException异常</td></tr><tr><td>A和B的class全限定名不同</td><td>ClassCastException异常</td></tr><tr><td>A将id类型改为String</td><td>ClassCastException异常</td></tr><tr><td>A将name改为bookName</td><td>序列化后，实例B的name为null</td></tr><tr><td>A删除author属性</td><td>序列化后，实例B的author为null</td></tr><tr><td>B删除author属性</td><td>无影响</td></tr><tr><td>A删除id的get方法，B删除id的set方法</td><td>id赋值无影响</td></tr></tbody></table><h3 id="2-5-serialVersionUID作用"><a href="#2-5-serialVersionUID作用" class="headerlink" title="2.5 serialVersionUID作用"></a>2.5 serialVersionUID作用</h3><p>当对象实现Serializable接口后，可以手动声明一个serialVersionUID静态常量(不强制)，并且在序列化时会记录到流中，反序列化时进行对比，如果不一致则序列化失败。这里建议手动声明，如果没有显示声明，jvm在序列化时也会参考内部结构基于算法生成一个，然而不同的jvm算法规则不一样，就存在反序列化失败的可能。</p><p>既然手动声明了，这个值就是固定的，又有什么意义呢？首先在RPC场景中，Consumer和Provider可能由不同的人维护，Provider可能会对DTO参数进行修改，比如添加一个属性，如果这个属性无关紧要，直接添加完发布就好了，就当Consumer调用时没有传这个属性，实现版本兼容。</p><p>如果这个属性非常重要，要求Consumer必须知道它的存在，那么Provider可以将serialVersionUID值+1，这样Consumer在调用后肯定异常，因为Provider反序列化参数肯定失败，迫使维护者必须更新自己的DTO，实现版本升级。</p><h2 id="3-writeObject"><a href="#3-writeObject" class="headerlink" title="3.writeObject()"></a>3.writeObject()</h2><h2 id="4-readObject"><a href="#4-readObject" class="headerlink" title="4.readObject()"></a>4.readObject()</h2>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> io流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流(五) 数组字节流</title>
      <link href="2020/05/12/IO%E6%B5%81-%E6%95%B0%E7%BB%84%E5%AD%97%E8%8A%82%E6%B5%81/"/>
      <url>2020/05/12/IO%E6%B5%81-%E6%95%B0%E7%BB%84%E5%AD%97%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>ByteArrayInputStream即<span class="p red">字节数组输入流</span>，ByteArrayOutputStream即<span class="p red">字节数组输出流</span>，这俩对象在创建时，需要提供一个<span class="p blue">byte[]</span>作为输入来源、输出目的地，所有的方法都是围绕这个<span class="p blue">byte[]</span>进行操作。<span class="p blue">byte[]</span>保存在内存的一块空间，也就是说所有操作完全不涉及磁盘文件，一般用于流数据的中转。</p><h2 id="2-ByteArrayInputStream"><a href="#2-ByteArrayInputStream" class="headerlink" title="2.ByteArrayInputStream"></a>2.ByteArrayInputStream</h2><h3 id="2-1-构造器"><a href="#2-1-构造器" class="headerlink" title="2.1 构造器"></a>2.1 构造器</h3><p>ByteArrayInputStream提供了俩个构造器，核心是要传入一个字节数组，其他的下面成员变量会详解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayInputStream</span><span class="params">(<span class="keyword">byte</span> buf[])</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.buf = buf;</span><br><span class="line">       <span class="keyword">this</span>.pos = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">this</span>.count = buf.length;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ByteArrayInputStream</span><span class="params">(<span class="keyword">byte</span> buf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.buf = buf;</span><br><span class="line">       <span class="keyword">this</span>.pos = offset;</span><br><span class="line">       <span class="keyword">this</span>.count = Math.min(offset + length, buf.length);</span><br><span class="line">       <span class="keyword">this</span>.mark = offset;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-成员变量"><a href="#2-2-成员变量" class="headerlink" title="2.2 成员变量"></a>2.2 成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心属性，字节数组</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span> buf[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前要读取的数组坐标，可以在构造器指定，默认为0</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记的位置，可以在构造器指定，默认为0</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> mark = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流中字节的数目，也可以理解为下次读取的起始坐标</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><h3 id="2-3-内部方法"><a href="#2-3-内部方法" class="headerlink" title="2.3 内部方法"></a>2.3 内部方法</h3><figure class="highlight java"><figcaption><span>读取单个字节数据:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 位与0xFF的作用就是将buf[pos]值的二进制变成32位，并且前位24补零，然后转化为int</span></span><br><span class="line"><span class="keyword">return</span> (pos &lt; count) ? (buf[pos++] &amp; <span class="number">0xff</span>) : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><figcaption><span>批量读取字节数据:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 参数校验</span></span><br><span class="line">       <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果将要读取的数组坐标，已经超出最大长度，代表读取到流末尾，返回-1</span></span><br><span class="line">       <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 计算出可读取的长度</span></span><br><span class="line">       <span class="keyword">int</span> avail = count - pos;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果想要读取的长度大于可读取长度，那么根据可读取的长度，进行读取</span></span><br><span class="line">       <span class="keyword">if</span> (len &gt; avail) &#123;</span><br><span class="line">           len = avail;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 再次校验是否已经达到流末尾</span></span><br><span class="line">       <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 拷贝数据，从buf的pos坐标开始，拷贝len个元素到b，b从off坐标开始接收拷贝过来的数据</span></span><br><span class="line">       System.arraycopy(buf, pos, b, off, len);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 下次读取的起始坐标递增</span></span><br><span class="line">       pos += len;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 返回读取的字节数量</span></span><br><span class="line">       <span class="keyword">return</span> len;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><figcaption><span>将下次要读取的坐标往后推移n位，但是不能超过最大坐标值:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算出可以后推的坐标数量</span></span><br><span class="line"><span class="keyword">long</span> k = count - pos;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想要后推的数量小于可以后推的数量</span></span><br><span class="line"><span class="keyword">if</span> (n &lt; k) &#123;</span><br><span class="line">k = n &lt; <span class="number">0</span> ? <span class="number">0</span> : n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行后推并返回后推的值</span></span><br><span class="line">pos += k;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><figcaption><span>其他方法:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果无效返回0，其他值代表有效</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> count - pos;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否支持标记</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 逻辑固定，将下次要读取的坐标进行标记</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readAheadLimit)</span> </span>&#123;</span><br><span class="line">       mark = pos;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将下次读取的坐标设置为标记值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       pos = mark;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 关闭流，由于不涉及操作系统文件描述符的释放，这里设计为模版模式，如果有特殊要求可以继承并重写此类</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="3-ByteArrayOutputStream"><a href="#3-ByteArrayOutputStream" class="headerlink" title="3.ByteArrayOutputStream"></a>3.ByteArrayOutputStream</h2><p class="p red">ByteArrayInputStream类关注读取坐标(pos)的管理，而ByteArrayOutputStream类关注字节数组容量管理，因为某个实例可能会被无限写入，构造器初始化的容量很大几率不够使用，因此需要动态扩容。</p><p class="p red">ByteArrayInputStream类还有一个特点，可以获取写入结果，或者将写入结果写入其他输出流，这是其他输出流没有的。</p><h3 id="3-1-构造器"><a href="#3-1-构造器" class="headerlink" title="3.1 构造器"></a>3.1 构造器</h3><p>ByteArrayOutputStream也提供了俩个构造器，核心时创建一个字节数据，用于后续的写入:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayOutputStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayOutputStream</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Negative initial size: &quot;</span> + size);</span><br><span class="line">       &#125;</span><br><span class="line">       buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-成员变量"><a href="#3-2-成员变量" class="headerlink" title="3.2 成员变量"></a>3.2 成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心属性，字节数组</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span> buf[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节数组的长度</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节数据最大的容量，有些虚拟机会数组中保留一些头字，所以要在最大int值上减8</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h3 id="3-3-内部方法"><a href="#3-3-内部方法" class="headerlink" title="3.3 内部方法"></a>3.3 内部方法</h3><figure class="highlight java"><figcaption><span>传入一个假定容量，如果大于当前字节数组长度，进行扩容:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - buf.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><figcaption><span>字节数组扩容:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录原始容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = buf.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将原始容量左移一位，也就是乘以2，得到新容量</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果计算出来的新容量大于最小容量，取最小容量(保证数组正好装满，不会有空余)</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最重要扩容的容量大于最大允许容量，调用hugeCapacity方法再处理</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行扩容</span></span><br><span class="line">    buf = Arrays.copyOf(buf, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><figcaption><span>字节数组容量最大值处理:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于MAX_ARRAY_SIZE就取int最大值，否则用MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><figcaption><span>单字节写入:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入前先将写入成功后的字节数组长度值，拿去检查是否需要扩容</span></span><br><span class="line">    ensureCapacity(count + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将int值转化为byte并赋值到字节数组的坐标中</span></span><br><span class="line">    buf[count] = (<span class="keyword">byte</span>) b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量+1，也代表下次写入的坐标</span></span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><figcaption><span>多字节写入:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验</span></span><br><span class="line">    <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; b.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">        ((off + len) - b.length &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入前判断写入后的长度是否超过容量</span></span><br><span class="line">    ensureCapacity(count + len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝数组</span></span><br><span class="line">    System.arraycopy(b, off, buf, count, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新设置容量</span></span><br><span class="line">    count += len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><figcaption><span>其他方法:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将写入结果写入另一个输出流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.write(buf, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置，但只是将容量标记归零，数组中的字节元素仍然存在</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字节数组拷贝一份并返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">byte</span> <span class="title">toByteArray</span><span class="params">()</span>[] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(buf, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回字节数组长度(容量)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将写入结果转化为字符串返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将写入的结果转化为字符串返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">(String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="number">0</span>, count, charsetName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将写入的结果转化为字符串返回，已废弃</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> hibyte)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, hibyte, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭流，仍然为空方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4.使用场景"></a>4.使用场景</h2><h3 id="4-1-MultipartFile"><a href="#4-1-MultipartFile" class="headerlink" title="4.1 MultipartFile"></a>4.1 MultipartFile</h3><p>有些文件的来源不一定是磁盘，还有可能来自网络，比如SpringMVC框架接收上传文件的MultipartFile类，服务端接收到文件后是没有路径这个概念的，对外提供的getInputStream()方法返回的是个ByteArrayInputStream，这种设计使文件不知道来源的情况下，也能融入到IO流体系中。</p><h3 id="4-2-多次使用"><a href="#4-2-多次使用" class="headerlink" title="4.2 多次使用"></a>4.2 多次使用</h3><p>InputStream</p><h3 id="4-3-避免创建临时文件"><a href="#4-3-避免创建临时文件" class="headerlink" title="4.3 避免创建临时文件"></a>4.3 避免创建临时文件</h3><p>之前有个需求，简单说就是某个远程服务器有一些excel文件，但是表头都是数据库字段名，前端无法通过URL直接导出(都是英文，用户也看不懂)，因此需要后端做一层处理，将这些excel表头修改为中文描述再呈现给用户。正常情况下，读取到远程excel的InputStream后，创建一个Workbook对象并进行修改，并将结果写入HttpServletResponse即可。</p><p>但是公司因为一些原因不能通过流的形式将文件下载到浏览器，必须将文件放入云服务器然后返回路径，前端只能通过路径去下载。上传到云服务器必须提供文件的InputStream，但是Workbook只能将结果写入OutputStream。一般情况下你可能会想到先写到本地，然后创建本地的InputStream再上传到云服务器，最后删除本地文件。</p><p>现在我们可以利用ByteArrayInputStream、ByteArrayOutputStream来避免这种情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 远程文件路径</span></span><br><span class="line">    String excelPath = <span class="string">&quot;excel path&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过java.net.URL类，远程获取excel的InputStream</span></span><br><span class="line">    InputStream inputStream = getInputStreamByUrl(excelPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Workbook</span></span><br><span class="line">    XSSFWorkbook xwb = <span class="keyword">new</span> XSSFWorkbook(inputStream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sheet固定为第一个，表头固定为第一行</span></span><br><span class="line">    XSSFSheet sheetAt = xwb.getSheetAt(<span class="number">0</span>);</span><br><span class="line">    XSSFRow headRow = sheetAt.getRow(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改表头内容</span></span><br><span class="line">    XSSFCell cell1 = headRow.getCell(<span class="number">0</span>);</span><br><span class="line">    cell1.setCellValue(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    XSSFCell cell2 = headRow.getCell(<span class="number">1</span>);</span><br><span class="line">    cell2.setCellValue(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将excel修改结果，写入临时输出流</span></span><br><span class="line">    ByteArrayOutputStream tempOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    xwb.write(tempOutputStream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将临时输出流 转化为临时输入流</span></span><br><span class="line">    InputStream tempInputStream = <span class="keyword">new</span> ByteArrayInputStream(tempOutputStream.toByteArray());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上传到云服务器</span></span><br><span class="line">    upload(tempInputStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> io流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流(四) 文件字节流</title>
      <link href="2020/05/08/IO%E6%B5%81-%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E6%B5%81/"/>
      <url>2020/05/08/IO%E6%B5%81-%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>FileInputStream即<span class="p red">文件输入流</span>，FileOutputStream即<span class="p red">文件输出流</span>，内部采用二进制字节数组的数据传输形式，实现本地文件的读写。这俩个对象是java.io包下最基本的对象，java大量采用装饰者模式、适配器模式对这俩个类的功能进行增强和扩展，衍生出了其他众多字节流、字符流对象，因此了解这俩对象对学习IO流非常重要。</p><h2 id="2-FileInputStream"><a href="#2-FileInputStream" class="headerlink" title="2.FileInputStream"></a>2.FileInputStream</h2><h3 id="2-1-构造器"><a href="#2-1-构造器" class="headerlink" title="2.1 构造器"></a>2.1 构造器</h3><p>FileInputStream对象提供了3个构造方法，String参数就不提了，还剩下File和FileDescriptor参数构造器，最终都是调用操作系统函数拿到一个文件描述符:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取文件路径</span></span><br><span class="line">       String name = (file != <span class="keyword">null</span> ? file.getPath() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取jvm安全管理器，进行安全检查</span></span><br><span class="line">       SecurityManager security = System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">           security.checkRead(name);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 文件路径不能为空</span></span><br><span class="line">       <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 文件是否有效</span></span><br><span class="line">       <span class="keyword">if</span> (file.isInvalid()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;Invalid file path&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建一个文件描述符，这时候描述符号为-1，也就是说符号是无效的</span></span><br><span class="line">       fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将自身注册到文件描述符对象，方便后续的关闭操作</span></span><br><span class="line">       fd.attach(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 记录文件的路径</span></span><br><span class="line">       path = name;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 内部会通过name获得操作系统的文件描述符值，并赋值给内部对象FileDescriptor的fd属性</span></span><br><span class="line">       open(name);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(FileDescriptor fdObj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取jvm安全管理器，进行安全检查</span></span><br><span class="line">       SecurityManager security = System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (fdObj == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">           security.checkRead(fdObj);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 保存文件描述符引用</span></span><br><span class="line">       fd = fdObj;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 已经得到文件描述符对象，路径就不需要了</span></span><br><span class="line">       path = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将自身注册到文件描述符对象，方便后续的关闭操作</span></span><br><span class="line">       fd.attach(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-成员变量"><a href="#2-2-成员变量" class="headerlink" title="2.2 成员变量"></a>2.2 成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对应的文件描述符对象，在构造器中会初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FileDescriptor fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用File构造器，那么还会存储文件的路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String path;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件描述符的通道，用于nio</span></span><br><span class="line"><span class="keyword">private</span> FileChannel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个流对象可能会被多个线程调用，这个创建一个对象用于synchronized关键字的锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object closeLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流关闭状态，使用volatile保证可见性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-native方法"><a href="#2-3-native方法" class="headerlink" title="2.3 native方法"></a>2.3 native方法</h3><p>FileInputStream类内部的native方法，底层都是对操作系统的IO函数进行调用，而这些IO函数都是围绕某个文件描述符操作的，虽然java层面没有作为参数传递，但native方法内部会使用this获取到文件描述符，然后作为参数调用系统IO函数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用操作系统open函数，通过路径定位到具体的文件，并将文件描述符赋值给内部FileDescriptor </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">open0</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用操作系统read函数，读取一个字节数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">read0</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用操作系统read函数，可以指定读取的起始位置off，读取的长度len，并将读取的结果放入字节数组b中，返回值代表读到的字节数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">readBytes</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用操作系统skip函数，移动输入流的当前指针，也就是说在读取时可以忽略开头的一部分字节数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用操作系统skip函数，移动输入流的当前指针，也就是说在读取时可以忽略开头的一部分字节数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用操作系统close函数，关闭系统的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">close0</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><span class="p red">关于native方法的具体逻辑，可以下载openjdk源码查看。</span><h3 id="2-4-普通方法"><a href="#2-4-普通方法" class="headerlink" title="2.4 普通方法"></a>2.4 普通方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 调用内部native open0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    open0(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用内部native read</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readBytes(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用内部native read</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readBytes(b, off, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭当前流对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断流是否已经被关闭，防止多个线程操作一个流对象，进行加锁后再判断</span></span><br><span class="line">    <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        closed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果流生成了通道，需要关闭</span></span><br><span class="line">    <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">       channel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用close0()，将关闭操作系统文件描述符的逻辑封装为一个Closeable对象，交给fd去关闭</span></span><br><span class="line">    fd.closeAll(<span class="keyword">new</span> Closeable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           close0();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取流对象对应的文件描述符对象，主要用于刷盘、判断是否有效 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileDescriptor <span class="title">getFD</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取或创建文件描述符的通道，主要用于nio操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FileChannel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel = FileChannelImpl.open(fd, path, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止应用程序没有关闭流，在GC回收此对象时再次关闭</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((fd != <span class="keyword">null</span>) &amp;&amp;  (fd != FileDescriptor.in)) &#123;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-简单使用"><a href="#2-5-简单使用" class="headerlink" title="2.5 简单使用"></a>2.5 简单使用</h3><p>对于一个稍大的文件来说，通过单字节的形式挨个读取，应用程序对系统内核的调用、内核对设备管理器的调用都太频繁，所以都会采用缓冲区批量读取:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建流</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;you file path&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件内容容器</span></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量读取</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((length = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        result.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, length));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    System.out.println(result.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-FileOutputStream"><a href="#3-FileOutputStream" class="headerlink" title="3.FileOutputStream"></a>3.FileOutputStream</h2><h3 id="3-1-内部源码"><a href="#3-1-内部源码" class="headerlink" title="3.1 内部源码"></a>3.1 内部源码</h3><p>FileOutputStream的构造器和成员变量和FileInputStream几乎一样，仅仅多了一个append概念，主要用于区分写入的形式是将原来的内容覆盖，还是在后面追加。方法也几乎一样，只不过read变成了write。</p><h3 id="3-2-简单使用"><a href="#3-2-简单使用" class="headerlink" title="3.2 简单使用"></a>3.2 简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;you file path&quot;</span>);</span><br><span class="line">    fos.write(<span class="string">&quot;hello world&quot;</span>.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> io流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流(三) 文件描述符</title>
      <link href="2020/05/08/IO%E6%B5%81-%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
      <url>2020/05/08/IO%E6%B5%81-%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>文件描述符即FileDescriptor类，当应用程序调用linux的open函数后，会返回一个非负整数，这个数字代表了某个文件的标示(linux系统)，FileDescriptor类对这个数字进行了一层封装，除了保存这个数字外还提供了其他的方法。</p><p>后续可以将此类内部的符号作为参数，再次调用操作系统的IO读写函数，完成设备的IO操作。在Java中我们不能直接调用FD的相关方法，而是通过它创建一个FileInputStream或FileOutputStream对象，通过调用流对象完成IO操作。</p><h2 id="2-构造器与常量"><a href="#2-构造器与常量" class="headerlink" title="2.构造器与常量"></a>2.构造器与常量</h2><h3 id="2-1-构造器"><a href="#2-1-构造器" class="headerlink" title="2.1 构造器"></a>2.1 构造器</h3><p>FileDescriptor类共有俩个构造器，对外仅提供了一个空参数的构造器，另一个构造器仅供类内部使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空构造器，描述符号写死</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       fd = -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义描述符号的构造器，不对外提供</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">FileDescriptor</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.fd = fd;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p class="p red">由此看出java代码层面只能创建一个描述符号值为-1的实例，但是linux颁发的描述符号都是非负整数，也就是说创建的实例是个无效的描述符，至于为什么这样设计，后面会讲。</p><h3 id="2-2-标准输入-输出常量"><a href="#2-2-标准输入-输出常量" class="headerlink" title="2.2 标准输入/输出常量"></a>2.2 标准输入/输出常量</h3><p>FileDescriptor类通过私有构造器创建了三个静态常量实例，并且指定了描述符号的值。在linux系统中默认打开一些文件描述符，其中0固定为<span class="p red">键盘标准输入</span>、1固定为<span class="p red">屏幕标准输出</span>、2固定为<span class="p red">屏幕错误输出</span>。对此java也创建了三个固定的描述符对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准输入(键盘)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FileDescriptor in = <span class="keyword">new</span> FileDescriptor(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准输出(屏幕)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FileDescriptor out = <span class="keyword">new</span> FileDescriptor(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误输出(屏幕)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FileDescriptor err = <span class="keyword">new</span> FileDescriptor(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><br>常量in实现了键盘的输入功能，这个很少用就不讲了，接下来我们通过代码的形式，基于out常量实现一个屏幕的输出操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于out文件描述符，创建一个屏幕输出流</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(FileDescriptor.out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入输出的内容</span></span><br><span class="line">    fos.write(<span class="string">&quot;来一杯冰镇可乐&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭流</span></span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class="p red">main方法执行完毕后，可以在控制台看到打印的结果，这个效果和我们常用的System.out.println()方法一致，System对象内部就是通过out常量创建一个FileOutputStream，考虑到性能问题，还会继续封装成BufferedOutputStream对象，最后再封装成PrintStream实现。</p><p class="p red">常量err和out几乎一样，因为是错误输出，所以在控制台打印的颜色是红色。</p><h2 id="3-成员变量"><a href="#3-成员变量" class="headerlink" title="3.成员变量"></a>3.成员变量</h2><h3 id="3-1-fd变量"><a href="#3-1-fd变量" class="headerlink" title="3.1 fd变量"></a>3.1 fd变量</h3><p>fd即文件描述符号值，除了上述的三种特殊情况可以提前知道符号值，当我们想要对linux的IO设备进行读写时，必须调用open函数获取对应的文件描述符号，因为linux系统的所有IO函数都是基于文件描述符号操作的。</p><p>以FileInputStream为例，内部的native open0()方法会调用linux的open函数拿到文件描述符号，并赋值给自己的fd属性，也就是说fd只能通过底层的C语言进行赋值。个人猜测，这么设计是防止开发人员<span class="p red">随意设置文件描述符号值</span>进行IO操作，引起不必要的麻烦。</p><h3 id="3-2-parent"><a href="#3-2-parent" class="headerlink" title="3.2 parent"></a>3.2 parent</h3><p>用于记录哪些FileOutputStream实例是基于自己创建的，第一个赋值在parent属性中，主要用于后续的流关闭操作。</p><h3 id="3-3-otherParents"><a href="#3-3-otherParents" class="headerlink" title="3.3 otherParents"></a>3.3 otherParents</h3><p>用于记录哪些FileOutputStream实例是基于自己创建的，除了第一个，后续的就添加到otherParents集合中，主要用于后续的流关闭操作。</p><h3 id="3-4-closed"><a href="#3-4-closed" class="headerlink" title="3.4 closed"></a>3.4 closed</h3><p>默认为true，当调用classAll()方法后变为false，如果文件描述符已关闭，就无法再进行IO操作了。</p><h2 id="4-内部方法"><a href="#4-内部方法" class="headerlink" title="4.内部方法"></a>4.内部方法</h2><h3 id="4-1-valid"><a href="#4-1-valid" class="headerlink" title="4.1 valid"></a>4.1 valid</h3><p>判断一个文件描述符是否有效，就是看符号值是否为-1，在java层面new出来的实例都是无效的，需要借助native方法调用操作系统open函数对其再次赋值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fd != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-sync"><a href="#4-2-sync" class="headerlink" title="4.2 sync"></a>4.2 sync</h3><p>我们都知道Linux的磁盘IO，在内核中默认使用PageCache缓冲，sync方法就是调用操作系统函数强制刷盘。</p><h3 id="4-3-attach"><a href="#4-3-attach" class="headerlink" title="4.3 attach"></a>4.3 attach</h3><p>当我们基于某个FileDescriptor对象构造一个FileInputStream实例时，会调用FileDescriptor对象的attach方法，将自己注册进去。主要用于后续的流关闭操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能会有多个流对象基于此实例进行创建，因此要保证线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Closeable c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果parent为空，说明是第一个利用此实例创建的FileInputStream对象</span></span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent = c;</span><br><span class="line">    <span class="comment">// 后续基于此实例创建的FileInputStream对象，放入集合中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (otherParents == <span class="keyword">null</span>) &#123;</span><br><span class="line">        otherParents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        otherParents.add(parent);</span><br><span class="line">        otherParents.add(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        otherParents.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-closeAll"><a href="#4-4-closeAll" class="headerlink" title="4.4 closeAll"></a>4.4 closeAll</h3><p>当一个FileInputStream实例(后面简称FIS)调用close方法时，其实是调用内部的FileDescriptor对象的closeAll方法，为了防止多个FileInputStream实例同时调用，也使用关键字保证线程安全:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">closeAll</span><span class="params">(Closeable releaser)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 只有未关闭状态才会执行关闭操作</span></span><br><span class="line">       <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 标记为已关闭</span></span><br><span class="line">           closed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 记录是否出现了异常</span></span><br><span class="line">           IOException ioe = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 将传进来的对象关闭</span></span><br><span class="line">           <span class="keyword">try</span> (Closeable c = releaser) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// otherParents集合中如果存在元素，统统关闭</span></span><br><span class="line">               <span class="keyword">if</span> (otherParents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (Closeable referent : otherParents) &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           referent.close();</span><br><span class="line">                       &#125; <span class="keyword">catch</span>(IOException x) &#123;</span><br><span class="line">                           <span class="comment">// 如果关闭过程中出现异常，记录到ioe中</span></span><br><span class="line">                           <span class="keyword">if</span> (ioe == <span class="keyword">null</span>) &#123;</span><br><span class="line">                               ioe = x;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               ioe.addSuppressed(x);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span>(IOException ex) &#123;</span><br><span class="line">               <span class="comment">// 如果关闭过程中出现异常，记录到ioe中</span></span><br><span class="line">               <span class="keyword">if</span> (ioe != <span class="keyword">null</span>)</span><br><span class="line">                   ex.addSuppressed(ioe);</span><br><span class="line">               ioe = ex;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">// 如果catch到异常则抛出</span></span><br><span class="line">               <span class="keyword">if</span> (ioe != <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">throw</span> ioe;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个方法很有意思，当FileInputStream实例使用完毕后，调用自己的close进行流关闭，并且会将关闭自己的逻辑封装成一个Closeable，作为参数调用内部FileDescriptor实例的closeAll方法。</p><p>也就是说当多个FileInputStream实例引用一个FileDescriptor实例时，其中一个FileInputStream实例执行了close方法，其他的FileInputStream实例也就无法进行读写了，因为操作系统已经把这个文件描述符关闭了。</p><p>closeAll方法中并未对parent进行关闭，这个我很疑惑，但这不重要。重点是参数releaser内部包含了Linux系统close方法的调用，在操作系统层面已经将文件描述符关闭了，java层面无论如何都不可能再读写的。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>FileDescriptor对象是操作系统和java流对象之间的桥梁，以linux系统为例，FileDescriptor的本质就是记录linux系统open函数返回的符号，这个符号的本质就是linux系统给文件发送的临时索引，通过这个临时身份证就可以找到对应的文件，java流对象就可以和linux进行函数调用，完成IO操作。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> io流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流(二) Java中的传统IO</title>
      <link href="2020/05/07/IO%E6%B5%81-Java%E4%B8%AD%E7%9A%84%E4%BC%A0%E7%BB%9FIO/"/>
      <url>2020/05/07/IO%E6%B5%81-Java%E4%B8%AD%E7%9A%84%E4%BC%A0%E7%BB%9FIO/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>Java传统IO是指java.io包中，以InputStream、OutputStream及其子类为代表的<span class="p red">字节流</span>，和Reader、Writer及其子类为代表的<span class="p red">字符流</span>，外加其他辅助类(文件类、异常类等)为基础，通过对操作系统函数的封装，形成的一套对IO设备的读写功能。</p><p>java.io包是Java提供最早的IO处理类，无论是字符流还是字节流，均通过<span class="p red">同步阻塞</span>的方式读写数据，也就是我们经常说的BIO，因此可以将java.io包视为传统IO。</p><h2 id="2-流的基础知识"><a href="#2-流的基础知识" class="headerlink" title="2.流的基础知识"></a>2.流的基础知识</h2><h3 id="2-1-流对象到底是什么"><a href="#2-1-流对象到底是什么" class="headerlink" title="2.1 流对象到底是什么?"></a>2.1 流对象到底是什么?</h3><p>简单说Java中的流对象就是一个<span class="p red">传送带</span>，传送带的一端连接操作系统内核，另一端连接我们的Java业务代码。Java项目作为运行在操作系统上的应用程序，是无法直接访问IO设备的，当我们想要从磁盘等地方读写数据时，只能通过调用内核函数来间接操作，流的作用就是封装内核调用等底层复杂操作，帮助开发者实现数据在内核和业务代码之间传送。</p><p>以文件读写为例，当我们想要从本地磁盘读取数据时，需要创建一个传送带(FileInputStream)并指定文件的路径，二进制数字就可以从内核不断的流向Java应用程序:<br><img src="/2020/05/07/IO%E6%B5%81-Java%E4%B8%AD%E7%9A%84%E4%BC%A0%E7%BB%9FIO/%E6%B5%81%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%81%E5%B8%A6.png" class="lazyload" data-srcset="/2020/05/07/IO%E6%B5%81-Java%E4%B8%AD%E7%9A%84%E4%BC%A0%E7%BB%9FIO/%E6%B5%81%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%81%E5%B8%A6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h3 id="2-2-流的方向"><a href="#2-2-流的方向" class="headerlink" title="2.2 流的方向"></a>2.2 流的方向</h3><p>流按照方向可分为<span class="p red">输入流</span>、<span class="p red">输出流</span>，这种划分是站在内存角度去定义的。数据从IO设备流向内存的过程就是流的输入过程，例如InputStream、Reader的子类，用于应用程序从设备读取数据；数据从内存流向IO设备的过程就是流的输出过程，例如OutputStream、Writer的子类，用于应用程序向设备输出数据。</p><p>由此可以看出传统IO类的读写是单向的，输入流只能读取数据，输出流只能写入数据，读取和写入需要创建不同的流对象去完成:<br><img src="/2020/05/07/IO%E6%B5%81-Java%E4%B8%AD%E7%9A%84%E4%BC%A0%E7%BB%9FIO/%E5%8D%95%E5%90%91%E8%AF%BB%E5%86%99.png" class="lazyload" data-srcset="/2020/05/07/IO%E6%B5%81-Java%E4%B8%AD%E7%9A%84%E4%BC%A0%E7%BB%9FIO/%E5%8D%95%E5%90%91%E8%AF%BB%E5%86%99.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h3 id="2-3-流的单位"><a href="#2-3-流的单位" class="headerlink" title="2.3 流的单位"></a>2.3 流的单位</h3><p>流按照单位可分为<span class="p red">字节流</span>、<span class="p red">字符流</span>，字节流就是所有的IO操作都基于字节，字节流就是所有的IO操作都基于字符。对于字节流来说很好理解，因为所有的IO设备都只认二进制值，字节就是由8个二进制值组成的。而字符与二进制值不存在直接的关系，因此Java中每个字节流在创建的时候必须指定一个编码集，用于维护二进制值与字符的关系。</p><p>如果你读写的内容完全来自于<span class="p red">ASCll表(美国信息互换标准代码)</span>包含的符号组成，那么字节流就可以完成读写功能，因为ASCll表中的符号可以用0到127来表示，单个字节就可以表示一个符号，每读取一个字节都可以按照ASCll表转化为符号，每写入一个字节先通过ASCll表转化为字节再写入。</p><p>如果你读写的内容包含<span class="p red">汉字</span>、<span class="p red">特殊符号</span>(♬、✿、★、♨等)，单个字节是无法进行表示的，必须借助编码集实现。每个编码集都有一个映射表，用于记录哪几个字节值代表哪个汉字或特殊符号，例如UTF-8编码集中，汉字<span class="p blue">‘云’</span>对应的编码为<span class="p blue">‘&amp;#x4E91;’</span>，编码的每个符号在ASCll表都存在，那么汉字就可以借助编码集顺理成章的转化为多个字节，因此你可以理解为字符流是对字节流的封装。</p><h3 id="2-4-流的处理类型"><a href="#2-4-流的处理类型" class="headerlink" title="2.4 流的处理类型"></a>2.4 流的处理类型</h3><p>流按照是否与IO设备直接连接，可分为<span class="p red">节点流</span>、<span class="p red">处理流</span>。节点流就是直接指定一个地点(磁盘、内存条等)进行读写，处理流并不直连IO设备，而是采用装饰器模式对节点流进行包装，在对外提供的方法不变的前提下，对原有功能进行增强。</p><p>以FileInputStream和BufferedImputStream为例，FileInputStream属于节点流，因为它指定文件路径后就可以直接读取，而BufferedImputStream是对它的装饰包装，当调用BufferedImputStream的read方法读取一个字节时，内部调用FileInputStream的read方法读取8192个字节将缓冲区填满，后续再读字节时就可以直接从缓冲区返回，直到内存读完。这样就减少了和操作系统的IO次数，实现对read方法的增强。</p><h3 id="2-5-随机-顺序读写"><a href="#2-5-随机-顺序读写" class="headerlink" title="2.5 随机/顺序读写"></a>2.5 随机/顺序读写</h3><p>暂无</p><h2 id="3-字节流"><a href="#3-字节流" class="headerlink" title="3.字节流"></a>3.字节流</h2><h3 id="3-1-InputStream"><a href="#3-1-InputStream" class="headerlink" title="3.1 InputStream"></a>3.1 InputStream</h3><p>InputStream是所有字节输入流的顶层类，定义了从IO设备读取字节到内存的一些基本、抽象方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于确定要使用的最大缓冲区大小，调用skip方法时使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SKIP_BUFFER_SIZE = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取方法，需要子类重写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取参数数组大小的字节，并将读取结果填充到参数中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取指定长度的字节，并将读取结果填充到参数数组中，从off坐标开始，填充len位</span></span><br><span class="line">    <span class="comment">// 由于方法是循环读取，每次都需要与内核交互一次，因此效率很低，子类通常会重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过n位字节，最多不能超过MAX_SKIP_BUFFER_SIZE</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回读取的目标，一共有多少字节，需要子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭流</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记当前读取的位置，方法为空需要子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将读取的坐标重置到mark的位置，方法默认抛异常需要子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;mark/reset not supported&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否支持mark，默认不支持，子类根据需要重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><br><b>① read()方法明明是读取一个字节，为什么返回值是int类型呢?</b><br>首先，Java返回int类型是因为操作系统(例如Linux)提供的read函数返回的就是int类型。假设Linux系统的read()函数返回的是字节，那么返回的值范围就是[-128,127]，这样Java在调用时就无法判断流是否已读到末尾，因为-128到127的任何一个值都可能是读到的字节值，没有多余的值去告诉Java已经读完了，因此Linux的read()函数返回字节无法实现单字节读取。</p><p>至于Linux为什么不用null来表示已读完，可能是因为POXIS规范吧。Linux采用高位补零的方式将读取的byte值转化为int并返回，因此无论读取的字节值是多少，再高位补零后永远不可能是负数，当字节已经读到末尾时再读取则返回-1。在Java代码中拿到int值需要高位抹零(int转byte)得到真正的字节值:<br><img src="/2020/05/07/IO%E6%B5%81-Java%E4%B8%AD%E7%9A%84%E4%BC%A0%E7%BB%9FIO/read%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9Eint.png" class="lazyload" data-srcset="/2020/05/07/IO%E6%B5%81-Java%E4%B8%AD%E7%9A%84%E4%BC%A0%E7%BB%9FIO/read%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9Eint.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><br><b>② 字节流如何重复读取数据?</b><br>mark、reset、markSupported三个方法都是为了字节流能重复读取而设计的，默认是不支持的，并且在InputStream层面并没有规定markSupported返回false对另外俩个方法有什么影响，子类在重写这三个方法来实现重复读取时，可以随意设计。具体的重写思路:<br><img src="/2020/05/07/IO%E6%B5%81-Java%E4%B8%AD%E7%9A%84%E4%BC%A0%E7%BB%9FIO/%E6%B5%81%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%8F%96.png" class="lazyload" data-srcset="/2020/05/07/IO%E6%B5%81-Java%E4%B8%AD%E7%9A%84%E4%BC%A0%E7%BB%9FIO/%E6%B5%81%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%8F%96.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><br><b>③ 流为什么要关闭?</b><br>以Linux系统为例，大多数流对象的IO操作都是基于文件描述符进行的，因此流对象的创建通常要在Linux系统中通过open函数申请一个fd。Linxu系统对单个进程或整个系统所能打开的fd数量有限制，超过限制数会open失败，即使调高上限值，如果流使用完毕不关闭fd也会造成内存浪费，因为每个fd在内核中都会单独分配一个打开文件句柄。</p><h3 id="3-2-OutputStream"><a href="#3-2-OutputStream" class="headerlink" title="3.2 OutputStream"></a>3.2 OutputStream</h3><p>OutputStream是所有字节输出流的顶层类，定义了向IO设备写入字节的一些基本、抽象方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入单个字节，参数是int类型，估计是想和read对应上吧</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入多个字节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        write(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入多个字节，指定范围，内部还是for循环一个个写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭流</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出流相比较输入流要简单很多，flush()方法的作用是刷新输出流，或者说清空输出流，这个清空不是直接删掉，而是把它挪到该去的地方。很多带缓冲概念的子类会重写这个方法，将缓存的数据手动刷回对应的IO设备中，例如常用的BufferedOutputStream。不存在缓存概念的例如FileOutputStream、ByteArrayOutputStream等就不会重写，因为没地方可以刷。</p><h3 id="3-3-汉字处理"><a href="#3-3-汉字处理" class="headerlink" title="3.3 汉字处理"></a>3.3 汉字处理</h3><p>我们经常说读取中文内容需要用字符流，使用字节流会出现乱码。首先，只要包涵中文的内容，无论读还是写都必定会涉及到<span class="p red">字符集</span>，其次字节流并不是每次读取包含汉字的内容，都会出现乱码，要分情况看待。</p><p>例如使用文件字节流FileInputStream完成对中文内容进行读取，需要一次性读取整个文件的所有字节，并将结果存入某个字节数组中，最后手动指定<span class="p red">字符集</span>转化为String:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建输入流</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/lvtao/Downloads/test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次性读取数据，放入数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[fileInputStream.available()];</span><br><span class="line">        fileInputStream.read(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定字符集并转String</span></span><br><span class="line">        String result = <span class="keyword">new</span> String(bytes, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印读取结果</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br>如果文件的数据量较小，单次读完没啥问题，但很多场景不得不分段读取，比如文件太大需要读取一批处理一批，这时候需要按上面的方式得到多段String。以UTF-8编码集为例，一个汉字占用3个字节，如果在分批读取时，某个汉字对应的3个字节被分割在俩段分别读取，这时候就会出现乱码:<br><img src="/2020/05/07/IO%E6%B5%81-Java%E4%B8%AD%E7%9A%84%E4%BC%A0%E7%BB%9FIO/%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E5%8F%96%E4%B9%B1%E7%A0%81.png" class="lazyload" data-srcset="/2020/05/07/IO%E6%B5%81-Java%E4%B8%AD%E7%9A%84%E4%BC%A0%E7%BB%9FIO/%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E5%8F%96%E4%B9%B1%E7%A0%81.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p class="p red">输出流执行写入操作仍然避免不了字符集，只不过String的getBytes方法使用操作系统默认字符集而已。总的来说字节流没有字符集的概念，也不关心读写的内容到底有没有汉字、特殊符号，所有操作只认字节。因此面对包含汉字的内容，要么手动处理字节和汉字的转化(可能乱码)，要么使用字符流解决。</p><h2 id="4-字符流"><a href="#4-字符流" class="headerlink" title="4.字符流"></a>4.字符流</h2><p>字符流与字节流的不同之处在于，<span class="p red">字符流每次读取至少是一个字符</span>，这个字符可能是数字、字母、特殊符号、汉字等，但绝对不会出现字节流那种，把一个汉字或特殊符号对应的多个字节拆成多分的情况，因此字符流没有乱码这一说(前提读和写使用的是同一种编码集)。</p><h3 id="4-1-Reader"><a href="#4-1-Reader" class="headerlink" title="4.1 Reader"></a>4.1 Reader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">implements</span> <span class="title">Readable</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象，用于保证部分操作的线程安全</span></span><br><span class="line">    <span class="keyword">protected</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空构造器，将自身作为锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定一个对象作为锁对象</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Reader</span><span class="params">(Object lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取多个字符到CharBuffer中，内部调用抽象read方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(java.nio.CharBuffer target)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取单个字符，内部调用抽象read方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取多个字符，内部调用抽象read方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read(cbuf, <span class="number">0</span>, cbuf.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取多个字节，需要子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最多跳过的缓冲数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSkipBufferSize = <span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> skipBuffer[] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重复读取那一套</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重复读取那一套</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readAheadLimit)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;mark() not supported&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重复读取那一套</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;reset() not supported&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭流</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-Writer"><a href="#4-2-Writer" class="headerlink" title="4.2 Writer"></a>4.2 Writer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">Closeable</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] writeBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITE_BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object lock;<span class="function"><span class="keyword">protected</span> <span class="title">Writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Writer</span><span class="params">(Object lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (writeBuffer == <span class="keyword">null</span>)&#123;</span><br><span class="line">                writeBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[WRITE_BUFFER_SIZE];</span><br><span class="line">            &#125;</span><br><span class="line">            writeBuffer[<span class="number">0</span>] = (<span class="keyword">char</span>) c;</span><br><span class="line">            write(writeBuffer, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        write(cbuf, <span class="number">0</span>, cbuf.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        write(str, <span class="number">0</span>, str.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">char</span> cbuf[];</span><br><span class="line">            <span class="keyword">if</span> (len &lt;= WRITE_BUFFER_SIZE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (writeBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    writeBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[WRITE_BUFFER_SIZE];</span><br><span class="line">                &#125;</span><br><span class="line">                cbuf = writeBuffer;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">            &#125;</span><br><span class="line">            str.getChars(off, (off + len), cbuf, <span class="number">0</span>);</span><br><span class="line">            write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Writer <span class="title">append</span><span class="params">(CharSequence csq)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (csq == <span class="keyword">null</span>)</span><br><span class="line">            write(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            write(csq.toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Writer <span class="title">append</span><span class="params">(CharSequence csq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        CharSequence cs = (csq == <span class="keyword">null</span> ? <span class="string">&quot;null&quot;</span> : csq);</span><br><span class="line">        write(cs.subSequence(start, end).toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Writer <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        write(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-汉字处理"><a href="#4-3-汉字处理" class="headerlink" title="4.3 汉字处理"></a>4.3 汉字处理</h3><p>常用的字符流中，除了CharArrayReader、CharArrayWriter这俩实现类，完全就是在内存中读写字符，根本不会涉及和字节的转换，其他实现类的最底层都是对StreamEncoder、StreamDecoder类的装饰。</p><p>这俩个类内部又是对InputStream、OutputStream的装饰，<span class="p red">因此是最接近字节流的字符流</span>。每次调用InputStream的read方法后，会将字节解码成汉字再返回。每次写入包含汉字的内容时，会编码成字节在调用OutputStream的write方法。</p><p>StreamEncoder与StreamDecoder的底层通过Charset对象，完成对汉字、特殊符号的读写。我们可以写个Demo看看Charset是怎么处理汉字的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个Charset抽象类的UTF-8字符集实现类</span></span><br><span class="line">    Charset charset = Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1创建UTF-8字符集的编码对象</span></span><br><span class="line">    CharsetEncoder encoder = charset.newEncoder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2要写入的内容</span></span><br><span class="line">    String text = <span class="string">&quot;1949年10月1日,中华人民共和国成立&quot;</span>;</span><br><span class="line">    CharBuffer charBuffer = CharBuffer.wrap(text.toCharArray());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.3将包含汉字的字符串，编码成字节，供后续写入</span></span><br><span class="line">    ByteBuffer encodeByteBuffer = encoder.encode(charBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1创建UTF-8字符集的解码对象</span></span><br><span class="line">    CharsetDecoder decoder = charset.newDecoder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2读取字节内容并转化为字符</span></span><br><span class="line">    CharBuffer decoderCharBuffer = decoder.decode(encodeByteBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3打印读取结果</span></span><br><span class="line">    System.out.println(decoderCharBuffer.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p class="p red">Charset对象本质上就是对操作系统的字符集功能进行封装，Java中创建一个字符流对象需要指定一个字符集，并且会调用操作系统函数，检查字符集名称存不存在，如果没有指定，会使用当前操作系统的默认字符集。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> io流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流(一) Linux系统中的IO</title>
      <link href="2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/"/>
      <url>2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>Java的各种IO流对象，都是在操作系统提供的IO功能基础上进行设计的，因此越过操作系统去研究Java的IO流有点不切实际，通常我们的服务都是部署在Linux系统中，因此研究Linux中的IO原理，是学习Java IO流的基础。</p><h2 id="2-驱动程序"><a href="#2-驱动程序" class="headerlink" title="2.驱动程序"></a>2.驱动程序</h2><h3 id="2-1-什么是驱动程序"><a href="#2-1-什么是驱动程序" class="headerlink" title="2.1 什么是驱动程序"></a>2.1 什么是驱动程序</h3><p>驱动程序是比操作系统更为底层的技术，也是最接近硬件的软件，换句话说就是连接硬件和操作系统的桥梁，它的主要作用是<span class="p red">驱动各种硬件完成自身支持的功能。</span></p><p>以最常用的Window系统为例，重装系统后需要通过鲁大师、驱动精灵等装网卡、显卡等驱动，否则无法连接网络、无法玩LOL等网络游戏。以MacOS为例，连接有线网需要购买转接头，并下载对应厂商提供的转接头驱动程序，否则无法连接。</p><h3 id="2-2-与linux关系"><a href="#2-2-与linux关系" class="headerlink" title="2.2 与linux关系"></a>2.2 与linux关系</h3><p>计算机中有很多硬件，以硬盘为例，又可分为机械硬盘和固态硬盘，每种类型的硬盘又有不同的厂商生产出不同的版本型号，其中每一种情况都可能对应一个驱动软件。而Linux系统在设计IO子系统时不可能将所有情况都考虑并进行兼容，因此在内核提供了一套驱动开发标准，硬件厂商依据此标准开发自己的驱动软件，使用者需要根据对应的硬件下载对应驱动程序，</p><p class="p red">Linux系统通过对驱动的调用，完成对IO设备的控制。</p><p></p><p>因此驱动程序说直白点就是对硬件进行抽象，屏蔽了同一类型硬件但不同版本型号的差异，并提供统一标准API给Linux内核调用，如图:<br><img src="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E4%B8%8ELinux%E5%85%B3%E7%B3%BB.png" class="lazyload" data-srcset="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E4%B8%8ELinux%E5%85%B3%E7%B3%BB.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h2 id="3-虚拟文件系统"><a href="#3-虚拟文件系统" class="headerlink" title="3.虚拟文件系统"></a>3.虚拟文件系统</h2><p>驱动程序虽然摒弃了同一硬件类型不同版本型号的差异，但是不同的硬件在调用层面仍然有差别，而Linux系统通过<span class="p red">一切皆文件</span>的设计理念，将所有硬件设备抽象成文件子系统，硬盘、网卡等设备都会实现文件子系统的标准接口，然后通过虚拟文件系统对应用程序进行呈现:<br><img src="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" class="lazyload" data-srcset="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p class="p red">Linux系统虽然将一切看作都文件，但又将文件这个抽象概念分成普通文件、目录文件、链接文件和设备文件，不同的类型提供的操作类型也不同，例如设备文件不能像普通文件那样支持复制、粘贴等功能。</p><h3 id="3-1-文件子系统"><a href="#3-1-文件子系统" class="headerlink" title="3.1 文件子系统"></a>3.1 文件子系统</h3><p>暂无</p><!-- 文件子系统包括EXT3、EXT4、XFS、ZFS等，这里不具体研究每个子系统的实现原理，重点放在多数文件子系统都会实现的PageCache缓存机制。PageCache是通过将磁盘中的数据缓存到内存中，以此减少磁盘I/O操作，从而提高性能。在实际调用过程中，除非显示的标记<span class='p red'>O_DIRECT</span>，所有访问都会经过PageCache。 --><h3 id="3-1-网络子系统"><a href="#3-1-网络子系统" class="headerlink" title="3.1 网络子系统"></a>3.1 网络子系统</h3><p>暂无</p><!-- 网络子系统包括NFS、samba等。 --><h3 id="3-1-其他子系统"><a href="#3-1-其他子系统" class="headerlink" title="3.1 其他子系统"></a>3.1 其他子系统</h3><h2 id="4-文件描述符"><a href="#4-文件描述符" class="headerlink" title="4.文件描述符"></a>4.文件描述符</h2><p>在linux系统中，设备也是以文件的形式存在，要对该设备进行操作就必须先打开这个文件，打开这个文件就会获得这个文件描述符，它是个很小的正整数，可以看作是一个索引值，指向内核为每一个进程所维护的、该进程打开文件的记录表。</p><h3 id="4-1-描述符结构"><a href="#4-1-描述符结构" class="headerlink" title="4.1 描述符结构"></a>4.1 描述符结构</h3><p><img src="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>首先每个进程都有一张<span class="p red">文件描述符表</span>，用于记录此进程打开的文件，同一个文件可能会被不同的进程打开，也有可能会被同一进程的不同线程打开，总之每次打开得到的都是不同的文件描述符。同时Linux会对每个进程的打开文件数进行限制，一般是1024个(可以通过命令修改)。</p><p>每个文件描述符在打开文件表都对应一个<span class="p red">打开文件句柄</span>，这个句柄记录了此次打开的一些状态信息，这里重点说下关联操作属性(file_operations)，此属性作为指针指向一张<span class="p red">函数操作表</span>，函数操作表中有当前文件支持的所有操作函数。普通文件、设备文件等不同类型的文件，指向的函数操作表也不同，因此通过这个属性可以将不同类型的文件的操作区分开。</p><p>i-node表维护了文件的<span class="p red">具体信息</span>，每个文件在被进程打开后都会将结构信息加载到i-node表中，如果一个文件被多次打开也只会加载一次，与打开文件句柄是一对多的关系。也就是说应用程序通过内核函数操作文件时，都是基于i-node进行操作。</p><h3 id="4-2-标准描述符"><a href="#4-2-标准描述符" class="headerlink" title="4.2 标准描述符"></a>4.2 标准描述符</h3><table><thead><tr><th>描述符</th><th>名称</th><th>对应设备</th></tr></thead><tbody><tr><td>0</td><td>标准输入流</td><td>键盘</td></tr><tr><td>1</td><td>标准输出流</td><td>显示屏</td></tr><tr><td>2</td><td>标准错误流</td><td>显示屏</td></tr></tbody></table><p>当我们在Linux环境中启动一个进程，会自动向此进程的文件描述符表中添加这三个描述符(值固定)，换句话说，进程如果想要对键盘、显示屏进行IO操作，是不需要手动打开的，Linux系统已经帮我们准备好了。</p><p>例如使用nohup命令运行Java包时，会在命令后添加<span class="p red">xxx.log 2>&1</span>，这个后缀的意思就是将<span class="p blue">标准错误输出</span>重定向到<span class="p blue">标准输出流</span>、然后将<span class="p blue">标准输出流</span>重定向到xxx.log文件，说白了就是让java的日志或print输出到指定的日志文件。</p><h3 id="4-3-指针移动"><a href="#4-3-指针移动" class="headerlink" title="4.3 指针移动"></a>4.3 指针移动</h3><p>在文件描述符对应的打开文件句柄中，有个当前偏移量属性，记录了文件读写操作的位置。以读取为例，假设某个文件共2000个字节，初始偏移量就是0，每读取一个字节就将偏移量值加1，读取n个字节就将偏移量加n，直到偏移量递增到1999(从0开始偏移)为止读取结束，后续再调用返回结束标志:</p><h2 id="5-IO函数"><a href="#5-IO函数" class="headerlink" title="5.IO函数"></a>5.IO函数</h2><h3 id="5-1-open"><a href="#5-1-open" class="headerlink" title="5.1 open"></a>5.1 open</h3><p>open函数是最基本的函数，打开一个文件或设备，如果打开成功则返回一个文件描述符值，失败则返回-1。有了文件描述符值就可以对文件或设备进行操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pathname: 文件路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// flags参数用于控制打开文件的行为标志:</span></span><br><span class="line"><span class="comment">// O_RDONLY: 以只读的方式打开</span></span><br><span class="line"><span class="comment">// O_WRONLY: 以只写的方式打开</span></span><br><span class="line"><span class="comment">// O_RDWR: 以可读、可写的方式打开</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mode为附带参数，效果与flags并存，可以在打开时提供额外的选项:</span></span><br><span class="line"><span class="comment">// O_CREAT: 文件不存在则创建文件</span></span><br><span class="line"><span class="comment">// O_EXCL: 如果同时指定了O_CREAT，且文件已经存在，则出错</span></span><br><span class="line"><span class="comment">// O_TRUNC: 如果文件存在，则清空文件内容</span></span><br><span class="line"><span class="comment">// O_APPEND: 写文件时，数据添加到文件末尾</span></span><br><span class="line"><span class="comment">// O_NONBLOCK: 对于设备文件，以非阻塞I/O方式打开</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p class="p red">Linux的/dev目录存放了与设备相关的文件，如果你想open一个打印机、键盘、网卡等硬件设备，需要到此目录找到对应的文件，然后将文件路径作为参数传入即可。</p><h3 id="5-2-socket"><a href="#5-2-socket" class="headerlink" title="5.2 socket"></a>5.2 socket</h3><p>socket函数与open函数一样用于获取描述符，由于网卡相对其他设备较为特殊，需要额外考虑到IP类型、传输协议等，因此open函数无法满足，需要通过socket函数生成一个套接字描述符(文件描述符的一种):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// protofamily: 地址族，也就是IP地址的类型(处于七层协议的网络层)</span></span><br><span class="line"><span class="comment">// PF_UNIX、PF_LOCAL: 本地通信</span></span><br><span class="line"><span class="comment">// AF_INET、PF_INET: IPv4 Internet协议</span></span><br><span class="line"><span class="comment">// PF_INET6: IPv6 Internet协议</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type: 套接字类型(处于七层协议的传输层)</span></span><br><span class="line"><span class="comment">// SOCK_STREAM: 字节流</span></span><br><span class="line"><span class="comment">// SOCK_DGRAM: 数据报</span></span><br><span class="line"><span class="comment">// SOCK_SEQPACKET: 有序分组</span></span><br><span class="line"><span class="comment">// SOCK_RAW: 原始套接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// protocol: 指定传输协议</span></span><br><span class="line"><span class="comment">// IPPROTO_TCP: TCP传输协议</span></span><br><span class="line"><span class="comment">// IPPTOTO_UDP: UDP传输协议</span></span><br><span class="line"><span class="comment">// IPPROTO_SCTP: STCP传输协议</span></span><br><span class="line"><span class="comment">// IPPROTO_TIPC: TIPC传输协议</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> protofamily, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>protofamily与type确定的情况下，可以决定最终的传输协议，但是这俩者组合后可能衍生一或多个传输协议，也可能一个都没有。如果衍生出多个传输协议，就需要通过protocol参数进行补充，说白了就是告诉操作系统具体用哪个；如果仅衍生出一个，protocol参数填0即可；如果一个都没衍生出来，操作系统会选择type默认的传输协议。无论衍生出什么组合，只要protocol参数传入0，那么操作系统都会选择type默认的传输协议。</p><p>这里虽然得到了套接字描述符(sockfd)，但一个服务器可能运行很多个进程，多个进程共享一个网卡硬件完成网络数据的收发，因此无论是服务端还是客户端，必须使用bind函数为此sockfd绑定ip(IPv4、IPv6等)和端口，实现各进程的网络数据传输隔离。</p><p>此时sockfd仍然不知道能和谁通信，因此还得调用listen函数对此sockfd进行监听，如果某个客户端进程(可能本机，也可能远程机器)调用connect函数并指定ip和端口进行连接，服务端的listen函数会监听到连接请求，然后通过accept函数对连接请求进行处理，并返回一个acceptfd。</p><p>linux中服务端和客户端是一对多的关系，accept函数提供于服务端，因为服务端需要知道并区分每一个客户端的连接，因此返回值acceptfd就是标记与每个客户端的连接通道。connect函数提供于客户端，因为一个客户端只能对应一个服务端，所以客户端在连接过程中不会生成新的描述符。</p><p class="p red">如果客户端想要连接多个服务端，那就要手动创建新的sockfd，但ip端口已经被原来的sockfd占用，不同的sockfd绑定同一个ip端口会报错，这时候就得使用端口复用技术，允许某个进程的多个sockfd绑定到某一个ip端口上。绑定成功后再调用connect函数，基于新创建的sockfd与服务端进行连接。</p><p>假设服务端和客户端建立的是TCP连接，那么从客户端调用connect函数，到服务端执行accept函数的过程，就是三次握手的过程:<br><img src="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" class="lazyload" data-srcset="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h3 id="5-3-read与write"><a href="#5-3-read与write" class="headerlink" title="5.3 read与write"></a>5.3 read与write</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>就单纯的对描述符对应的文件进行读写，读写成功后会触发文件描述符的指针移动。以读取为例，假设最后读取了10个字节，那么读取后需要将指针(也可以理解为读取进度)往后移动10位，确保下次读取不会对同一位置的字节重复读取。</p><p>以写入为例，假设最后写入了10个字节，也要将指针往后移动10位，确保下次写入接着上次的位置往后写，不会对同一位置重复写，覆盖之前的write操作。</p><h3 id="5-4-send与recv"><a href="#5-4-send与recv" class="headerlink" title="5.4 send与recv"></a>5.4 send与recv</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buff, <span class="keyword">size_t</span> nbytes, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="5-5-close"><a href="#5-5-close" class="headerlink" title="5.5 close"></a>5.5 close</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="6-IO模型"><a href="#6-IO模型" class="headerlink" title="6.IO模型"></a>6.IO模型</h2><h3 id="6-1-同步阻塞IO"><a href="#6-1-同步阻塞IO" class="headerlink" title="6.1 同步阻塞IO"></a>6.1 同步阻塞IO</h3><p><img src="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png" class="lazyload" data-srcset="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>同步阻塞IO就是应用程序在调用内核函数过程中一直处于等待状态，不能执行其他任何操作，直到内核将数据返回后，才能继续往后执行代码。同步阻塞在磁盘IO和内存IO中使用较为广泛，因为硬盘和内存总会快速读取(大文件除外)，同步阻塞实现起来简单明了，非阻塞或者异步只会让设计更复杂，却又对性能没多少帮助。</p><h3 id="6-2-同步非阻塞IO"><a href="#6-2-同步非阻塞IO" class="headerlink" title="6.2 同步非阻塞IO"></a>6.2 同步非阻塞IO</h3><p><img src="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png" class="lazyload" data-srcset="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>同步非阻塞IO在数据没有准备好时总会快速返回errno，当数据准备好时才会进入阻塞，直到拷贝到用户空间并返回。这种方式可以让应用程序在进行IO操作时更加灵活，当读取的文件较大或者等待网络请求时，可以利用准备数据的这段时间处理其他逻辑，提高任务的执行效率，直到数据准备完毕后再次调用，阻塞并等待数据拷贝返回。</p><h3 id="6-3-IO多路复用"><a href="#6-3-IO多路复用" class="headerlink" title="6.3 IO多路复用"></a>6.3 IO多路复用</h3><p><img src="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8IO%E6%A8%A1%E5%9E%8B.png" class="lazyload" data-srcset="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8IO%E6%A8%A1%E5%9E%8B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>IO多路复用模型常用于网路IO，解决服务端和客户端TCP并发连接数高、网络交互不频繁的场景，假设现在用同步(阻塞或非阻塞)的方式处理客户端的网路IO，由于服务端不知道客户端什么时候会发送数据，上面也有讲过每个连接都会分配一个描述符，因此对于每个连接都需要分配一个线程不停的去检查，检测到请求就及时响应。如果连接较少就无所谓了，当连接数达到1W甚至更多，那么就会有1万甚至更多个线程不停的循环检查数据，CPU直接就炸了。</p><p>上述的问题就是服务端经典的C10K问题，本质上是操作系统的问题。IO多路复用采用单线程监听多个客户端网络请求的方式，将多个连接客户端的sockfd放入一个集合中，然后交给某一个线程去轮询这些连接，当发现某个sockfd传来数据时就通知服务端处理，避免大量的线程轮询忙等带来的CPU浪费。由此也可以看出此模型不适合磁盘，因为磁盘IO不像网路IO那样不知道啥时候会有数据传来，磁盘的数据就摆在那读完就结束了。</p><p>Linux系统提供了select、poll、epoll三种IO多路复用机制，虽然都是通过单个线程监听多个描述符，但内部监听的方式不同、存储sockfd的数据结构不同、对sockfd的数量限制也不同，下面单独讲。</p><h3 id="6-4-信号驱动IO"><a href="#6-4-信号驱动IO" class="headerlink" title="6.4 信号驱动IO"></a>6.4 信号驱动IO</h3><p><img src="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E6%A8%A1%E5%9E%8B.png" class="lazyload" data-srcset="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E6%A8%A1%E5%9E%8B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>信号驱动IO模型底层采用中断机制，对IO设备进度读取时立刻返回(非阻塞)，Linux系统中用sigaction函数将SIGIO读写信号以及handler回调函数存在内核队列中。当设备IO缓冲区可写或可读时触发SIGIO中断，返回设备fd并回调handler。与其他同步非阻塞IO模型相比，信号驱动IO模型在准备数据阶段不需要应用程序主动轮询检查，因此更节约CPU资源。</p><p>使用<span class="p blue">kill -l</span>命令，可查看Linux系统支持的信号量列表(SIGIO的编号为29):<br><img src="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/Linux%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%88%97%E8%A1%A8.png" class="lazyload" data-srcset="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/Linux%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%88%97%E8%A1%A8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>其中编号为1 ~ 31的信号为传统UNIX支持的信号，是不可靠信号，编号为32 ~ 63的信号是后来扩充的，称做可靠信号。不可靠信号和可靠信号的区别在于前者不支持排队%}，例如同一个可靠信号量发送多次到某个进程，内核可以缓存最多8192个(版本不同会有差异)；例如同一个不可靠信号量发送多次到某个进程，内核只会缓存一个，多余的信号量直接丢弃。</p><p><strong>SIGIO信号量在TCP连接中支持的IO事件:</strong></p><ul><li>监听的套接字上有新连接请求完成</li><li>某个断开连接请求发起</li><li>某个断开连接请求完成</li><li>数据到达套接字</li><li>数据已从套接字发送走</li><li>发生某个异步错误</li></ul><p><strong>SIGIO信号量在UDP连接中支持的IO事件:</strong></p><ul><li>数据报到达套接字</li><li>套接字上发生异步错误</li></ul><p class="p red">信号驱动IO模型最大的缺点，是使用SIGIO信号量时无法识别IO事件的具体类型，特别是TCP这种属于双向可靠连接，可产生信号的条件很多，而我们真正想要的只是连接完成和数据到达事件。这就导致TCP连接使用此模型时，会频繁的产生SIGIO信号，因此回调函数每次都要去检查是否有新连接、是否有可读数据，但并不是每次信号都需要真正的处理网络请求。</p><p class="p red">如果服务端与1W个客户端建立TCP连接(C10K问题)，每一个TCP通道都会分配一个handler用于接收SIGIO信号，由于TCP的SIGIO信号量产生过于频繁，这些handler的回调函数，相当一部分时间里都是在检查是否有新连接、是否有可读数据，而只有少数时间是真正的处理网络请求，反而更浪费CPU资源。</p><p class="p red">而UDP是无状态的连接，只有数据到达套接字、发生错误这俩种情况才会产生信号，每次产生信号都是有任务需要处理，回调函数的逻辑判断也简单很多。因此信号驱动IO模型在UDP连接中使用较多，而TCP极少使用。</p><h3 id="6-5-异步非阻塞IO"><a href="#6-5-异步非阻塞IO" class="headerlink" title="6.5 异步非阻塞IO"></a>6.5 异步非阻塞IO</h3><p><img src="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B.png" class="lazyload" data-srcset="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>以上四种IO模型都属于同步IO模型，同步阻塞IO模型全程处于阻塞状态，同步非阻塞IO模型、信号驱动IO模型在数据copy阶段仍然阻塞，因此不能说是异步；IO多路复用在轮询过程中也处于阻塞状态。只有异步非阻塞IO模型才是完完全全的异步模型。</p><p>Linux从2.6版本开始支持异步IO，此功能最初是为数据库设计的，因此通过异步IO的读写操作不会被缓存或缓冲，这就无法利用操作系统的缓存与缓冲机制。</p><h2 id="7-IO多路复用函数"><a href="#7-IO多路复用函数" class="headerlink" title="7.IO多路复用函数"></a>7.IO多路复用函数</h2><h3 id="7-1-select"><a href="#7-1-select" class="headerlink" title="7.1 select"></a>7.1 select</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><br><strong>参数介绍</strong></p><ul><li>nfds: 需要监视的最大的文件描述符值+1</li><li>readfds: 要监听的读文件描述符</li><li>writefds: 要监听的写文件描述符</li><li>exceptfds: 要监听的异常文件描述符</li><li>timeout: 超时设置，null表示没限制一直等、0表示扫描一轮立刻返回、指定值:扫描指定时间，直到超时</li></ul><p><br><strong>返回值</strong></p><ul><li>大于0: 表示多少个描述符就绪</li><li>等于0: 表示超时</li><li>小于0: 表示监控出错了(select本次监控出错)</li></ul><p><br><strong>执行流程图:</strong><br><img src="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/select%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" class="lazyload" data-srcset="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/select%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>轮询时如果发现某个描述符没有就绪，那么会从数组中剔除，最终返回的集合中仅包含就绪的描述符，因此应用程序拿到数组后还需要进行遍历，才能确定哪些描述符是就绪的。如果timeout参数为null或特定值，那么会对数组多次轮询，因此在轮询前还会将数组copy一份，防止上次轮询无事件，导致数组被清空。</p><p>轮询毕竟会多余的消耗CPU资源，如果timeout参数为null或特定值，那么会对数组多次轮询，在进程没有从设备读到数据时，会进入设备的睡眠队列中(可设置睡眠时间)，直到睡眠超时或设备发生读写事件提前唤醒，再次进入下次轮询，减少对CPU无意义的消耗。</p><p>select的工作模式为条件触发，函数将存在事件的描述符数组返回给应用程序时，如果应用程序对某个描述符不作任何处理，那么之后的轮询仍然会返回此描述符，直到对此描述符进行处理为止。</p><h3 id="7-2-poll"><a href="#7-2-poll" class="headerlink" title="7.2 poll"></a>7.2 poll</h3><p>使用链表存储监听的描述符，对监听的描述符不作数量上的限制，其他与select一致。</p><h3 id="7-3-epoll"><a href="#7-3-epoll" class="headerlink" title="7.3 epoll"></a>7.3 epoll</h3><p>epoll在2.6内核中提出，主要为了解决select和poll的缺点，比前两者更灵活但实现起来也更复杂。内部操作过程又可分为epoll_create, epoll_ctl、epoll_wait三个函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个epoll的句柄，用于存放需要监听的fd</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对epfd中的某个fd进行相关操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待epfd上的io事件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><br><font color="red">epoll_create函数</font>用于创建一个epoll专用的fd集合，用于存储想要监听的描述符。参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</p><p><font color="red">epoll_ctl函数</font>是对epfd(epoll_create函数的返回值)进行相关操作，op参数代表操作类型(新增、修改、删除)，event参数代表操作事件(可读、可写、挂断等)。例如指定某个epfd内部的某个fd，新增一个可读事件监听，新增成功返回0，失败返回-1。</p><p><font color="red">epoll_wait函数</font>用于等待epfd上的io事件，等待过程中线程阻塞。前俩个函数可以创建一个fd集合，并对其中的每个fd设置各种类型的监听事件，而此函数则真正负责监听。内核会把监听到的事件添加到events参数中，最多添加maxevents个，并通过timeout参数控制超时时间，返回监听到的事件数量。</p><p><strong>epoll内部执行流程图:</strong><br><img src="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/epoll%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" class="lazyload" data-srcset="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/epoll%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>epoll不会像select那样对监听的描述符数量进行限制，也不会像select/poll那样每次监听都将所有fd传到内核，而是通过epoll_ctl函数逐个放入，后续调用epoll_wait函数监听时，只需要告诉内核epfd即可，达到数据轻量拷贝的效果，不过返回时仍然需要拷贝所有fd到应用程序。</p><p>epoll还使用了事件驱动的机制，在内核维护了一个链表记录就绪事件，当某个socket有事件发生时会向CPU发送中断信号，然后执行对应的回调函数将描述符添加到就绪链表中，应用程序通过epoll_wait函数获取就绪描述符时，只需要扫描这个链表即可，也就是说epoll只关心活跃连接，并不会像select/poll那样随着连接数增多，效率降低。</p><p>epoll支持条件触发(LT)和水平触发(ET)两种工作方式，LT的工作方式在写select时说的很清楚了。ET在就绪通知方面与LT相反，对于就绪的描述符仅通知应用程序一次，即使应用程序没有进行处理也不会在多次监听过程中重复提醒，除非你做了某些操作导致变成未就绪状态，后面再次就绪才会再提醒。ET模式在调用epoll_ctl函数时，在event参数的属性中设置。</p><p class="p red">从epoll的原理来看，好像比select/poll要高级很多，但这并不代表epoll能完全代替select/poll。对于监听的fd集合，如果每次检查大多数fd都处于就绪状态，使用事件驱动的机制就有点画蛇添足了，还不如直接轮询。因此epoll相对于select/poll来说，适合连接数更多、请求频率更低的场景。</p><h2 id="8-零拷贝技术"><a href="#8-零拷贝技术" class="headerlink" title="8.零拷贝技术"></a>8.零拷贝技术</h2><p>零拷贝技术是Linux系统对IO性能的一种优化，让进程在整个IO操作过程中，用户内存与内核内存之间的拷贝次数降为零次，因此称为零拷贝技术。传统的IO操作，进程需要调用open()或socket()函数来确定IO的目标，并得到一个描述符，后续将这个描述符以及读写的内容作为参数，调用Linux内核函数进行读写:<br><img src="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/temp.jpeg" class="lazyload" data-srcset="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/temp.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><br><p class="p red">由于内核内存与进程内存完全隔离，也就意味着每次IO操作，必须经历一次内核内存与进程内存之间的数据拷贝，对于大文件的读写，或者大数据量的网络请求接受，这个步骤是比较消耗资源的。Linux系统提供了mmap()、sendfile()函数来减少拷贝的次数，提高IO效率。</p><h3 id="8-1-mmap"><a href="#8-1-mmap" class="headerlink" title="8.1 mmap()"></a>8.1 mmap()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><p>了解Linux虚拟内存机制是掌握mmap()原理的基础，这里我省略不写了。在传统IO过程中，进程通过open()或socket()函数得到内核分配的描述符，但完全不知道描述符涉及到的物理地址在哪，内核函数会根据描述符找到对应的虚拟地址，经过CPU的MMU转化为物理地址再执行读写，也就是说底层的逻辑Linux已经帮我们封装好了，进程对于设备地址这些概念是透明的。</p><p>mmap()函数的作用，是在内核中初始化一块虚拟内存，内存大小和描述符对应的数据大小一致，一般都是针对磁盘文件。进程在调用此函数后，内核会将初始化的这块内存地址，映射到进程内存空间的某块虚拟地址上，并返回映射的地址值，这样进程就拥有了这部分内核内存的访问权:<br><img src="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/temp.jpeg" class="lazyload" data-srcset="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/temp.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><br><p>进程拥有描述符对应的虚拟地址后，就不需要借助read()、write()等函数了，可以直接调用文件系统，甚至是块设备驱动的相关函数进行读写，从而减少用户内存与内核内存之间的拷贝。如果是写入的话，内核也能通过地址访问随时感知到数据的变化，并且在合适的时候将数据落盘(映射内存的读写经过PageCache):<br><img src="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/temp.jpeg" class="lazyload" data-srcset="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/temp.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h3 id="8-2-sendfile"><a href="#8-2-sendfile" class="headerlink" title="8.2 sendfile()"></a>8.2 sendfile()</h3><figure class="highlight c"><figcaption><span>函数内容</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p><br><strong>参数说明:</strong></p><ul><li>out_fd: 已经打开的、传输过程中用于写入的描述符</li><li>in_fd: 已经打开的、传输过程中用于读取的描述符</li><li>offset: 从in_fd对应地址的哪个位置开始读取数据</li><li>count: 从in_fd的offset位置开始，拷贝到out_fd的字节总数</li></ul><p><br><strong>返回值说明:</strong><br>如果成功的拷贝,返回写操作到out_fd的字节数,错误返回-1,并相应的设置error信息。</p><br><p>sendfile()函数是专门针对不同描述符之间的IO传输，例如将某个file描述符的某段数据写入某个socket描述符，相对于mmap()来说使用场景可能少一点，但执行效率要高一些。下面是sendfile()函数的工作流程:<br><img src="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/temp.jpeg" class="lazyload" data-srcset="/2020/05/06/IO%E6%B5%81-Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84IO/temp.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><br>从图中可以看出，使用sendfile()函数进行IO传输，数据根本就不会经过进程内存，也就不存在内核与进程内存之间的数据拷贝，并且读写两个操作经历一次系统函数调用即完成，减少一次系统函数调用，也就意味着减少一次上下文切换。<h3 id="8-3-使用场景"><a href="#8-3-使用场景" class="headerlink" title="8.3 使用场景"></a>8.3 使用场景</h3><p>在使用场景方面，mmap()函数要比sendfile()函数广泛一些，首先mmap()函数可以单纯的读取或单纯的写入，也可以读写组合使用，sendfile()函数必须要指定两个描述符进行传输，而且sendfile()函数在整个IO操作过程中，进程完全不知道传输的数据内容是什么。以RocketMQ和Kafka为例:</p><p>RocketMQ使用mmap()方式，主要因为Consumer订阅消息支持过滤功能，每条消息都有关于tag的hashCode，Broker进程需要将消息从磁盘读取到进程内存中，然后通过hashCode判断这条消息是否需要过滤掉，因此无法使用sendfile()。</p><p>Kafka没有消息过滤功能，整个设计只注重吞吐量，因此在向Consumer发送消息时，完全不需要关注消息的内容，使用sendfile()性能最佳。但Producer进行消息写入时，只涉及到磁盘设备，Kafka使用了mmap()函数进行消息持久化。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> io流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程(十七) 线程池</title>
      <link href="2020/03/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>2020/03/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>解释线程池之前要先说一下池化技术，池化技术简单点来说，就是提前保存大量的资源，以备不时之需。而线程池就是利用池化技术保存线程资源的容器，同样也是Java多线程编程的重要基础。</p><p>多线程优点:</p><ul><li>避免线程频繁的创建以及销毁带来的资源浪费</li><li>提高响应速度，任务到达时提前保存的线程可以立即执行，不需要等待临时创建</li><li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</li><li>提供定时执行、定期执行、单线程、并发数控制等功能。</li></ul><h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><p><img src="/2020/03/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.jpg" class="lazyload" data-srcset="/2020/03/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><font size="4"><b>Executor:</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line">   void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executor类是线程池顶级接口，只定义了一个执行无返回值任务的方法。</p><p><font size="4"><b>ExecutorService:</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public interface ExecutorService extends Executor &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 关闭线程池，不再接受新任务，但已经提交的任务会执行完成</span><br><span class="line">    void shutdown();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 立即关闭线程池，尝试停止正在运行的任务，未执行的任务将不再执行</span><br><span class="line">    &#x2F;&#x2F; 被迫停止及未执行的任务将以列表的形式返回</span><br><span class="line">    List&lt;Runnable&gt; shutdownNow();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检查线程池是否已关闭</span><br><span class="line">    boolean isShutdown();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检查线程池是否已终止，只有在shutdown()或shutdownNow()之后调用才有可能为true</span><br><span class="line">    boolean isTerminated();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在指定时间内线程池达到终止状态了才会返回true</span><br><span class="line">    boolean awaitTermination(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行有返回值的任务，任务的返回值为task.call()的结果</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行有返回值的任务，任务的返回值为这里传入的result,相当于给指针赋值</span><br><span class="line">    &#x2F;&#x2F; 当然只有当任务执行完成了调用get()时才会返回</span><br><span class="line">    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行有返回值的任务，返回值.get()为线程返回值</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 批量执行任务，只有当这些任务都完成了这个方法才会返回，可以获取线程ID来区分集合中的返回值</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在指定时间内批量执行任务，未执行完成的任务将被取消</span><br><span class="line">    &#x2F;&#x2F; 这里的timeout是所有任务的总时间，不是单个任务的时间</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, </span><br><span class="line">    long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 返回任意一个已完成任务的执行结果，未执行完成的任务将被取消</span><br><span class="line">    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        throws InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在指定时间内如果有任务已完成，则返回任意一个已完成任务的执行结果，未执行完成的任务将被取消</span><br><span class="line">    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,  long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExecutorService类仍然只是接口，在Executor的基础上增加了关闭线程池、池内线程执行等相关操作。</p><p><font size="4"><b>ScheduledExecutorService:</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public interface ScheduledExecutorService extends ExecutorService &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在指定延时后执行一次</span><br><span class="line">    public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 在指定延时后执行一次</span><br><span class="line">    public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit);</span><br><span class="line">                                           </span><br><span class="line">    &#x2F;&#x2F; 在指定延时后开始执行，并在之后以指定时间间隔重复执行（间隔不包含任务执行的时间）</span><br><span class="line">    &#x2F;&#x2F; 无论任务是否完成，只要到时间就执行下一次</span><br><span class="line">    public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">long initialDelay,</span><br><span class="line">long period,</span><br><span class="line">TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在指定延时后开始执行，并在之后以指定延时重复执行（间隔包含任务执行的时间）</span><br><span class="line">    &#x2F;&#x2F; 上次任务结束才开始倒计时，只可能一个线程在工作</span><br><span class="line">    public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">long initialDelay,</span><br><span class="line">long delay,</span><br><span class="line">TimeUnit unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScheduledExecutorService接口在ExecutorService的基础上增加了定时任务的相关功能，这些定时功能又分为单次执行和重复执行。</p><p><font size="4"><b>AbstractExecutorService:</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolExecutor extends AbstractExecutorService&#123;</span><br><span class="line"></span><br><span class="line">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123;</span><br><span class="line">return new FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;</span><br><span class="line">        return new FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask &#x3D; newTaskFor(task, null);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        return ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;</span><br><span class="line">        if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        return ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;</span><br><span class="line">        if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        return ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private &lt;T&gt; T doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                              boolean timed, long nanos)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">        if (tasks &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        int ntasks &#x3D; tasks.size();</span><br><span class="line">        if (ntasks &#x3D;&#x3D; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        ArrayList&lt;Future&lt;T&gt;&gt; futures &#x3D; new ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);</span><br><span class="line">        ExecutorCompletionService&lt;T&gt; ecs &#x3D;</span><br><span class="line">            new ExecutorCompletionService&lt;T&gt;(this);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; Record exceptions so that if we fail to obtain any</span><br><span class="line">            &#x2F;&#x2F; result, we can throw the last exception we got.</span><br><span class="line">            ExecutionException ee &#x3D; null;</span><br><span class="line">            final long deadline &#x3D; timed ? System.nanoTime() + nanos : 0L;</span><br><span class="line">            Iterator&lt;? extends Callable&lt;T&gt;&gt; it &#x3D; tasks.iterator();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Start one task for sure; the rest incrementally</span><br><span class="line">            futures.add(ecs.submit(it.next()));</span><br><span class="line">            --ntasks;</span><br><span class="line">            int active &#x3D; 1;</span><br><span class="line"></span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                Future&lt;T&gt; f &#x3D; ecs.poll();</span><br><span class="line">                if (f &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    if (ntasks &gt; 0) &#123;</span><br><span class="line">                        --ntasks;</span><br><span class="line">                        futures.add(ecs.submit(it.next()));</span><br><span class="line">                        ++active;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (active &#x3D;&#x3D; 0)</span><br><span class="line">                        break;</span><br><span class="line">                    else if (timed) &#123;</span><br><span class="line">                        f &#x3D; ecs.poll(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                        if (f &#x3D;&#x3D; null)</span><br><span class="line">                            throw new TimeoutException();</span><br><span class="line">                        nanos &#x3D; deadline - System.nanoTime();</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                        f &#x3D; ecs.take();</span><br><span class="line">                &#125;</span><br><span class="line">                if (f !&#x3D; null) &#123;</span><br><span class="line">                    --active;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        return f.get();</span><br><span class="line">                    &#125; catch (ExecutionException eex) &#123;</span><br><span class="line">                        ee &#x3D; eex;</span><br><span class="line">                    &#125; catch (RuntimeException rex) &#123;</span><br><span class="line">                        ee &#x3D; new ExecutionException(rex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (ee &#x3D;&#x3D; null)</span><br><span class="line">                ee &#x3D; new ExecutionException();</span><br><span class="line">            throw ee;</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            for (int i &#x3D; 0, size &#x3D; futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        throws InterruptedException, ExecutionException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return doInvokeAny(tasks, false, 0);</span><br><span class="line">        &#125; catch (TimeoutException cannotHappen) &#123;</span><br><span class="line">            assert false;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                           long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">        return doInvokeAny(tasks, true, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        if (tasks &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        ArrayList&lt;Future&lt;T&gt;&gt; futures &#x3D; new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">        boolean done &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">                RunnableFuture&lt;T&gt; f &#x3D; newTaskFor(t);</span><br><span class="line">                futures.add(f);</span><br><span class="line">                execute(f);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i &#x3D; 0, size &#x3D; futures.size(); i &lt; size; i++) &#123;</span><br><span class="line">                Future&lt;T&gt; f &#x3D; futures.get(i);</span><br><span class="line">                if (!f.isDone()) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        f.get();</span><br><span class="line">                    &#125; catch (CancellationException ignore) &#123;</span><br><span class="line">                    &#125; catch (ExecutionException ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            done &#x3D; true;</span><br><span class="line">            return futures;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (!done)</span><br><span class="line">                for (int i &#x3D; 0, size &#x3D; futures.size(); i &lt; size; i++)</span><br><span class="line">                    futures.get(i).cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                         long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        if (tasks &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        long nanos &#x3D; unit.toNanos(timeout);</span><br><span class="line">        ArrayList&lt;Future&lt;T&gt;&gt; futures &#x3D; new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">        boolean done &#x3D; false;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (Callable&lt;T&gt; t : tasks)</span><br><span class="line">                futures.add(newTaskFor(t));</span><br><span class="line"></span><br><span class="line">            final long deadline &#x3D; System.nanoTime() + nanos;</span><br><span class="line">            final int size &#x3D; futures.size();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Interleave time checks and calls to execute in case</span><br><span class="line">            &#x2F;&#x2F; executor doesn&#39;t have any&#x2F;much parallelism.</span><br><span class="line">            for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                execute((Runnable)futures.get(i));</span><br><span class="line">                nanos &#x3D; deadline - System.nanoTime();</span><br><span class="line">                if (nanos &lt;&#x3D; 0L)</span><br><span class="line">                    return futures;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">                Future&lt;T&gt; f &#x3D; futures.get(i);</span><br><span class="line">                if (!f.isDone()) &#123;</span><br><span class="line">                    if (nanos &lt;&#x3D; 0L)</span><br><span class="line">                        return futures;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        f.get(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                    &#125; catch (CancellationException ignore) &#123;</span><br><span class="line">                    &#125; catch (ExecutionException ignore) &#123;</span><br><span class="line">                    &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">                        return futures;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos &#x3D; deadline - System.nanoTime();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            done &#x3D; true;</span><br><span class="line">            return futures;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (!done)</span><br><span class="line">                for (int i &#x3D; 0, size &#x3D; futures.size(); i &lt; size; i++)</span><br><span class="line">                    futures.get(i).cancel(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractExecutorService是个抽象类，首先重写了ExecutorService类的submit()、invokeAny()、invokeAll()方法，另外还提供了一个newTaskFor方法用于构建RunnableFuture对象。</p><p><font size="4"><b>ThreadPoolExecutor:</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolExecutor extends AbstractExecutorService &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor是一个普通类，也是我们使用线程池时需要创建的实例，内部集成了AbstractExecutorService抽象类，也就意味着它包含了以上介绍的所有接口(除了ScheduledExecutorService)的处理逻辑，也是本章节要着重要分析的类。</p><p><font size="4"><b>ScheduledThreadPoolExecutor:</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ScheduledThreadPoolExecutor</span><br><span class="line">extends ThreadPoolExecutor</span><br><span class="line">implements ScheduledExecutorService &#123;</span><br><span class="line">&#x2F;&#x2F; 属性方法..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor类看继承实现关系就能看明白，在继承了ThreadPoolExecutor类所有功能的情况下，通过实现ScheduledExecutorService接口又增加了线程定时任务执行的相关逻辑。</p><p><font size="4"><b>ForkJoinPool:</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ForkJoinPool extends AbstractExecutorService &#123;</span><br><span class="line">&#x2F;&#x2F; 属性方法..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkJoinPool比较适合计算密集型的任务，以后有机会用到的话再写。</p><h2 id="构造器参数"><a href="#构造器参数" class="headerlink" title="构造器参数"></a>构造器参数</h2><p>在ThreadPoolExecutor类中有4个构造器，但最终调用的是如下这个构造器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">int maximumPoolSize,</span><br><span class="line">long keepAliveTime,</span><br><span class="line">TimeUnit unit,</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">ThreadFactory threadFactory,</span><br><span class="line">RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><p><font size="4"><b>corePoolSize:</b></font><br>核心线程大小，即在没有任务需要执行的时候线程池的大小，当所有核心线程都在执行任务时仍然有新任务提交，会直接进入阻塞队列。除非调用allowCoreThreadTimeOut()方法设置为true，这种情况下核心线程数空闲下来也会被回收掉。另外核心线程默认是懒加载模式，只有等到有任务的时候才会启动，比如常见的数据库连接池，在启动项目后首次访问数据库会打印{dataSource-1} inited日志，其实就是在懒加载核心线程，除非你调用prestartCoreThread()或prestartAllCoreThreads()方法提前启动核心线程。</p><p><font size="4"><b>maximumPoolSize:</b></font><br>线程池中允许的最大线程数，如果说corePoolSize是控制同一时刻线程执行数量的下限，maximumPoolSize就是与之对应的上限。当阻塞队列已满并且当前线程个数小于maximumPoolSize，那么会创建新的线程来执行任务。这里值得一提的是getLargestPoolSize()方法，调用该方法会返回线程池在整个生命周期中曾经出现的最大线程个数。</p><p><font size="4"><b>keepAliveTime:</b></font><br>线程空闲时的存活时间，当线程持续keepAliveTime时间处于空闲状态时，这个空闲线程会被销毁。默认情况下，该参数只会对非核心线程生效，如果调用allowCoreThreadTimeOut()被设置为true时，无论线程数多少，线程处于空闲状态超过一定时间就会被销毁掉。</p><p><font size="4"><b>unit:</b></font><br>keepAliveTime的单位，TimeUnit是一个枚举类型，具体哪些就没必要讲了。</p><p><font size="4"><b>workQueue:</b></font><br>阻塞队列，当所有核心线程都在执行任务时仍然有新任务提交时，会加入此队列等待。构造器中阻塞队列的范型必须是Runnable类型，换句话说只有实现Runnable接口的类才可以加入阻塞队列，这个下面会单独讲。</p><p><font size="4"><b>threadFactory:</b></font><br>线程工厂，用于新线程的创建，创建时可以设定线程名、是否为daemon线程等等。</p><p><font size="4"><b>handler:</b></font><br>拒绝策略，当阻塞队列已满并且线程池中的线程数量也达到最大限制，必须采取一种策略处理该任务。线程池提供了四种决绝策略，如果仍然无法满足业务需求，还可以通过实现RejectedExecutionHandler接口自定义拒绝策略。</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>线程池允许设置的阻塞队列对象，用来保存等待被执行的任务的阻塞队列，队列全部都是BlockingQueue接口的实现类，并且范型必须实现Runable接口，如下阻塞队列:</p><p><font size="4"><b>ArrayBlockingQueue(有界队列):</b></font><br>是一个基于数组实现的的阻塞队列，队列长度在创建后固定不可修改，此队列按照先进先出（FIFO）的原则对元素进行排序。ArrayBlockingQueue插入数据和获取数据，需要竞争到锁才可以执行，也就意味着这俩个操作无法并行执行，另外可以通过构造器参数设置竞争的公平性。</p><p><font size="4"><b>LinkedBlockingQueue(无界队列):</b></font><br>是一个基于链表实现的的阻塞队列，如果在创建时没有在构造器中指定容量，那么容量默认为Integer.MAX_VALUE。LinkedBlockingQueue队列的插入和消费元素采用分离的锁控制，也就意味着这俩种操作可以并行执行，整体的吞吐性能要高于ArrayBlockingQueue，当队列达到最大容量时，插入元素的线程会进入阻塞，直到队列的元素被消费掉腾出空间才会被唤醒继续执行。</p><p><font size="4"><b>DelayQueue(延迟队列):</b></font><br>此队列中在长度方面没有任何限制，因此往队列插入元素时不会产生任何阻塞，如果线程池任务想要加入此队列除了要实现Runnable接口外，还需要实现Delayed接口。获取元素时，只有当元素的延迟时间到了才可以从队列中获取到该元素，否则会进入阻塞。</p><p><font size="4"><b>PriorityBlockingQueue(优先级队列):</b></font><br>此队列在长度方面仍然没有限制，插入元素操作也不会产生任何阻塞，如果线程池任务想要加入此队列除了要实现Runnable接口外，还需要实现Compator接口。在使用没有容量限制的队列时一定要注意，插入元素的速度绝对不能大于消费元素的速度，否则随着时间的积累，会耗尽系统的内存资源造成内存泄漏。</p><p><font size="4"><b>SynchronousQueue(无缓冲等待队列):</b></font><br>队列中仅保存一个元素，只有对列为空才可以添加元素，之后只有等待元素被消费才可以继续添加。拥有公平(FIFO)和非公平(LIFO)策略，可以在创建时指定。</p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务。拒绝策略并不是设置就一定生效，比如阻塞队列选择无界的情况下，基本上队列堆积的任务没有到达Inteher.MAX_VALUE时，内存就爆了。java提供了四种线程池拒绝策略，当然你也可以通过继承这四个策略类，或者实现RejectedExecutionHandler接口自定义拒绝策略:</p><p><font size="4"><b>AbortPolicy(异常中止策略):</b></font><br>直接抛出RejectedExecutionException异常，也是线程池的默认拒绝策略。这种策略使用的时候要处理好抛出的异常，避免调用线程池的主线程因为异常打断后续的执行流程。</p><p><font size="4"><b>DiscardPolicy(丢弃策略):</b></font><br>直接丢弃任务，因为此类在实现RejectedExecutionHandler接口并重写的rejectedExecution方法中啥都没做。如果你提交的任务无关紧要，可以选择使用此策略，我个人感觉这个策略几乎用不上，但凡有点良心的开发都会打印一行日志意思意思…</p><p><font size="4"><b>DiscardOldestPolicy(弃老策略):</b></font><br>放弃阻塞队列中最靠前的任务，并尝试让线程池执行当前线程。这种策略仍然会悄悄的丢掉任务，只不过保证新产生的任务优先执行，应该是满足特定场景使用的吧。</p><p><font size="4"><b>CallerRunsPolicy(调用者运行策略):</b></font><br>当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。原理是直接运行Runnable的run()方法，直接调用run()的方式都懂得，会阻塞调用者直到执行完毕。<br>这种方式看似比较稳妥，能保证所有的任务都会被执行，但是拒绝策略的rejectedExecution()方法是包含在线程池的execute()方法中调用，execute()在执行过程中会占用一条线程，如果多个线程进入此阻塞策略并且线程执行时间过长，会严重影响线程池处理任务的吞吐量。因此这种策略一般在不允许失败、对性能要求不高、并发亮较小的场景下使用。</p><p><font size="4"><b>自定义:</b></font><br>如果以上四种策略无法满足你的需求，那就需要考虑自定义策略了。比如dubbo的工作线程池自定义的拒绝策略是继承AbortPolicy类，打印完日志后调用父类抛异常、比如ActiveMQ中的拒绝策略属于最大努力执行任务型，当触发拒绝策略时，在尝试一分钟的时间重新将任务塞进任务队列，当一分钟超时还没成功时，就抛出异常。</p><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><p>线程池的使用难度不大，但用好线程池就需要对常用参数的含义有一定的理解，并且要考虑到应用程序所在服务器的CPU配置、任务的执行特点、任务执行过程中的内存使用率等，如果任务中涉及下游服务的调用，还要考虑到下游服务的抗并发能力等。可以将线程池要执行的任务进行分类:</p><p><font size="4"><b>CPU密集型:</b></font><br>例如内存中的计算、比较、转化等，尽量使用较小的线程池，一般为CPU核心数+1。即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。因为CPU密集型任务使得CPU使用率很高，尽量减少线程之间竞争引起的上下文切换带来的资源浪费。</p><p><font size="4"><b>IO密集型:</b></font><br>例如网络IO(调用其他服务或接口)、磁盘IO(读写文件)等，可以使用稍大的线程池，一般为2*CPU核心数+1(如果调用下游服务还要考虑抗并发因素)。因为IO操作期间不占用CPU，不要让CPU闲下来，应加大线程数量，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。</p><p><font size="4"><b>混合型:</b></font><br>可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。 </p><span class="p red">注:通过公式推算出的线程池参数仅仅只是理想状态下的最优方案，实际最优参数需要根据服务器运行情况比，如线程执行过程中占用CPU时间、最大线程数峰值、拒绝策略出现频率等不断调整参数。</span><h2 id="springboot线程池"><a href="#springboot线程池" class="headerlink" title="springboot线程池"></a>springboot线程池</h2><p><font size="4"><b>配置自定义线程池:</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAsync</span><br><span class="line">public class ThreadPoolConfig implements AsyncConfigurer &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">     * 自定义线程池，若不重写会使用默认的线程池</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean(&quot;asyncExecutor&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public Executor getAsyncExecutor() &#123;</span><br><span class="line">        ThreadPoolTaskExecutor asyncExecutor &#x3D; new ThreadPoolTaskExecutor();</span><br><span class="line">        asyncExecutor.setCorePoolSize(16);</span><br><span class="line">        asyncExecutor.setMaxPoolSize(32);</span><br><span class="line">        asyncExecutor.setKeepAliveSeconds(180);</span><br><span class="line">        asyncExecutor.setQueueCapacity(200);</span><br><span class="line">        asyncExecutor.setThreadNamePrefix(&quot;buss-thread&quot;); &#x2F;&#x2F; 线程命名前缀</span><br><span class="line">        asyncExecutor.initialize();</span><br><span class="line">        return asyncExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 自定义拒绝策略</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123;</span><br><span class="line"></span><br><span class="line">        return new AbortPolicy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span class="p red">注: @EnableAsync注解一定要加，否则线程池异步调用不生效。</span><p><font size="4"><b>配置异步任务:</b></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">    public void updateById(UserTo to) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">@Async</span><br><span class="line">    @Override</span><br><span class="line">    public void asyncUpdateById(UserTo to) &#123;</span><br><span class="line">        updateById(to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    @Override</span><br><span class="line">    public Future&lt;Boolean&gt; asyncUpdateById(UserTo to) &#123;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">updateById(to);</span><br><span class="line">&#125; catch()&#123;</span><br><span class="line">return new AsyncResult&lt;&gt;(Boolean.FALSE);</span><br><span class="line">&#125;</span><br><span class="line">return new AsyncResult&lt;&gt;(Boolean.TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要使用异步方式调用某个方法，只需要加上@Async注解即可，如果需要返回值必须使用Future<T>，其他返回值类型在调用后会立刻返回null，如果不需要返回值直接将方法返回值设置为void。最好封装一个异步方法，减少对原始方法的破坏，避免其他非异步使用的线程调用后返回null导致程序错误。</T></p><span class="p red">注:如果应用配置了多个线程池，则需要在@Async注解的value属性中指定线程池Bean名称，没有指定的情况下使用默认线程池(@primary注解的bean)</span><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程(十六) ThreadLocal</title>
      <link href="2020/03/16/ThreadLocal/"/>
      <url>2020/03/16/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>ThreadLocal用于存储线程的局部变量，通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题，每个线程都可以通过set()和get()来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离。ThreadLocal诞生于JDK 1.2，直到JDK5.0开始支持范型。</p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2.应用场景"></a>2.应用场景</h2><p>ThreadLocal的应用场景比较广泛，例如web项目中登陆信息的存储、IOC中Request作用域的实现、Spring事物管理的实现、线程同步工具Exchanger的实现等。除了登录信息的存储以外，其他的多多少少都是涉及到底层的源码，写出来篇幅太大，所以下面简单讲述一下如何使用ThreadLocal存储登陆信息。</p><p>一般浏览器发送http请求到后端服务器，都会将用户信息的token以cookie或header形式携带过去，并在后端拦截器中对token校验是否合法。如果请求的接口中需要用到一次或多次用户信息(比如ID、名称、生日、职级等)进行业务处理，这就需要将用户信息从controller一层一层作为参数传递下去，这无疑增加了代码的复杂程度，重点是不够优雅，使用ThreadLocal完全可以避免这个问题。</p><p><strong>1.用户信息对象:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long deptId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.创建一个ThreadLocal封装类，内部定义一个私有ThreadLocal并对外提供get、set方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoThreadLocal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserInfo&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(UserInfo value)</span></span>&#123;</span><br><span class="line">        threadLocal.set(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserInfo <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserInfo <span class="title">getAndValidate</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        UserInfo userInfo = get();</span><br><span class="line">        <span class="keyword">if</span>(userInfo == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 抛业务异常</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.拦截器负责校验信息，并将合法的用户信息注册到ThreadLocal中:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInfoInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String token = request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(token))&#123;</span><br><span class="line">            <span class="comment">// 抛业务异常</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟查询用户信息</span></span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line">        userInfo.setId(<span class="number">323L</span>);</span><br><span class="line">        userInfo.setDeptId(<span class="number">542L</span>);</span><br><span class="line">        userInfo.setPhone(<span class="string">&quot;110&quot;</span>);</span><br><span class="line">        userInfo.setEmail(<span class="string">&quot;110@163.com&quot;</span>);</span><br><span class="line">        userInfo.setBirthday(<span class="string">&quot;1995-12-20&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放入UserInfoThreadLocal</span></span><br><span class="line">        UserInfoThreadLocal.set(userInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">            Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        UserInfoThreadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.web项目的controller层，获取并打印拦截器查询并校验通过的用户信息:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户信息并打印</span></span><br><span class="line">        UserInfo userInfo = UserInfoThreadLocal.getAndValidate();</span><br><span class="line">        System.out.println(<span class="string">&quot;controller:&quot;</span> + JSONObject.toJSONString(userInfo));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用service</span></span><br><span class="line">        testService.testQuery();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5.web项目的service层，获取并打印拦截器查询并校验通过的用户信息:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户信息并打印</span></span><br><span class="line">        UserInfo userInfo = UserInfoThreadLocal.getAndValidate();</span><br><span class="line">        System.out.println(<span class="string">&quot;testQuery:&quot;</span> + JSONObject.toJSONString(userInfo));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用私有方法</span></span><br><span class="line">        testMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户信息并打印</span></span><br><span class="line">        UserInfo userInfo = UserInfoThreadLocal.getAndValidate();</span><br><span class="line">        System.out.println(<span class="string">&quot;testMethod:&quot;</span> + JSONObject.toJSONString(userInfo));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果:</strong><br>controller:{“birthday”:”1995-12-20”,”deptId”:542,”email”:”<a href="mailto:&#49;&#x31;&#x30;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d;">&#49;&#x31;&#x30;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d;</a>“,”id”:323,”phone”:”110”}<br>testQuery:{“birthday”:”1995-12-20”,”deptId”:542,”email”:”<a href="mailto:&#x31;&#x31;&#48;&#64;&#49;&#54;&#51;&#x2e;&#x63;&#x6f;&#x6d;">&#x31;&#x31;&#48;&#64;&#49;&#54;&#51;&#x2e;&#x63;&#x6f;&#x6d;</a>“,”id”:323,”phone”:”110”}<br>testMethod:{“birthday”:”1995-12-20”,”deptId”:542,”email”:”<a href="mailto:&#x31;&#49;&#x30;&#x40;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#x6d;">&#x31;&#49;&#x30;&#x40;&#49;&#54;&#51;&#x2e;&#x63;&#111;&#x6d;</a>“,”id”:323,”phone”:”110”}</p><span class="p red">从上面的Demo代码可以看出来，只要在拦截器层面对token的验证通过，并将用户信息存储在创建的ThreadLocal<UserInfo>对象中，就可以在任何逻辑层、任何方法直接获取用户信息，提高了代码的简洁程度。</UserInfo></span><h2 id="3-存储原理"><a href="#3-存储原理" class="headerlink" title="3.存储原理"></a>3.存储原理</h2><p>Thread类中有个成员变量threadLocals，这个变量的引用类型是ThreadLocal中的一个内部类ThreadLocalMap，这个类没有实现Map接口，本质上是一个table数组，数组中每个元素都是K-V键值对组成的Entry对象，其中K就是ThreadLocal实例，V就是要存储的局部变量对象。<br><img src="/2020/03/16/ThreadLocal/threadLocals-%E7%BB%93%E6%9E%84%E5%9B%BE.png" class="lazyload" data-srcset="/2020/03/16/ThreadLocal/threadLocals-%E7%BB%93%E6%9E%84%E5%9B%BE.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h2 id="4-源码解析"><a href="#4-源码解析" class="headerlink" title="4.源码解析"></a>4.源码解析</h2><h3 id="4-1-hash算法"><a href="#4-1-hash算法" class="headerlink" title="4.1 hash算法"></a>4.1 hash算法</h3><p>ThreadLocalMap的存储逻辑和HashMap有一些相似的地方，内部都是维护一个Entry类型数组，然后通过对key的哈希码进行位与运算，定位出存储的数组坐标。ThreadLocal作为key提供的哈希码查询方法并非hashCode()，而是通过成员变量threadLocalHashCode去表达。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 哈希码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个哈希码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">        <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希码递增跨度值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希码递增方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存储哈希码的成员变量threadLocalHashCode被final修饰，也就意味着实例被创建时内部threadLocalHashCode固定为nextHashCode()方法返回的值。这个方法很有意思，每次调用都是将nextHashCode递增0x61c88647，并返回递增后的值。按照这个设计逻辑，每次创建的ThreadLocal实例的哈希值都是不同的，都会比上一次的哈希值高0x61c88647，并且考虑到会被多个线程创建，使用AtomicInteger维护递增值确保线程安全。</p><p>因此线程的threadLocals值必须由同一个实例进行存取，这样才能定位到同一个数组下坐标，这也是上述的例子中把ThreadLocal设计成static、final的原因。</p><h3 id="4-2-set-源码"><a href="#4-2-set-源码" class="headerlink" title="4.2 set()源码"></a>4.2 set()源码</h3><p>ThreadLocal的set方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取调用set方法的当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程的threadLocals属性</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经初始化，继续往里面增加键值对</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">// 如果没有初始化，创建一个ThreadLocalMap并增加一个键值对</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果ThreadLocalMap为null，调用createMap()初始化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 为调用set方法的当前线程初始化threadLocals属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用带参数构造器</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadLocalMap重载构造器 </span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化table数组容量为16</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对key的hashCode进行位与运算取余数，计算出存储到table数组的坐标</span></span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Entry插入ThreadLocalMap中，Entry构造器没啥复杂逻辑，不写了</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时长度固定为1，因为就一个Entry</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法是设置ThreadLocalMap扩容的阈值(固定为容量的2/3)，类似HashMap的负载因子</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Map已经被初始化，调用set()方法添加一个键值对:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Entry类型数组</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组长度</span></span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对哈希值使用位与运算定位到存储的数组坐标计作i</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将i坐标在数据中的值取出，赋值给e</span></span><br><span class="line">    <span class="comment">// 即使ThreadLocal实例的哈希值不同，位与运算后仍然会计算出相同的数组坐标，只要计算出的坐标已存储元素，for循环就继续下去</span></span><br><span class="line">    <span class="comment">// 每次循环完将i值重新赋值为i+1(如果+1后下标越界则赋值0)，并将新赋值的i坐标对应的数组元素赋值给e</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.每次循环取出数组坐标i对应的值，赋值给e</span></span><br><span class="line"><span class="comment">     * 2.虽然每个ThreadLocal实例的哈希值不同，但是经过位于运算后仍然会冲突，并且数组中每个坐标只会存储一个对象，</span></span><br><span class="line"><span class="comment">     *   不会像HashMap那样相同坐标使用链表或红黑树存储。</span></span><br><span class="line"><span class="comment">     * 3.如果通过i取出的Entry为空，则跳出for循环</span></span><br><span class="line"><span class="comment">     * 4.如果通过i取出的Entry不为空，进入循环体的逻辑处理，并且在处理完后对i+1操作(如果+1之后大于等于数组长度则设置为0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];     </span><br><span class="line">    e != <span class="keyword">null</span>; </span><br><span class="line">    e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行到这里，说明数组下坐标i对应的Entry不为空，将Entry的key提取出来</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果提取出来的key与需要set的key地址一致，直接覆盖其value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果实体类Entry不为null，所属的key不为null(下面统一称为过期元素)</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// k被回收，所在的e也没有存在的意义了，将需要设置的key、value覆盖到e中，覆盖完返回</span></span><br><span class="line">        replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里说明i的值已经递增到对应下坐标为null了，直接new一个Entry存储进去</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组长度+1</span></span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有找到过期元素，并且新增后数组的长度超过阈值，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Entry是过期元素，那么这个Entry也没有任何存在的意义，因为没有任何途径能拿到此Entry的value。这时候就需要调用replaceStaleEntry()方法将此Entry替换掉，将此数组坐标重新利用起来:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// staleSlot是前面set方法中检查出来的过期元素所在的坐标</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数组从slotToExpunge坐标向前遍历，直到碰到过期元素后终止</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">        (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">        i = prevIndex(i, len))</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果此Entry是过期元素，则将当前坐标赋值给slotToExpunge</span></span><br><span class="line"><span class="comment">         * 可以理解为循环结束后，slotToExpunge的值会变为:坐标staleSlot往左最左边的过期元素</span></span><br><span class="line"><span class="comment">         * 这个变量的作用是定位一个范围，清理过期元素工作就是将当前值作为数组坐标向右检查</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个循环是向后遍历，与上面的循环正好相反</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">        (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">        i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数组中Entry的key</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果之前存在相同的key</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 覆盖原value值</span></span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// staleSlot是前面set方法查询到的过期元素，与当前循环的坐标i交换位置</span></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这俩值相等说明上一个for循环，往左没有找到任何E过期元素</span></span><br><span class="line">            <span class="comment">// 到目前为止需要清理的过期元素只有set方法检查出来的那一个，当前坐标的key和value都有值</span></span><br><span class="line">            <span class="comment">// 然而上面俩行代码已经将当前坐标的Entry与set检查出来的Entry交换位置了</span></span><br><span class="line">            <span class="comment">// 所以当前坐标对应的Entry是过期数据，将当前坐标赋值给slotToExpunge，准备后续清理工作</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清理过期的数据</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// key的位置已经定位并覆盖value了，所有逻辑处理到此结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里说明要设置的key在数组中还没找到，并且左边的循环查询过期元素</span></span><br><span class="line">        <span class="comment">// 换句话说就是当前坐标i往左的元素都没毛病，往右检查清理元素的起点坐标要从i开始</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里说明数组遍历完了也没存在key，重新创建一个Entry并覆盖当前坐标</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这俩值相等，说明staleSlot坐标的左右元素都没问题，而且当前坐标也被新的Entry覆盖了，不需要清理</span></span><br><span class="line">    <span class="comment">// 如果不相等，要么坐标staleSlot的左边存在要清理的元素，要么就是右边，执行清理</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面对数组中Entry的检查中不难发现，无论往左还是往右一旦碰到为null的元素检查就停止了，这会漏掉一部分Entry的检查。因此在每次清理的时候，顺带将不为空的元素左移，挤出所有值为null的下坐标，确保所有不为null的Entry连续挨在一起。这些逻辑都在expungeStaleEntry方法中实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将上个方法检查出来的过期元素以及所属value的引用设置为null，方便GC回收</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组长度减1</span></span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顺着坐标向右遍历</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">        (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">        i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出当前坐标的key</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果key为空，则将Entry和内部value设置为null，方便GC回收，数组长度也要减1</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不为空,重新通过哈希值计算安插的数组坐标</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果通过哈希值计算的坐标不是当前坐标</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将当前坐标清空，对应的Entry已经被e指向，并不会丢掉</span></span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从哈希值计算的坐标开始，往右寻找null的坐标安放e，一旦发现要安插的坐标h左边有为null的坐标，就填充过去</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将e赋值到最终计算出的坐标</span></span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值i代表从staleSlot往右循环过程中，碰到的第一个为null的坐标</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cleanSomeSlots主要用于控制扫描，检查还存不存在有问题的元素，如果有就清理掉。扫描的趟数为log2(数组长度)，执行过程中一旦发现了过期元素，扫描趟数会重置，并且返回值变为true:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取i的下一个坐标</span></span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        <span class="comment">// 取出Entry</span></span><br><span class="line">        Entry e = tab[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果循环过程中发现了过期元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重置n的值，也就是需要再次扫描log2(n)趟</span></span><br><span class="line">            n = len;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回值removed设置为true</span></span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清理元素并记录清理的坐标</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// n每右移一次相当于n除以2，直到n除以2后小于0终止循环</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果为true，代表执行过程中出现需要清理的元素</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组扩容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要扩容前，再次清理一遍过期元素</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超过阈值的3/4，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span class="p red">整个set方法的执行过程分为俩部分，一部分是通过哈希值与数组长度的取余运算，定位到要存储的坐标，并解决坐标冲突的问题。另一部分也是最复杂的一部分，主要涉及到对过期元素的清理工作并防止内存泄漏，因为Entry对象中key的引用是弱引用，所指向的实例如果没有其他强引用指向，随时可能被回收掉。</span><ul><li><span class="p blue">通过实例的哈希值(threadLocalHashCode属性)，定位到要存储的坐标。</span></li><li><span class="p blue">计算出的坐标可能会冲突(类似hashMap的哈希碰撞)，这时需要对比已存储的Entry的key与要存储的key是否一致。</span></li><li><span class="p blue">如果key地址相同，直接覆盖value值，结束。</span></li><li><span class="p blue">如果key为null(过期元素)，将要set的值包装成Entry覆盖当前坐标，然后进行扫描并清除所有过期元素</span></li><li><span class="p blue">如果计算出来的坐标不存在冲突，直接插入此坐标</span></li><li><span class="p blue">如果达到扩容的阈值，对数组进行扩容</span></li></ul><h3 id="4-3-get-源码"><a href="#4-3-get-源码" class="headerlink" title="4.3 get()源码"></a>4.3 get()源码</h3><p>ThreadLocal的get方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取调用此方法的线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程的ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果map不为null</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数组元素Entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不为空，根据范型强转并返回，get方法到此结束</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里说明map为null，或者获取的Entry为null，初始化</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap的getEntry方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过hashcode定位数组坐标</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果坐标的Entry所属的key正是要提取的key，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 顺着坐标往右寻找</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果通过哈希值寻找Entry失败，也就是出现了坐标冲突，那就要往后遍历寻找:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 只要e不为null，就循环下去</span></span><br><span class="line">            <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 地址吻合说明当前Entry就是要找的对象，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (k == key)</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果发现过期元素，执行清除方法</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 记录遍历坐标的i+1</span></span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                <span class="comment">// 下一个Entry赋值给e</span></span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 到这里说明整个数组就不存在这个key</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>setInitialValue方法没啥逻辑，就是初始化线程的threadLocals:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法写死的，返回null</span></span><br><span class="line">    T value = initialValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程的threadLocals</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过get方法进入的，map肯定为null</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 初始化threadLocals，并插入一个value为null的Entry</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span class="p red">get方法相对于set方法而言要简单很多，无非就是根据哈希值计算数组坐标，顺带也会清理过期元素。</span><h3 id="4-4-remove-源码"><a href="#4-4-remove-源码" class="headerlink" title="4.4 remove()源码"></a>4.4 remove()源码</h3><p>ThreadLocal的remove()方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程的map</span></span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="comment">// 如果猫已经初始化，调用map的remove方法</span></span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap的remove方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组信息</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过哈希值计算数组坐标赋值给i</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顺着坐标i往右遍历</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">        e != <span class="keyword">null</span>;</span><br><span class="line">        e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果发现过期元素</span></span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对当前Entry进行清理，方便GC回收</span></span><br><span class="line">            e.clear();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个方法上面已经讲过了，向右扫描并清理过期元素</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span class="p red">remove方法的作用不仅仅是清除指定的key，还会调用expungeStaleEntry()方法将清除的坐标继续向右遍历，清除遇到的所有过期元素，并且将null的坐标剔除掉。</span><h2 id="5-内存泄漏"><a href="#5-内存泄漏" class="headerlink" title="5.内存泄漏"></a>5.内存泄漏</h2><p>使用ThreadLocal可能出现的内存泄漏，是指value使用完毕后并没有被<span class="p red">及时的清理掉</span>。通俗点讲，我们希望线程执行完某个步骤后(value后续不会被使用)、生命周期结束前；或者线程执行完某个步骤后、归还线程池前，或者线程生命周期结束后；就该被清除但没被清除，都可以定义为<span class="p red">内存泄漏</span>。</p><span class="p red">从乐观的角度看，ThreadLocal导致的内存泄漏并不一定导致内存溢出，也许value只是在内存中多逗留了一会。</span><h3 id="5-1-弱引用"><a href="#5-1-弱引用" class="headerlink" title="5.1 弱引用"></a>5.1 弱引用</h3><p>每个线程内部会维护一个ThreadLocalMap，用于存储当前线程的私有变量，ThreadLocalMap内部所有Entry都是以ThreadLocal对象作为key，并且Entry的key对ThreadLocal是弱引用，但是对value是强引用。如图:<br><img src="/2020/03/16/ThreadLocal/ThreadLocal%E5%BC%95%E7%94%A8%E9%93%BE.png" class="lazyload" data-srcset="/2020/03/16/ThreadLocal/ThreadLocal%E5%BC%95%E7%94%A8%E9%93%BE.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>解决内存泄漏最直接有效的办法，就是保持使用完毕后调用remove()方法的习惯，但ThreadLocal的设计者为了避免开发者忘记调用remove()方法，提供了弱引用机制尽可能的避免内存泄漏。之所以这么说，是因为弱引用并不能百分百的避免内存泄漏，只能解决部分特定场景。</p><p>从上面的源码可以看出，每次调用get()、set()方法时，会去检查所有key为null的Entry并清除。也就是说，即使没有调用remove()方法，对应的ThreadLocal对象变成null，线程后续用到其他ThreadLocal对象的get()、set()方法时，依然可以自动帮你清理(不用白搭)。</p><p>我们平时使用ThreadLocal对象，要么设置为static全局共享，要么每次都new一个新的；在使用线程方面，要么每次创建新的线程，要么将线程池化。组合起来就是四种场景，到底哪些场景JDK可以帮我们避免，哪些需要我们开发时注意的，得一个个单独分析。</p><h3 id="5-2-非静态化与普通线程"><a href="#5-2-非静态化与普通线程" class="headerlink" title="5.2 非静态化与普通线程"></a>5.2 非静态化与普通线程</h3><p>ThreadLocal每次使用的时候，都是new出一个新对象，线程每次也都是创建新对象。这种场景比较少见，也比较奇葩，因为ThreadLocal设计的意图，就是让value可以在任何地方获取到，这就代表任何需要value的方法，都得将ThreadLocal作为参数传进去，为啥不直接传value呢。</p><p>另外，当线程执行完某个方法，后续不再需要value时，方法出栈后ThreadLocal对象就仅剩Entry中的key弱引用形式指向它，肯定会被回收。这时Entry中的key就变成了null，如果线程后续使用了其他ThreadLocal对象的get()、set()方法，之前的value就会被自动回收。</p><span class="p red">如果Entry的key不是弱引用，key对于ThreadLocal对象是强引用，即使出栈也不会被回收，在不调用remove()方法的前提下，也就无法尽可能提前回收value。但就算没有提前回收，线程生命周期结束，ThreadLocal与线程对象都会被回收，对应的value也就GC不可达，最终还是会被回收。</span><h3 id="5-3-非静态化与线程池"><a href="#5-3-非静态化与线程池" class="headerlink" title="5.3 非静态化与线程池"></a>5.3 非静态化与线程池</h3><p>ThreadLocal每次使用的时候，都是new出一个新对象，处理任务的线程则是从线程池中获取。由于线程不会被销毁，并且会不停的处理任务，在开发者忘记调用remove()方法的前提下，会不停的往自身的ThreadLocalMap中添加value。由于ThreadLocal每次都是new出来的，弱引用设计的存在保证能被及时回收，当线程下次执行任务并用到ThreadLocal时，能自动的将上次任务用到的value清除掉。</p><span class="p red">弱引用在此场景的作用，除了尽可能的提前回收value外，还可以避免内存溢出。假设没有弱引用，线程归还线程池时，value在ThreadLocalMap中依然存在。即使下次执行任务并调用get()、set()方法，由于上次设置的Entry的key不为null，依然无法将其清除，并且value只增不减，时间久了必定导致内存溢出。</span><h3 id="5-4-静态化与普通线程"><a href="#5-4-静态化与普通线程" class="headerlink" title="5.4 静态化与普通线程"></a>5.4 静态化与普通线程</h3><p>将ThreadLocal设置为静态变量或常量，是目前比较常见的使用方式。这意味着ThreadLocal对象被class对象强引用，永远不可能被删除，弱引用也就发挥不了任何作用，开发者如果忘记调用remove()方法，是无法进行提前回收的，只能等线程生命周期结束后被GC回收。</p><h3 id="5-5-静态化与线程池"><a href="#5-5-静态化与线程池" class="headerlink" title="5.5 静态化与线程池"></a>5.5 静态化与线程池</h3><p>这种场景在实际开发中使用最多，由于ThreadLocal对象被class对象强引用，永远不可能被删除，线程也不会被销毁，这就要求开发者每次使用完必须手动调用remove()方法，否则value会永远停留在线程的ThreadLocalMap中，这就有几率造成内存溢出。</p><p>为什么说有几率而不是百分百造成内存溢出呢？比如上面提到的用户登陆信息存储，虽然springMVC使用线程池来处理http请求，但好在每次进入拦截器都会重新设置value，上次请求产生的value对象在Entry中被覆盖，仅有的一个指向它的引用也没了，自然会被回收。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>线程的局部变量是存储在线程自身的ThreadLocalMap中，ThreadLocalMap与HashMap都属于键值对映射结构，不过ThreadLocalMap采用数组线性探测的方式存储数据，HashMap使用数组+链表存储数据。</p><p>而ThreadLocal对象仅仅只是个方便存取数据的快捷键而已，一般都是创建静态变量并提供静态存取方法，使用起来比较方便。另外在使用完毕后尽量使用remove()方法进行清理，方便GC尽快回收。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程(十五) 同步工具类-Phaser</title>
      <link href="2020/03/15/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB-Phaser/"/>
      <url>2020/03/15/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB-Phaser/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Phaser表示<span class="p red">阶段器</span>，用来解决控制多个线程分阶段共同完成任务的情景问题。它的功能与 CyclicBarrier和CountDownLatch有些类似，类似于一个多阶段的栅栏，并且功能更强大。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程(十四) 同步工具类-Exchanger</title>
      <link href="2020/03/14/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB-Exchanger/"/>
      <url>2020/03/14/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB-Exchanger/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Exchanger也是一个线程同步的辅助类，用于两个线程之间交换信息。通过exchange方法相互交换数据，如果第一个执行到exchange方法，会等待第二个线程执行exchange，当两个线程都到达时，会进行数据交换。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程(十三) 同步工具类-Semaphore</title>
      <link href="2020/03/13/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB-Semaphore/"/>
      <url>2020/03/13/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB-Semaphore/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Semaphore也是一个线程同步的辅助类，在多线程环境下用于协调各个线程, 以保证它们能够正确、合理的使用公共资源。信号量维护了一个许可集，我们在初始化Semaphore时需要为这个许可集传入一个数量值，该数量值代表同一时间能访问共享资源的线程数量。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>这个应用就比较广泛了，主要用于流量控制，例如限制某接口或者静态资源的最大并发访问数，上代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    private static Semaphore semaphore &#x3D; new Semaphore(2);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D;1; i &lt;&#x3D; 10; i++)&#123;</span><br><span class="line"></span><br><span class="line">            Thread thread &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    select();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            thread.setName(&quot;线程序号&quot; + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Object select()&#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 注册</span><br><span class="line">            semaphore.acquire();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 模拟查询耗时</span><br><span class="line">            Thread.currentThread().sleep(500L);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 打印信息</span><br><span class="line">            StringBuilder info &#x3D; new StringBuilder();</span><br><span class="line">            info.append(Thread.currentThread().getName());</span><br><span class="line">            info.append(&quot;进入查询方法,&quot;);</span><br><span class="line">            info.append(&quot;空闲通道:&quot;).append(semaphore.drainPermits());</span><br><span class="line">            info.append(&quot;,&quot;);</span><br><span class="line">            info.append(&quot;等待线程数:&quot;).append(semaphore.getQueueLength());</span><br><span class="line">            System.out.println(info.toString());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            &#x2F;&#x2F; 释放</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果:<br>线程序号1进入查询方法,空闲通道:0,等待线程数:8<br>线程序号2进入查询方法,空闲通道:0,等待线程数:8<br>线程序号3进入查询方法,空闲通道:0,等待线程数:6<br>线程序号4进入查询方法,空闲通道:0,等待线程数:6<br>线程序号5进入查询方法,空闲通道:0,等待线程数:4<br>线程序号6进入查询方法,空闲通道:1,等待线程数:4<br>线程序号7进入查询方法,空闲通道:0,等待线程数:3<br>线程序号8进入查询方法,空闲通道:0,等待线程数:2<br>线程序号9进入查询方法,空闲通道:0,等待线程数:1<br>线程序号10进入查询方法,空闲通道:0,等待线程数:0</p><p>打印结果可以看出来，同一时刻只能有2个线程对方法进行访问。</p><h2 id="构造器源码"><a href="#构造器源码" class="headerlink" title="构造器源码"></a>构造器源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 默认使用非公平锁</span><br><span class="line">public Semaphore(int permits) &#123;</span><br><span class="line">    sync &#x3D; new NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以通过构造器参数指定是否公平竞争</span><br><span class="line">public Semaphore(int permits, boolean fair) &#123;</span><br><span class="line">    sync &#x3D; fair ? new FairSync(permits) : new NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Semaphore对象可以通过构造器指定访问限制，还可以指定争夺的公平方式。</p><h2 id="Sync源码"><a href="#Sync源码" class="headerlink" title="Sync源码"></a>Sync源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 1192457210091910933L;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 初始化访问</span><br><span class="line">    Sync(int permits) &#123;</span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final int getPermits() &#123;</span><br><span class="line">        return getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 非公平方式获取AQS共享式资源</span><br><span class="line">    final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">        &#x2F;&#x2F; 自旋</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取state值</span><br><span class="line">            int available &#x3D; getState();</span><br><span class="line">            &#x2F;&#x2F; 计算获取资源后值应该是多少</span><br><span class="line">            int remaining &#x3D; available - acquires;</span><br><span class="line">            &#x2F;&#x2F; 如果大于等于0说明满足条件，将计算后值通过CAS修改后返回，如果小于0直接返回</span><br><span class="line">            if (remaining &lt; 0 ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                return remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 释放锁，就是把state加回来</span><br><span class="line">    protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取state值</span><br><span class="line">            int current &#x3D; getState();</span><br><span class="line">            &#x2F;&#x2F; 计算加后的值</span><br><span class="line">            int next &#x3D; current + releases;</span><br><span class="line">            &#x2F;&#x2F; 如果加后值小于当前state值，说明参数为负数，抛异常</span><br><span class="line">            if (next &lt; current) &#x2F;&#x2F; overflow</span><br><span class="line">                throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">            &#x2F;&#x2F; 使用CAS方式修改值</span><br><span class="line">            if (compareAndSetState(current, next))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; state减操作</span><br><span class="line">    final void reducePermits(int reductions) &#123;</span><br><span class="line">        &#x2F;&#x2F; 自旋</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取state值</span><br><span class="line">            int current &#x3D; getState();</span><br><span class="line">            &#x2F;&#x2F; 计算减后的值</span><br><span class="line">            int next &#x3D; current - reductions;</span><br><span class="line">            &#x2F;&#x2F; 如果减后值大于当前state值，说明参数为负数，抛异常</span><br><span class="line">            if (next &gt; current) &#x2F;&#x2F; underflow</span><br><span class="line">                throw new Error(&quot;Permit count underflow&quot;);</span><br><span class="line">            &#x2F;&#x2F; 使用CAS方式修改值</span><br><span class="line">            if (compareAndSetState(current, next))</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将state归零</span><br><span class="line">    final int drainPermits() &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 自旋</span><br><span class="line">        for (;;) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 获取state</span><br><span class="line">            int current &#x3D; getState();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果是0直接返回0，不是0使用CAS设置成0在返回0，这是要干啥？</span><br><span class="line">            if (current &#x3D;&#x3D; 0 || compareAndSetState(current, 0))</span><br><span class="line">                return current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync类实现了很多方法:</p><ul><li>nonfairTryAcquireShared():非公平性获取共享式锁，不进行排队直接自旋获取。</li><li>tryReleaseShared():释放共享式锁，使用CAS方式对state执行加操作。</li><li>reducePermits():使用CAS方式对state执行减操作。</li><li>drainPermits():将state设置为0并返回，不知道想干啥?</li></ul><h2 id="公平-非公平Sync源码"><a href="#公平-非公平Sync源码" class="headerlink" title="公平/非公平Sync源码"></a>公平/非公平Sync源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非公平</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; -2694183684443567898L;</span><br><span class="line"></span><br><span class="line">    NonfairSync(int permits) &#123;</span><br><span class="line">        super(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 调用父类写好的方法，非公平式获取锁</span><br><span class="line">    protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        return nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 公平</span><br><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 2014338818796000944L;</span><br><span class="line"></span><br><span class="line">    FairSync(int permits) &#123;</span><br><span class="line">        super(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 无限自旋直到CAS修改成功</span><br><span class="line">    protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 比非公平锁多了一个步骤，判断前面是否有人,如果前面有人就放弃</span><br><span class="line">            if (hasQueuedPredecessors())</span><br><span class="line">                return -1;</span><br><span class="line">            int available &#x3D; getState();</span><br><span class="line">            int remaining &#x3D; available - acquires;</span><br><span class="line">            if (remaining &lt; 0 ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                return remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平与非公平Sync逻辑几乎一样，只是公平锁在尝试获取资源的时候会先去判断前面是否已经有人，如果有人就放弃尝试，进入AQS的等待阻塞方法。而非公平锁不管前面有没有人都会尝试获取直到成功。</p><h2 id="acquire-源码"><a href="#acquire-源码" class="headerlink" title="acquire()源码"></a>acquire()源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 先判断是否已经被中断        </span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果访问次数已经耗尽，进入doAcquireSharedInterruptibly()方法阻塞</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 源码就不贴了，AQS写好的方法:</span><br><span class="line">         * 排在等待队列的第一个，自旋等待直到重写方法tryAcquireShared(arg)返回值大于0跳出自旋</span><br><span class="line">         * 排在等待队列的第二个开始，直接挂起一边呆着去...</span><br><span class="line">         *&#x2F;</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这没啥好说的，只不过现在都是分布式项目，如果限流的目的是减少数据库或静态资源的访问，单靠Semaphore无法实现，还需要依靠基于Redis或Zookeeper的分布式锁实现，感觉用处不多。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程(十二) 同步工具类-CyclicBarrier</title>
      <link href="2020/03/12/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB-CyclicBarrier/"/>
      <url>2020/03/12/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB-CyclicBarrier/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>CyclicBarrier是一个同步的辅助类，允许一组线程相互之间等待，并设置一个公共屏障点，当组内线程达到这个屏障点的时候阻塞，阻塞在这个屏障点的线程数达到指定数量时，释放所有线程继续往下执行。CyclicBarrier在释放完线程后相当于重置之前的记录可以循环使用，所以称之为Cyclic(循环)Barrier(屏障)。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>开发经历有限，目前为止还真没用过CyclicBarrier，一般场景使用CountDownLatch就够了，就随便写点吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    private static CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(5, new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;屏障点回调线程，执行者:&quot; + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0; i&lt; 5;i++)&#123;</span><br><span class="line"></span><br><span class="line">            Thread thread &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot;开始运行&quot;);</span><br><span class="line">                        cyclicBarrier.await();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot;结束运行&quot;);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            thread.setName(&quot;线程&quot; + i);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果:<br>线程1开始运行<br>线程0开始运行<br>线程2开始运行<br>线程3开始运行<br>线程4开始运行<br>屏障点回调线程，执行者:线程4<br>线程4结束运行<br>线程1结束运行<br>线程0结束运行<br>线程2结束运行<br>线程3结束运行</p><p>打印结果可以看出来，当指定数量(构造器参数决定)的线程到达屏障点(await代码行)后，才能继续往下执行。如果在构造器中指定了回调线程，还需要等待回调线程执行完才可以往下执行，回调线程由最后一个阻塞的线程执行。</p><h2 id="构造器源码"><a href="#构造器源码" class="headerlink" title="构造器源码"></a>构造器源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置屏障阈值</span><br><span class="line">public CyclicBarrier(int parties) &#123;</span><br><span class="line">    this(parties, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置屏障阈值，同时增加回调线程功能</span><br><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">    if (parties &lt;&#x3D; 0) throw new IllegalArgumentException();</span><br><span class="line">    this.parties &#x3D; parties;</span><br><span class="line">    this.count &#x3D; parties;</span><br><span class="line">    this.barrierCommand &#x3D; barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; lock对象</span><br><span class="line">private final ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 跳闸，可以理解为打开屏障</span><br><span class="line">private final Condition trip &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 屏障阈值</span><br><span class="line">private final int parties;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 回调线程</span><br><span class="line">private final Runnable barrierCommand;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 每次使用屏障都会生成，内部的broken标记屏障是否破损</span><br><span class="line">private Generation generation &#x3D; new Generation();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 默认设置false</span><br><span class="line">private static class Generation &#123;</span><br><span class="line">    boolean broken &#x3D; false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="await-源码"><a href="#await-源码" class="headerlink" title="await()源码"></a>await()源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 内部调用dowait()方法，并且参数传false，不支持超时</span><br><span class="line">    public int await() throws InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return dowait(false, 0L);</span><br><span class="line">        &#125; catch (TimeoutException toe) &#123;</span><br><span class="line">            throw new Error(toe); &#x2F;&#x2F; cannot happen</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 真正进入等待的逻辑</span><br><span class="line">    private int dowait(boolean timed, long nanos)</span><br><span class="line">        throws InterruptedException, BrokenBarrierException,</span><br><span class="line">               TimeoutException &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    &#x2F;&#x2F; 获取排他锁</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        final Generation g &#x3D; generation;</span><br><span class="line">        &#x2F;&#x2F; 屏障被破坏则抛异常</span><br><span class="line">        if (g.broken)</span><br><span class="line">            throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 线程中断 则退出屏障</span><br><span class="line">            breakBarrier();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 到达屏障的计数-1</span><br><span class="line">        int index &#x3D; --count;      </span><br><span class="line">        if (index &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; tripped</span><br><span class="line">            &#x2F;&#x2F; index &#x3D;&#x3D; 0, 说明指定 count 的线程均到达屏障，此时可以打开屏障</span><br><span class="line">            boolean ranAction &#x3D; false;</span><br><span class="line">            try &#123;</span><br><span class="line">                final Runnable command &#x3D; barrierCommand;</span><br><span class="line">                if (command !&#x3D; null)</span><br><span class="line">                    &#x2F;&#x2F; 若指定了 barrierCommand 则执行</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction &#x3D; true;</span><br><span class="line">                &#x2F;&#x2F; 唤醒阻塞在屏障的线程并重置 generation</span><br><span class="line">                nextGeneration();</span><br><span class="line">                return 0;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; loop until tripped, broken, interrupted, or timed out</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!timed)</span><br><span class="line">                    &#x2F;&#x2F; 若未指定阻塞在屏障处的等待时间，则一直等待；直至最后一个线程到达屏障处的时候被唤醒</span><br><span class="line">                    trip.await();</span><br><span class="line">                else if (nanos &gt; 0L)</span><br><span class="line">                    &#x2F;&#x2F; 若指定了阻塞在屏障处的等待时间，则在指定时间到达时会返回</span><br><span class="line">                    nanos &#x3D; trip.awaitNanos(nanos);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                if (g &#x3D;&#x3D; generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 若等待过程中，线程发生了中断，则退出屏障</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    throw ie;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; We&#39;re about to finish waiting even if we had not</span><br><span class="line">                    &#x2F;&#x2F; been interrupted, so this interrupt is deemed to</span><br><span class="line">                    &#x2F;&#x2F; &quot;belong&quot; to subsequent execution.</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 屏障被破坏 则抛出异常</span><br><span class="line">            if (g.broken)</span><br><span class="line">                throw new BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            if (g !&#x3D; generation)</span><br><span class="line">                &#x2F;&#x2F; g !&#x3D; generation 说明所有线程均到达屏障处 可直接返回</span><br><span class="line">                &#x2F;&#x2F; 因为所有线程到达屏障处的时候，会重置 generation</span><br><span class="line">                &#x2F;&#x2F; 参考 nextGeneration</span><br><span class="line">                return index;</span><br><span class="line"></span><br><span class="line">            if (timed &amp;&amp; nanos &lt;&#x3D; 0L) &#123;</span><br><span class="line">                &#x2F;&#x2F; 说明指定时间内，还有线程未到达屏障处，也就是等待超时</span><br><span class="line">                &#x2F;&#x2F; 退出屏障</span><br><span class="line">                breakBarrier();</span><br><span class="line">                throw new TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nextGeneration-源码"><a href="#nextGeneration-源码" class="headerlink" title="nextGeneration()源码"></a>nextGeneration()源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void nextGeneration() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 唤醒阻塞在等待队列的线程</span><br><span class="line">    trip.signalAll();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 重置 count</span><br><span class="line">    count &#x3D; parties;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 重置 generation</span><br><span class="line">    generation &#x3D; new Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="breakBarrier-源码"><a href="#breakBarrier-源码" class="headerlink" title="breakBarrier()源码"></a>breakBarrier()源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void breakBarrier() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; broken 设置为 true</span><br><span class="line">    generation.broken &#x3D; true;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 重置 count</span><br><span class="line">    count &#x3D; parties;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 唤醒等待队列的线程</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reset-源码"><a href="#reset-源码" class="headerlink" title="reset()源码"></a>reset()源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">    &#x2F;&#x2F; 唤醒阻塞的线程</span><br><span class="line">    breakBarrier();   &#x2F;&#x2F; break the current generation</span><br><span class="line">    &#x2F;&#x2F; 重新设置 generation</span><br><span class="line">    nextGeneration(); &#x2F;&#x2F; start a new generation</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CyclicBarrier依赖与Lock与Condition实现，await()方法使用Lock进行互斥，Condition对象负责挂起被屏障挡住的线程。Lock与Condition底层是基于AQS的，所以CyclicBarrier还是通过AQS实现。</p><p>CyclicBarrier内部有个屏障是否被打破的概念，维护在内部类Generation的broken属性中(默认是false)，并且可以通过breakBarrier()方法进行打破(修改为true)，调用这个方法的地方有三个，检测到中断、等待超时、reset()方法。当某个线程在等待过程中被中断或超时，会直接抛中断异常退出等待，不会对count执行-1操作，这会导致同一组线程会无限等待下去，因为count值永远无法到达0。使用reset()方法会重置count值，为了避免重置时还有残余线程没执行到await()方法，干扰重置后的count值导致下一轮提前结束。当遇到这些情况时，CyclicBarrier会修改broken=true来通知其他线程不要再等下去了。</p><p>CountDownLatch与CyclicBarrier区别:</p><table><thead><tr><th>CountDownLatch</th><th>CyclicBarrier</th></tr></thead><tbody><tr><td>一个线程(或多个)线程等待另N个线程完成某事后才能继续执行</td><td>N个线程相互在某个点等待，知道所有线程都到达这个点解除等待</td></tr><tr><td>无法重复利用，没有提供state属性的重置方法</td><td>可以重复利用，提供reset()方法重置</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程(十一) 同步工具类-CountDownLatch</title>
      <link href="2020/03/11/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB-CountDownLatch/"/>
      <url>2020/03/11/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB-CountDownLatch/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>CountDownLatch是一种线程同步工具类，它允许一个或多个线程等待直到在其他线程中一组操作执行完成。你可以把它理解为一个计数器，对象被创建的时候指定总数，每有一个线程到达指定条件总数减1，当减到为0时代表所有线程都达到条件，所有等待线程被唤醒继续往下执行，因此CountDownlatch也被称为<span class="p red">倒计时锁</span>。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>例如运营系统的流量、业务等统计功能，页面需要统计展示每日的新增用户量、订单数量、商品销售总量、商品销售总额等。如果每个统计类型的查询需要2秒，4个统计类型就需要8秒的时间才能返回给前端，用户显然是无法接受的。我们只需要将4个统计类型的查询由串行执行改为并行执行，等待所有线程都查询完在组装返回，那么整个请求的响应时间就缩短到的了2秒。</p><p>写个简单的Demo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        long startTimeMillis &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch &#x3D; new CountDownLatch(4);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Long&gt; statisticsMap &#x3D; new Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 1.查询新增用户量</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 模拟两秒查询</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(2000L);</span><br><span class="line">                    statisticsMap.put(&quot;addUserCount&quot;, 1000L);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F; 倒计时锁-1</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2.查询订单数量</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 模拟两秒查询</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(2000L);</span><br><span class="line">                    statisticsMap.put(&quot;orderCount&quot;, 248300L);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F; 倒计时锁-1</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3.查询商品销售总量</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 模拟两秒查询</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(2000L);</span><br><span class="line">                    statisticsMap.put(&quot;commodityCount&quot;, 300L);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F; 倒计时锁-1</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 4.查询商品销售总额</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 模拟两秒查询</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(2000L);</span><br><span class="line">                    statisticsMap.put(&quot;totalSales&quot;, 9073180L);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F; 倒计时锁-1</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long takeTimeMillis &#x3D; System.currentTimeMillis() - startTimeMillis;</span><br><span class="line">        System.out.println(&quot;耗时:&quot; + takeTimeMillis + &quot;ms&quot;);</span><br><span class="line">        System.out.println(&quot;返回值:&quot; + statisticsMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>耗时:2006ms<br>返回值:{commodityCount=300, totalSales=9073180, orderCount=248300, addUserCount=1000}</p><h2 id="构造器源码"><a href="#构造器源码" class="headerlink" title="构造器源码"></a>构造器源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public CountDownLatch(int count) &#123;</span><br><span class="line">    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</span><br><span class="line">    this.sync &#x3D; new Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch底层基于AQS实现，当我们调用CountDownLatch countDownLatch= new CountDownLatch(4) 创建一个实例时，会在对象内部创建一个继承AQS的Sync类，并将构造器的参数值赋值给state，所以state的值也代表CountDownLatch所剩余的计数次数。</p><h2 id="Sync源码"><a href="#Sync源码" class="headerlink" title="Sync源码"></a>Sync源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private static final class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 4982264981922014374L;</span><br><span class="line"></span><br><span class="line">    Sync(int count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getCount() &#123;</span><br><span class="line">        return getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据计数值是否耗尽(为0就算耗尽)，返回正数(1)或者负数(-1)</span><br><span class="line">    protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">        return (getState() &#x3D;&#x3D; 0) ? 1 : -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 共享式释放锁的逻辑重写，主要提供给countDown()使用</span><br><span class="line">    protected boolean tryReleaseShared(int releases) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 自旋</span><br><span class="line">        for (;;) &#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 获取当前state值</span><br><span class="line">            int c &#x3D; getState();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果state&#x3D;0，说明计数值已经耗尽了，不需要继续释放</span><br><span class="line">            if (c &#x3D;&#x3D; 0)</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 使用CAS方式-1</span><br><span class="line">            int nextc &#x3D; c-1;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果减完为0，证明是最后一个释放的，返回true</span><br><span class="line">            if (compareAndSetState(c, nextc))</span><br><span class="line">                return nextc &#x3D;&#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync除了维护了state值以外，分别重写了tryAcquireShared()与tryReleaseShared()方法，主要提供给CountDownLatch的countDown()与await()方法调用。</p><h2 id="countDown-源码"><a href="#countDown-源码" class="headerlink" title="countDown()源码"></a>countDown()源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 内部调用AQS的共享式释放锁</span><br><span class="line">public void countDown() &#123;</span><br><span class="line">       sync.releaseShared(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; AQS的共享式释放锁</span><br><span class="line">   public final boolean releaseShared(int arg) &#123;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; if中的方法被CountDownLatch重写，仅当state不为0并且修改后为0时才返回true</span><br><span class="line">       if (tryReleaseShared(arg)) &#123;</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; 如果state修改后是0，说明自己是最后一个执行完毕的，需要唤醒所有等待的线程</span><br><span class="line">           doReleaseShared();</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; countDown()方法并没有利用返回值做其他事情，可以无视</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>countDown()方法的逻辑非常简单，就是利用静态内部类Sync的重写方法tryReleaseShared()，使用CAS方式对计数值(state)-1操作。如果返回true证明自身是最后一个执行完成的，还需要唤醒所有阻塞的等待线程。</p><h2 id="await-源码"><a href="#await-源码" class="headerlink" title="await()源码"></a>await()源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 内部调用AQS的共享式获取锁方式(支持中断)</span><br><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">       sync.acquireSharedInterruptibly(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; AQS共享式获取锁方式(支持中断)</span><br><span class="line">   public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">           throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 如果已经是中断状态，直接抛出来</span><br><span class="line">       if (Thread.interrupted())</span><br><span class="line">           throw new InterruptedException();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 调用重写的共享式获取锁方法，如果返回值小于0证明计数值还没有耗尽，需要加入等待队列</span><br><span class="line">       if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">           &#x2F;&#x2F; AQS的方法，前面已经解释过了，排队的第一个自旋等待，后面的挂起等待，直到tryAcquireShared()&gt;&#x3D;0</span><br><span class="line">           doAcquireSharedInterruptibly(arg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>await()方法无非就是阻塞，第一个调用此方法的线程是自旋等待，直到计数值耗尽(state=0)跳出，如果有多个线程调用此方法等待，则使用park()函数挂起直到被唤醒。并且提供重载方法支持超时放弃，等待过程中支持中断响应。</p><h2 id="await-timeout-unit-源码"><a href="#await-timeout-unit-源码" class="headerlink" title="await(timeout, unit)源码"></a>await(timeout, unit)源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 内部调用AQS的共享式获取锁方式(支持超时与中断)</span><br><span class="line">public boolean await(long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AQS的共享式获取锁方式(支持超时与中断)</span><br><span class="line">public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    &#x2F;&#x2F; 先做中断校验</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果tryAcquireShared()方法返回值大于0，也就是已经计数值已耗尽(state&#x3D;0) 直接返回就好了</span><br><span class="line">    &#x2F;&#x2F; 如果没有耗尽，进入阻塞方法，也是AQS源码 不解释了...</span><br><span class="line">    return tryAcquireShared(arg) &gt;&#x3D; 0 ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在await()基础上增加超时功能，防止意外情况导致条件永远无法满足，等待线程一直阻塞。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CountDownLatch的作用是牺牲运行内存(额外创建的线程需要额外的栈空间支出)以及CPU资源(请求过程中会有额外的线程加入CPU使用权争夺)来提高请求的响应效率。因此CountDownLatch不能盲目使用，要参考JVM大小、CPU核数等配置信息，还要估算接口的QPS，避免大量请求导致JVM栈溢出或CPU使用率到100%。</p><p>在创建CountDownLatch时，构造器参数值一定要和处理任务的子线程数相等，避免高于子线程数量造成死锁，或者低于子线程数造成部门数据丢失。子线程的countDown()方法最好放在finally代码块中，避免执行过程中出现异常导致没有被执行。为了保险起见，主线程最好使用支持超时的await()进行等待，彻底解决可能出现的死锁情况。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程(十) 线程通信</title>
      <link href="2020/03/10/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
      <url>2020/03/10/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>线程与线程之间不是相互独立的个体，有些时候需要相互通信来共同完成某个业务场景，多线程之间通信总体来说分为<span class="p red">共享内存和消息通信机制</span>。</p><h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>wait/notify采用消息通信机制来进行线程间的通信，某个线程必须达到特定条件才能继续执行下去，没有达到就将自己挂起等待，另一个线程的执行过程中会使条件达成并通知挂起等待的线程继续执行下去。</p><p>wait/notify都属于Object的方法，利用java自带的对象加锁机制争夺对应monitor，当线程不满足执行条件时调用Object的wait方法将自己挂起在monitor对象的_WaitSet上，其他线程在执行过程中将条件满足，紧接着使用Object的notify或notifyAll方法唤醒前述的等待线程，重新加入锁的竞争。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>例如线程独有的join()方法就是通过wait/notify实现线程的合并(非异步调用)，在join线程执行过程中调用者线程只能等待，为了避免CPU的浪费，使用wait()方法将自己挂起在join线程的monitor对象的_WaitSet中，当join线程执行完毕后使用notify()唤醒调用者线程，继续往下执行。</p><p>简单的使用场景比如RocketMQ拉取消息时的长轮询机制，在拉取不到消息的时候将其挂起，直到Producer向本结点投递消息时，唤醒挂起的请求线程，拉取消息并返回。</p><p>复杂点的使用场景例如生产者/消费者模式，消费者线程使用while循环监听消息，如果消息队列为空则使用wait()将自己挂起，同样避免忙等造成CPU的浪费，生产者线程每次生产完数据都必须调用notify()方法，唤醒因消息队列为空而将自己挂起的消费者线程。下面是一段基于wait/notify机制的生产/消费模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">private static Object obj &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">    private static final Queue&lt;String&gt; messageQueue &#x3D; new LinkedBlockingDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">Thread producerThread &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line"></span><br><span class="line">                for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 生产消息</span><br><span class="line">                    synchronized (obj) &#123;</span><br><span class="line">                        messageQueue.add(&quot;第&quot; + i + &quot;条消息&quot;);</span><br><span class="line">                        obj.notify();</span><br><span class="line">                    &#125;      </span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 每生产三条暂停1秒</span><br><span class="line">                    if (i &gt; 1 &amp;&amp; i % 3 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            System.out.println(&quot;暂停&quot;);</span><br><span class="line">                            Thread.currentThread().sleep(1000L);</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread consumerThread &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line"></span><br><span class="line">                synchronized (obj) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        while (true) &#123;</span><br><span class="line"></span><br><span class="line">                            if (messageQueue.isEmpty()) &#123;</span><br><span class="line">                                obj.wait();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            String message &#x3D; messageQueue.poll();</span><br><span class="line">                            System.out.println(&quot;消费者:&quot; + message);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#x2F;&#x2F; ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producerThread.start();</span><br><span class="line">        consumerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><p><strong>为什么wait()、notify()、notifyAll()必须在同步代码块中？</strong><br>这三个方法都是对对象的monitor中的_WaitSet进行操作，而进入同步代码块意味着已经持有对象锁，也就持有了monitor，才有资格对_WaitSet进行操作，因此必须在同步代码块中。</p><p><strong>为什么wait()方法要放在while()循环而不是if中？</strong><br>被唤醒后线程从wait()代码之后继续执行，但是并不能保证每次被唤醒都是符合继续执行条件的，用while()被唤醒还会继续判断，不符合条件永远在while()中，而if不会。在N个线程通信的情况下，不能保证那一时刻条件被某个线程改变。</p><p><strong>为什么wait()、notify()要定义在Object中而不是线程中？</strong><br>wait()与notify()的基本思想是把某个对象作为联络点，利用锁机制拿到monitor进行联络通信，而java提供的锁是对象级的而不是线程级的，锁属于对象而不是线程专有，因此wait()、notify()、notifyAll()这种锁级别操作属于Object而不是线程专有方法。</p><h2 id="lock-condition"><a href="#lock-condition" class="headerlink" title="lock/condition"></a>lock/condition</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>既然java支持使用锁进行线程通信，synchronized可以，Lock必然也可以。lock/condition与wait/notify功能类似，通过Lcok对象创建Condition对象，利用Condition对象的await()与signal()方法来阻塞唤醒。</p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>无</p><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程(九) Lock家族</title>
      <link href="2020/03/09/Lock%E5%AE%B6%E6%97%8F/"/>
      <url>2020/03/09/Lock%E5%AE%B6%E6%97%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Lock继承体系"><a href="#Lock继承体系" class="headerlink" title="Lock继承体系"></a>Lock继承体系</h2><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p><strong>Lock接口诞生于JDK1.5，接口内部提供了最基本的加锁、释放锁方法:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface Lock &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 直接加锁 </span><br><span class="line">void lock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 支持可中断的加锁</span><br><span class="line">void lockInterruptibly() throws InterruptedException;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试一次加锁</span><br><span class="line">boolean tryLock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试一次加锁(支持超时停止阻塞)</span><br><span class="line">boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解锁</span><br><span class="line">void unlock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个Condition(作用于线程通信，后面会讲)</span><br><span class="line">Condition newCondition();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用层面</strong><br>既然是接口，就是提供给开发者实现用的，Java自带了ReentrantLock、Condition、ReentrantReadWriteLock实现类供开发者使用。如果这些类无法满足业务需求，开发者可以通过实现Lock接口并利用AQS框架，自己定义一个Lock的具体实现锁(是否公平、是否支持超时、是否支持重入等)，从而提高锁的灵活性。</p><p><strong>与synchronized区别</strong><br>由于Lock可以自己定义是否公平、是否支持超时、是否支持重入等功能，相对于synchronized关键字来说可发挥的空间更多，也更灵活。但是Lock的加锁、释放锁需要开发者自己编写，如果考虑不周很可能造成死锁情况(最好在try中加锁，finally中释放锁)，而synchronized由JVM实现，完全不需要担心这些情况。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock就是Java自带的Lock实现类，字面的意思就能看出来是一把可重入锁，并且功能几乎与synchronized相似，我们看看源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLock implements Lock, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">private final Sync sync;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义一个顶级同步器(内部包含一个非公平加锁方法，一个释放锁方法)</span><br><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID &#x3D; -5179523762034025860L;</span><br><span class="line"></span><br><span class="line">abstract void lock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 非公平方式尝试一次加锁</span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取试图尝试加锁的线程</span><br><span class="line">final Thread current &#x3D; Thread.currentThread();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取公共资源状态</span><br><span class="line">int c &#x3D; getState();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果没其他线程持有锁，进行加锁</span><br><span class="line">if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">&#x2F;&#x2F; 加锁前并没有校验等待队列是否已经有节点在等待了，这个if完全体现了非公平性</span><br><span class="line">if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果有线程持有锁并且是自身，重入次数递增</span><br><span class="line">else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">int nextc &#x3D; c + acquires;</span><br><span class="line">if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">setState(nextc);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 到这里说明锁被其他线程占了，直接返回false</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 释放锁</span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 计算递减后的重入次数</span><br><span class="line">int c &#x3D; getState() - releases;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果释放锁线程不是持有锁线程，抛异常(一般能执行这方法的都是持有锁线程)</span><br><span class="line">if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">throw new IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果递减后为0，那就是真的释放锁了，清空自己的独占状态并返回</span><br><span class="line">boolean free &#x3D; false;</span><br><span class="line">if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">free &#x3D; true;</span><br><span class="line">setExclusiveOwnerThread(null);</span><br><span class="line">&#125;</span><br><span class="line">setState(c);</span><br><span class="line">return free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回调用此方法的线程是否持有锁</span><br><span class="line">protected final boolean isHeldExclusively() &#123;</span><br><span class="line">            return getExclusiveOwnerThread() &#x3D;&#x3D; Thread.currentThread();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 其他方法...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义一个非公平同步器，继承顶级同步器</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID &#x3D; 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实现顶级同步器的lock加锁方法</span><br><span class="line">final void lock() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试CAS 如果成功说明之前没线程加锁</span><br><span class="line">if (compareAndSetState(0, 1))</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 失败就在尝试获取一次，这里调用AQS的acquire()方法，</span><br><span class="line">&#x2F;&#x2F; AQS的acquire()方法又调用下面重写的tryAcquire方法</span><br><span class="line">else</span><br><span class="line">acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 绕了一大圈，其实就是用非公平锁方式加锁</span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义一个公平同步器，继承顶级同步器</span><br><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID &#x3D; -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">final void lock() &#123;</span><br><span class="line">acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">int c &#x3D; getState();</span><br><span class="line">if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">compareAndSetState(0, acquires)) &#123;</span><br><span class="line">setExclusiveOwnerThread(current);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">int nextc &#x3D; c + acquires;</span><br><span class="line">if (nextc &lt; 0)</span><br><span class="line">throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">setState(nextc);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 无参构造器，默认使用非公平锁</span><br><span class="line">public ReentrantLock() &#123;</span><br><span class="line">        sync &#x3D; new NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 参数构造器，自行选择是否公平</span><br><span class="line">    public ReentrantLock(boolean fair) &#123;</span><br><span class="line">        sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 加锁</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 支持可中断加锁</span><br><span class="line">    public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试一次加锁 </span><br><span class="line">    public boolean tryLock() &#123;</span><br><span class="line">        return sync.nonfairTryAcquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 支持超时的加锁</span><br><span class="line">    public boolean tryLock(long timeout, TimeUnit unit)</span><br><span class="line">            throws InterruptedException &#123;</span><br><span class="line">        return sync.tryAcquireNanos(1, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 解锁</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 其他方法....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>重入支持</strong><br>ReentrantLock通过state属性控制重入，每次重入state+1、退出state-1，为0时代表释放锁。</p><p><strong>是否公平锁</strong></p><span class="p red">ReentrantLock类支持公平锁与非公平锁</span>，并根据构造器初始化一个Sync(公平锁创建FairSync，非公平锁创建NonfairSync)，后续加锁释放锁等操作完全调用Sync实现。FairSync与NonfairSync除了加锁逻辑不一样，其他的逻辑(比如释放锁等)完全一样。<p>ReentrantLock加锁是使用Sync的lock()实现，公平锁(FairSync)是直接调用AQS的acquire()方法获取锁，然后调用重写的tryAcquire()方法。在重写方法里面如果可以加锁(state=0)，会先判断等待队列是否有元素在等待，<span class="p red">如果没有元素可以直接加锁，如果加锁失败或存在元素，则加入等待队列尾部等待(按顺序排队)。</span></p><p>非公平锁(NonFairSync)在调用Sync的lock()方法时，只要可以加锁(state=0)，会直接使用CAS进行加锁(无视等待队列是否有元素)，如果插队失败了在调用AQS的acquire()再次加锁，重写的tryAcquire()方法还是会再次尝试插队，如果还是失败才会加入等待队列，<span class="p red">因此非公平锁存在2次插队的操作。</span></p><h2 id="ReadWriteLock接口"><a href="#ReadWriteLock接口" class="headerlink" title="ReadWriteLock接口"></a>ReadWriteLock接口</h2><p>没啥好写的</p><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>没啥好写的</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程(八) AQS</title>
      <link href="2020/03/08/AQS/"/>
      <url>2020/03/08/AQS/</url>
      
        <content type="html"><![CDATA[<h2 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h2><p>AQS的全称是AbstractQueuedSynchronizer，类内部定义了一套多线程访问共享资源的同步器框架，Java许多同步类的实现都依赖于它，比如常用的ReentrantLock、Semaphore、CountDownLatch等，我们也可以利用AQS自己实现一个锁。</p><p>AQS类内部的核心为<span class="p red">volatile int state(共享资源)</span>和<span class="p red">CLH线程等待队列(阻塞队列)</span>，整个AQS类内部大量的方法都是围绕state、CLH队列在处理逻辑。</p><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>state作为共享资源被应用在多线程竞争上，自带的volatile关键字可以保证可见性、有序性，在搭配CAS使用后可以保证操作的原子性。state初始状态为0，线程使用CAS对state+1成功后持有锁，后续每次重入state+1、退出state-1，state递减为0时代表锁释放。</p><h2 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h2><p>当线程竞争失败后会被封装成Node节点加入CLH队列，CLH队列在AQS中是以前驱节点(head)、后驱节点(tail)俩个成员构成的Node类型链表:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 前驱节点</span><br><span class="line">private transient volatile Node head;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 后驱节点</span><br><span class="line">private transient volatile Node tail;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 静态内部类Node</span><br><span class="line">static final class Node &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;** 共享锁 *&#x2F;</span><br><span class="line">static final Node SHARED &#x3D; new Node();</span><br><span class="line"></span><br><span class="line">&#x2F;** 独占锁 *&#x2F; </span><br><span class="line">static final Node EXCLUSIVE &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;** 表示线程已被取消 *&#x2F;</span><br><span class="line">static final int CANCELLED &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;** 表示后续线程需要取消阻塞 *&#x2F;</span><br><span class="line">static final int SIGNAL &#x3D; -1;</span><br><span class="line"></span><br><span class="line">&#x2F;** 表示线程在条件下等待 *&#x2F;</span><br><span class="line">static final int CONDITION &#x3D; -2;</span><br><span class="line"></span><br><span class="line">&#x2F;** 表示下一个获取共享应无条件传播 *&#x2F;</span><br><span class="line">static final int PROPAGATE &#x3D; -3;</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * 节点等待状态</span><br><span class="line"> * 等于0:该节点尚未被初始化完成</span><br><span class="line"> * 大于0:说明该线程中断或者等待超时，需要移除该线程</span><br><span class="line"> * 小于0:该线程处于可以被唤醒的状态</span><br><span class="line"> *&#x2F;</span><br><span class="line">volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">       &#x2F;** 前驱节点 *&#x2F;</span><br><span class="line">volatile Node prev;</span><br><span class="line"></span><br><span class="line">       &#x2F;** 后继节点 *&#x2F;</span><br><span class="line">volatile Node next;</span><br><span class="line"></span><br><span class="line">       &#x2F;** 获取同步状态的线程 *&#x2F;</span><br><span class="line">volatile Thread thread;</span><br><span class="line"></span><br><span class="line">       &#x2F;** 将单向列表变成双向列表 *&#x2F;</span><br><span class="line">Node nextWaiter;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 是否为共享节点</span><br><span class="line">final boolean isShared() &#123;</span><br><span class="line">return nextWaiter &#x3D;&#x3D; SHARED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取前继节点，没有就抛出异常</span><br><span class="line">final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">Node p &#x3D; prev;</span><br><span class="line">if (p &#x3D;&#x3D; null)</span><br><span class="line">throw new NullPointerException();</span><br><span class="line">else</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 无参构造器</span><br><span class="line">Node() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 构造器</span><br><span class="line">Node(Thread thread, Node mode) &#123;     &#x2F;&#x2F; Used by addWaiter</span><br><span class="line">this.nextWaiter &#x3D; mode;</span><br><span class="line">this.thread &#x3D; thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 构造器</span><br><span class="line">Node(Thread thread, int waitStatus) &#123; &#x2F;&#x2F; Used by Condition</span><br><span class="line">this.waitStatus &#x3D; waitStatus;</span><br><span class="line">this.thread &#x3D; thread;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Node内部类主要通过waitStatus来表示状态，主要有五种状态</strong>:</p><table><thead><tr><th>状态</th><th>状态值</th><th>描述</th></tr></thead><tbody><tr><td>INITAL</td><td>0</td><td>初始状态</td></tr><tr><td>CANCELLED</td><td>1</td><td>此节点的后继节点(或即将)被阻塞，因此当前节点在释放或取消时必须取消对其后继节点的阻塞</td></tr><tr><td>SIGNAL</td><td>-1</td><td>此节点的后继节点(或将很快)被阻塞(通过park)，因此当前节点在释放或取消时必须取消对其后继节点的阻塞。为了避免争用，获取方法必须首先表明它们需要一个信号，然后重试原子获取，然后在失败时阻塞</td></tr><tr><td>CONDITION</td><td>-2</td><td>节点线程等待在Condition上，当其他线程对Condition调用了signal()方法后，该节点从等待队列中转移到同步队列中，加入到对同步状态的获取中</td></tr><tr><td>PROPAGATE</td><td>-3</td><td>与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态</td></tr></tbody></table><p><strong>链表入列</strong><br>链表的入列采用CAS方式进行，前驱节点与后驱节都是被volatile修饰的，因此使用CAS修改可以保证绝对安全，在enq方法中AQS使用死循环保证节点可以正确添加，只有成功添加后，当前线程才会从该方法返回，否则会一直执行下去:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">&#x2F;&#x2F; 新建Node</span><br><span class="line">Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">&#x2F;&#x2F; CAS快速尝试添加尾节点(侥幸心理，万一成功了呢)</span><br><span class="line">Node pred &#x3D; tail;</span><br><span class="line">if (pred !&#x3D; null) &#123;</span><br><span class="line">node.prev &#x3D; pred;</span><br><span class="line">&#x2F;&#x2F;CAS设置尾节点</span><br><span class="line">if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">pred.next &#x3D; node;</span><br><span class="line">return node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;多次尝试</span><br><span class="line">enq(node);</span><br><span class="line">return node;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">       &#x2F;&#x2F;多次尝试，直到成功为止</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           Node t &#x3D; tail;</span><br><span class="line">           &#x2F;&#x2F;tail不存在，设置为首节点</span><br><span class="line">           if (t &#x3D;&#x3D; null) &#123;</span><br><span class="line">               if (compareAndSetHead(new Node()))</span><br><span class="line">                   tail &#x3D; head;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F;设置为尾节点</span><br><span class="line">               node.prev &#x3D; t;</span><br><span class="line">               if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   t.next &#x3D; node;</span><br><span class="line">                   return t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure><p>当线程被封装成Node节点成功追加到等待队列尾部后，为了节约CPU资源就需要将当前线程挂起了(被阻塞的线程如果支持可中断并且被中断，自动唤醒并抛出中断异常):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取资源是否失败标记</span><br><span class="line">boolean failed &#x3D; true;</span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;标记等待过程中是否被中断过</span><br><span class="line">boolean interrupted &#x3D; false;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 自旋</span><br><span class="line">for (;;) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;拿到前驱节点</span><br><span class="line">final Node p &#x3D; node.predecessor();</span><br><span class="line"></span><br><span class="line">&#x2F;* </span><br><span class="line"> * 如果前驱是head，说明自己排在第二位，有可能马上就被执行</span><br><span class="line">            * 所以再次尝试tryAcquire()获取，如果失败就挂起等待</span><br><span class="line">            * 当然有可能是第一位搞完了释放资源唤醒自己，也有可能被interrupt</span><br><span class="line">            *&#x2F;</span><br><span class="line">if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取到资源后，把自己设置为head，也就是说head指向的永远是当前拿到资源的</span><br><span class="line">setHead(node);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 断绝与前驱节点的联系，方便被GC回收</span><br><span class="line">p.next &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 成功获取资源后将失败标记为false</span><br><span class="line">failed &#x3D; false;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回等待过程中是否被中断过</span><br><span class="line">return interrupted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 先去检查自己是否真的可以被挂起了，如果不符合条件会进入下一次循环直到符合为止</span><br><span class="line"> * 调用park()方法将自己挂起，直到被唤醒</span><br><span class="line"> * 唤醒后会返回是否被中断标记，方便下次return出去</span><br><span class="line"> *&#x2F;</span><br><span class="line">if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">parkAndCheckInterrupt())</span><br><span class="line">interrupted &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果等待过程中没有成功获取资源(如timeout，或者可中断的情况下被中断了)，取消结点在队列中的等待。</span><br><span class="line">if (failed)</span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shouldParkAfterFailedAcquire方法，检查自己是否真的可以被挂起了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到前驱节点的状态</span><br><span class="line">int ws &#x3D; pred.waitStatus;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果前驱节点的状态是SIGNAL，那么前驱节点执行完会自动唤醒自己，放心的将自身挂起就好了</span><br><span class="line">       if (ws &#x3D;&#x3D; Node.SIGNAL)</span><br><span class="line">           return true;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 如果前驱节点执行过程中放弃了(超时或者其他的)，一直往前找，直到找到正常等待的状态节点</span><br><span class="line">       if (ws &gt; 0) &#123;</span><br><span class="line">           do &#123;</span><br><span class="line">               node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">           &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">           pred.next &#x3D; node;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           &#x2F;&#x2F; 如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下</span><br><span class="line">           compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>parkAndCheckInterrupt方法，就是挂起:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用park()使线程进入waiting状态</span><br><span class="line">LockSupport.park(this);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果执行到这里，说明被唤醒，查看自己是不是被中断的。</span><br><span class="line">return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部方法"><a href="#内部方法" class="headerlink" title="内部方法"></a>内部方法</h2><p><strong>主要方法</strong></p><ul><li><span class="p red">acquire(int arg):独占式获取同步状态，如果当前线程获取成功则返回，否则加入等待队列</span></li><li><span class="p red">acquireInterruptibly(int arg):独占式获取同步状态(同上)，如果被打断直接抛异常</span></li><li><span class="p red">tryAcquire(int arg):独占式获取同步状态(供开发者重写)</span></li><li><span class="p red">tryAcquireNanos(int arg，long nanosTimeout):独占式获取同步状态，增加超时限制</span></li><li><span class="p red">release(int arg):独占式释放同步状态，释放后将同步队列中第一个节点包含的线程唤醒</span></li><li><span class="p red">tryRelease(int arg):独占式释放同步状态(供开发者重写)</span></li></ul><ul><li><span class="p blue">acquireShared(int arg):共享式获取同步状态，如果当前线程获取成功则返回，否则加入等待队列</span></li><li><span class="p blue">acquireSharedInterruptibly(int arg):共享式获取同步状态(同上)，如果被打断直接抛异常</span></li><li><span class="p blue">tryAcquireShared(int arg):共享式获取同步状态(供开发者重写)</span></li><li><span class="p blue">tryAcquireSharedNanos(int arg，long nanosTimeout):共享式获取同步状态，增加超时限制</span></li><li><span class="p blue">releaseShared(int arg):共享式释放同步状态，释放后将同步队列中第一个节点包含的线程唤醒</span></li><li><span class="p blue">tryReleaseShared(int arg):共享式释放同步状态(供开发者重写)</span></li></ul><ul><li><span class="p brown">isHeldExclusively():当前同步器是否在独占式模式下被线程占用，一般该方法表示是否被当前线程所独占</span></li></ul><p><strong>方法虽然很多，不过很容易进行区分</strong></p><ul><li>首先争夺锁的方式有独占和共享</li><li>每种方式又包含加锁、释放锁方法</li><li>加锁的方法又分为直接加锁、超时加锁、中断加锁</li><li>直接加锁与中断加锁内部调用对应try开头的加锁方法处理</li><li>try开头的加锁方法采用模板模式，具体实现由开发者自己重写实现</li><li>最后一个是否独占并占用的查询</li></ul><p><strong>共享资源获取释放</strong><br>在需要开发者重写的获取资源方法中，独占式获取资源方法tryAcquire(int arg)返回值为boolean类型，仅仅需要告诉调用者<span class="p red">获取成功还是失败即可</span>。</p><p>而共享式获取资源方法acquireShared(int arg)返回int类型，大于等于零表示成功，小于零则表示失败，因为是共享所以允许多个线程访问获取，但有些时候我们需要<span class="p red">限制访问数量</span>。这就可以设置一个阈值，每次有线程进来时阈值-1消耗，当消耗为零的时候，后续线程就不允许访问了，直接进入等待队列。</p><p>同样的，共享式资源的释放相比较独占式逻辑也有不同，除了唤醒后继节点，<span class="p red">还需要将阈值+1</span>。</p><h2 id="独占式源码解析"><a href="#独占式源码解析" class="headerlink" title="独占式源码解析"></a>独占式源码解析</h2><p><strong>acquire(获取锁)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">       if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>先尝试用重写的tryAcquire(arg)方法，由于独占锁同一时刻只允许一个线程持有，这就需要开发者在重写方法时要利用好state属性，确保拿到锁的线程返回true，在没有释放前其他线程访问返回false。如果返回false就将线程封装成一个独占式锁加入队列中，紧接着尝试挂起线程。</p><p><strong>release(释放锁)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">if (tryRelease(arg)) &#123;</span><br><span class="line">Node h &#x3D; head;</span><br><span class="line">if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">unparkSuccessor(h);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先尝试调用重写的tryRelease(int arg)释放锁，如果成功后判断自身状态，如果节点状态不等于0(也就是还没退出等待队列)，调用unparkSuccessor方法释放锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取当前节点的状态</span><br><span class="line">       int ws &#x3D; node.waitStatus;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 如果小于0，使用CAS设置为0，0代表退出等待队列</span><br><span class="line">       if (ws &lt; 0)</span><br><span class="line">           compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 获取后继节点</span><br><span class="line">       Node s &#x3D; node.next;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 如果没有后继节点，或者后继节点状态大于0，也就是说已经退出队列了</span><br><span class="line">       if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 方便GC回收</span><br><span class="line">           s &#x3D; null;</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; 不停的往后面找，直到找到状态正常的为止</span><br><span class="line">           for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">               if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                   s &#x3D; t;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 如果找到了就唤醒</span><br><span class="line">       if (s !&#x3D; null)</span><br><span class="line">           LockSupport.unpark(s.thread);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个方法的逻辑也很简单，使用CAS方式将自身节点状态设置为0，紧接着根据自身的waitStatus判断后继节点是否需要被唤醒，如果后继节点因为响应中断等情况放弃了，就继续往后找，直到找到可以背唤醒的节点线程。</p><p><strong>acquireInterruptibly(获取锁并支持中断)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireInterruptibly(int arg)</span><br><span class="line">           throws InterruptedException &#123;</span><br><span class="line">       if (Thread.interrupted())</span><br><span class="line">           throw new InterruptedException();</span><br><span class="line">       if (!tryAcquire(arg))</span><br><span class="line">           doAcquireInterruptibly(arg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>先判断是否中断状态，如果是直接抛异常。如果不是中断状态，进入doAcquireInterruptibly(arg)方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireInterruptibly(int arg)</span><br><span class="line">       throws InterruptedException &#123;</span><br><span class="line">       final Node node &#x3D; addWaiter(Node.EXCLUSIVE);</span><br><span class="line">       boolean failed &#x3D; true;</span><br><span class="line">       try &#123;</span><br><span class="line">           for (;;) &#123;</span><br><span class="line">               final Node p &#x3D; node.predecessor();</span><br><span class="line">               if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                   failed &#x3D; false;</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">               if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   throw new InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">       LockSupport.park(this);</span><br><span class="line">       return Thread.interrupted();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>代码逻辑与acquire几乎一致，AQS阻塞等待逻辑的老套路就是，如果等待线程的前驱节点不是head则使用park()挂起，在parkAndCheckInterrupt()中实现，紧接着下一行返回中断状态。处于挂起状态的线程如果被中断，会立刻结束挂起状态，因此在上面的代码中会满足第二个if判断，抛出中断异常。这里有个疑问，如果前驱节点是head，中断没做任何处理？</p><p><strong>doAcquireNanos(获取锁并支持中断、超时)</strong><br>进入方法前获取当前时间戳，每次循环再次获取当前时间戳用差值判断是否超时，就算是被挂起的，也是调用park(this,nanosTimeout)进行挂起，到达超时时间直接跳出自旋。其他逻辑和doAcquireInterruptibly()一致。</p><h2 id="共享式源码解析"><a href="#共享式源码解析" class="headerlink" title="共享式源码解析"></a>共享式源码解析</h2><p><strong>acquireShared(获取锁)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">       if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">           doAcquireShared(arg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>先尝试用重写的acquireShared(arg)方法，由于共享锁同一时刻时允许多个线程进行访问的，AQS将重写方法设计为支持同一时刻最大访问限制数，返回值的int类型，表示如果当前线程进入访问后还能剩余多少访问数，如果为负数证明已经没有访问名额了，只能阻塞等待。</p><p><strong>releaseShared(释放锁)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">       if (tryReleaseShared(arg)) &#123;</span><br><span class="line">           doReleaseShared();</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>先尝试用重写的tryReleaseShared(arg)释放锁，加锁的时候是对state(访问限制数)-1，那么释放锁自然是加回来，这时有可能很多线程都在释放锁，因此在重写方法里加值要使用CAS方式。释放成功就代表有资源空闲出来，调用doReleaseShared方法唤醒后续节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">for (;;) &#123;</span><br><span class="line">           Node h &#x3D; head;</span><br><span class="line">           if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;</span><br><span class="line">               int ws &#x3D; h.waitStatus;</span><br><span class="line">               if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class="line">                   if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                       continue;            &#x2F;&#x2F; loop to recheck cases</span><br><span class="line">                   unparkSuccessor(h);</span><br><span class="line">               &#125;</span><br><span class="line">               else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                   continue;                &#x2F;&#x2F; loop on failed CAS</span><br><span class="line">           &#125;</span><br><span class="line">           if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在自旋的阶段，每一次循环的过程都是首先获得头结点，如果头结点不为空且不为尾结点(阻塞队列里面只有一个结点)，那么先获得该节点的状态，如果是SIGNAL的状态，则代表它需要有后继结点去唤醒，首先将其的状态变为0，因为是要释放资源了，它也不需要做什么了，所以转变为初始状态，然后去唤醒后继结点unparkSuccessor(h)，如果结点状态一开始就是0，那么就给他转换成PROPAGATE状态，保证在后续获取资源的时候，还能够向后面传播（这一块不明白）。</p><p><strong>tryAcquireSharedNanos(获取锁并支持中断、超时)</strong><br>进入方法前获取当前时间戳，每次循环再次获取当前时间戳用差值判断是否超时，就算是被挂起的，也是调用park(this,nanosTimeout)进行挂起，到达超时时间直接跳出自旋。其他逻辑和tryAcquireShared()一致。</p><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p>看懂AQS的原理机制后，我们可以尝试自己写一个不可重入锁，首先定义一下锁资源(AQS中的state)的含义，0表示未被加锁，1表示已经加锁。直接上代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class CustomLock &#123;</span><br><span class="line"></span><br><span class="line">private Sync sync;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 自定义同步器</span><br><span class="line">private static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断是否锁定状态</span><br><span class="line">@Override</span><br><span class="line">protected boolean isHeldExclusively() &#123;</span><br><span class="line">return getState() &#x3D;&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取资源</span><br><span class="line">@Override</span><br><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用CAS修改状态，如果成功设置当前资源为独占资源</span><br><span class="line">if(compareAndSetState(0, 1))&#123;</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 释放资源</span><br><span class="line">@Override</span><br><span class="line">protected boolean tryRelease(int arg) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;既然释放，肯定就是已占有状态了，为了代码健壮一点加层判断</span><br><span class="line">if (getState() &#x3D;&#x3D; 0)</span><br><span class="line">throw new IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 清空独占记录</span><br><span class="line">setExclusiveOwnerThread(null);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 释放共享资源，tryRelease还没执行完，线程仍然持有锁，因此不需要CAS修改</span><br><span class="line">setState(0);</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在自定义加锁对象创建时，为其初始化一个同步器</span><br><span class="line">public CustomLock()&#123;</span><br><span class="line">sync &#x3D; new Sync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 加锁</span><br><span class="line">public void lock() &#123;</span><br><span class="line">sync.acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 单次加锁尝试</span><br><span class="line">public boolean tryLock() &#123;</span><br><span class="line">return sync.tryAcquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 释放锁</span><br><span class="line">public void unlock()&#123;</span><br><span class="line">sync.release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 锁是否处于加锁状态</span><br><span class="line">public boolean isLocked()&#123;</span><br><span class="line">return sync.isHeldExclusively();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可重入锁在加锁、释放锁的时候需要对state进行加减操作，并且确保退出的时候state为零，再此期间其他线程访问时如果state大于等于零，则获取锁失败。由于这段代码设计的是不可重入锁，不需要记录次数，仅仅有加锁(1)和未加锁(0)俩中状态，因此lock()、tryLock()、unlock()方法传参随便写都可以，在内部类Sync重写AQS方法中已经写死。</p><p>利用AQS我们可以实现很多种同步机制，比如CountDownLatch、CyclicBarrier、Semaphore、Lock诸多实现类，都是利用AQS来实现。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程(七) synchronized关键字</title>
      <link href="2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如果我们想要保证单个共享变量的原子操作，可以借助CAS来实现，当我们想要保证多个共享变量的原子操作时，那就要把对多个变量的操作代码整合在一起建立临界区，临界区同一时刻只能有一个线程访问。而synchronized关键字就是java老牌的互斥锁，保证操作的原子性、可见性、有序性，同时还保证锁的可重入性。</p><h2 id="synchronized使用"><a href="#synchronized使用" class="headerlink" title="synchronized使用"></a>synchronized使用</h2><ul><li>修饰方法的时候，如果是普通方法，加锁目标是此实例对象(new出来的、存放在堆中的某个对象)</li><li>修饰方法的时候，如果是静态方法，加锁目标是当前类的class对象(存在方法区的类结构对象)</li><li>修饰代码块的时候，需要指定某个实例对象或class对象作为加锁目标</li></ul><h2 id="jvm对象头"><a href="#jvm对象头" class="headerlink" title="jvm对象头"></a>jvm对象头</h2><p>无论哪种方式实现线程同步，都必须指定一个对象并获得此对象的锁才有资格执行同步方法或代码块，synchronized的实现完全依赖于jvm，因此理解synchronized的底层实现，就必须理解对象在jvm是如何存储的，关于锁的那部分数据信息又是如何维护的。</p><p>在JVM虚拟机中，对象在内存中的存储布局，一般情况下分为三个区域：</p><ul><li>对象头(包括标记字段、类型指针)</li><li>实例数据(存储对象自身定义的数据)</li><li>对齐填充(jvm要求对象的内存大小必须是8字节整倍数，对齐填充用于补全大小到整倍数)</li><li>如果对象是数组，还会有个区域记录数组的长度，用于判断数组对象的内存大小</li></ul><p>有关对象锁的数据全部存储在对象头区域中，我们使用java提供的jol工具来看看对象的头部信息详细结构(测试为64位操作系统):</p><p>1.先添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.openjdk.jol&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jol-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.9&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2.创建测试用对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void doSomething()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.执行main方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       Person person &#x3D; new Person(&quot;李逍遥&quot;,18);</span><br><span class="line">       System.out.println(ClassLayout.parseInstance(person).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.打印结果<br><img src="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/jvm%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%BF%A1%E6%81%AF.jpg" class="lazyload" data-srcset="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/jvm%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%BF%A1%E6%81%AF.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>表头代表的含义：</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>OFFSET</td><td>偏移地址，单位字节</td></tr><tr><td>SIZE</td><td>占用的内存大小，单位字节</td></tr><tr><td>TYPE DESCRIPTION</td><td>类型描述，其中object header为对象头类型</td></tr><tr><td>VALUE</td><td>类型对应的值</td></tr></tbody></table><p>颜色标记区域代表的含义：</p><table><thead><tr><th>区域</th><th>描述</th></tr></thead><tbody><tr><td>红色</td><td>标记字段，内部结构比较复杂，而且会不断变化，下面单独讲</td></tr><tr><td>蓝色</td><td>类型指针，通常由64位组成，但是我们jvm会默认对其压缩到32位，因此占用4字节</td></tr><tr><td>绿色</td><td>实例数据，基本数据类型会直接打印值，引用数据类型显示(object)</td></tr><tr><td>黄色</td><td>对齐填充，图中对象占用总内存为20字节，因此对齐填充补了4字节确保是8字节倍数</td></tr></tbody></table><p>与synchronized底层原理关联最为密切的就是红色区域了，这个区域也比其他区域更为复杂一点，标记字段拥有8字节的内存大小(也就是64位)，对象锁状态的不同，这64位存储的内容也不同：<br><img src="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5%E5%AD%98%E5%82%A8%E4%BF%A1%E6%81%AF.png" class="lazyload" data-srcset="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5%E5%AD%98%E5%82%A8%E4%BF%A1%E6%81%AF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>标记字段中存储的信息：</p><ul><li>hash:存储对象哈希码，只有在调用hashCode()方法的时候才会生成，默认是没值的</li><li>age:jvm分代年龄，用于判断是否晋升老年代</li><li>biased_lock:偏向锁标识位</li><li>lock:锁状态标识位</li><li>JavaThread:保存持有偏向锁的线程ID</li><li>epoch:保存偏向时间戳(并不是我们理解的long类型时间戳)</li><li>Pointer to Lock Record:指向线程栈中锁记录的地址</li><li>Pointer to Monitor:指向jvm监控对象的地址</li></ul><h2 id="无锁状态"><a href="#无锁状态" class="headerlink" title="无锁状态"></a>无锁状态</h2><p>所谓无锁状态，就是对象还没有被加过锁，也就是说内部的synchronized修饰的方法还没有任何线程调用过，上面打印的截图是没有调用hashCode()方法的，我们写个调用hashCode()方法的测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    Object lockObject &#x3D; new Object();</span><br><span class="line">    System.out.println(&quot;哈希码 : &quot; + lockObject.hashCode());</span><br><span class="line">    System.out.print(ClassLayout.parseInstance(lockObject).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：<br><img src="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E6%97%A0%E9%94%81%E7%8A%B6%E6%80%81%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF.jpg" class="lazyload" data-srcset="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E6%97%A0%E9%94%81%E7%8A%B6%E6%80%81%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>我们把二进制数据拼接起来，拼接规则是<span class="p blue">从下至上、从右到左</span>。</p><p>最终拼接结果为:<span class="p red">00000000 00000000 00000000 01111011 00011101 01111111 11111111 00000001</span></p><p>取出哈希码:<span class="p red">1111011 00011101 01111111 11111111</span></p><p>随便找个进制转换器就能算出来结果是:2065530879，与main方法打印的一致。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁是jdk1.6引入的一项锁优化，意思是偏向于第一个获得它的线程，在接下来的执行过程中，假如该锁没有被其他线程所获取，没有其他线程来竞争该锁，那么持有偏向锁的线程将永远不需要进行同步操作。</p><p>JVM启动时会进行一系列的复杂活动，比如装载配置，系统类初始化等等。在这个过程中会使用大量synchronized关键字对对象加锁，且这些锁大多数都不是偏向锁。为了减少初始化的时间，JVM默认采用延时加载偏向锁的机制(大概4秒左右)。在延迟时间内是没有偏向锁概念的，对象创建完毕后是无锁状态，即使需要进行锁升级也是直接升级到轻量级锁，当到达延迟时间之后创建出来的对象，锁状态都是偏向锁状态。</p><p>所以我们直接执行main方法是看不到偏向锁信息的，当然也可以在创建对象之前sleep五秒，不过这个方法太low逼了，JVM提供了取消偏向锁延迟加载命令:<span class="p blue">-XX:BiasedLockingStartupDelay=0</span></p><p>测试类走起:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Object lockObject &#x3D; new Object();</span><br><span class="line">    System.out.println(ClassLayout.parseInstance(lockObject).toPrintable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果:<br><img src="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E5%81%8F%E5%90%91%E9%94%81%E7%8A%B6%E6%80%81%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF-1.jpg" class="lazyload" data-srcset="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E5%81%8F%E5%90%91%E9%94%81%E7%8A%B6%E6%80%81%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF-1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>打印结果可以看出，对象还没有被作为加锁对象使用，偏向线程是空的。我们写个持有偏向线程的代码，并且手动调用一次gc看看age有没有增长:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Object lockObject &#x3D; new Object();</span><br><span class="line">    System.gc();</span><br><span class="line">    synchronized (lockObject)&#123;</span><br><span class="line">        System.out.print(ClassLayout.parseInstance(lockObject).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果:<br><img src="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E5%81%8F%E5%90%91%E9%94%81%E7%8A%B6%E6%80%81%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF-2.jpg" class="lazyload" data-srcset="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E5%81%8F%E5%90%91%E9%94%81%E7%8A%B6%E6%80%81%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF-2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>打印结果中并不存在hashcode，这是因为在HotSpot虚拟机中，偏向锁与hashcode不可以并存(我估计是JavaThread占用的太多，没地方了…)，如果在无锁状态调用hashcode方法，<span class="p red">直接升级到轻量级锁</span>，如果是偏向锁状态下调用hashcode()，<span class="p red">直接进入偏向锁撤销阶段</span>。这种规则仅限于没有重写hashcode()方法的情况下。</p><p><strong>偏向锁工作流程图:</strong><br><img src="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E5%81%8F%E5%90%91%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="lazyload" data-srcset="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E5%81%8F%E5%90%91%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><strong>CAS获取偏向锁步骤</strong><br>整个流程图最大的疑问在于CAS获取偏向锁的这一步骤，如果线程A获取偏向锁并开始执行同步代码或方法块期间，线程B试图访问同步方法或代码块，按照我们的理解CAS成功是必然的，因为此刻线程A还在执行临界区代码，不会对标记字段进行修改干扰到线程B，这不就出现2个线程同时进入同步代码了吗？</p><p>实时并非如此，无论是无锁状态(001)下的CAS，还是偏向锁状态下的CAS，期望值参数永远是null，也就意味着多个线程同时对无锁状态的同步代码争夺偏向锁，仅有一个线程会成功并成为偏向线程，之后任何线程在尝试CAS获取偏向锁永远是失败的(因为JavaThread已经非null)，直接进入偏向锁撤销阶段。</p><p><strong>锁撤销</strong><br>偏向锁的撤销需要到达JVM的STW才会执行，这个时间点内所有字节码都不会执行，紧接着挂起偏向线程，根据isAlive()判断偏向线程状态再做后续处理:</p><ul><li>如果处于未活动状态，说明偏向线程已经执行完毕并死亡，<span class="p blue">说明没有发生竞争</span>，直接释放偏向锁。</li><li>如果处于活动状态并且已经退出同步代码块，<span class="p blue">说明没有发生竞争</span>，释放偏向锁后需要唤醒线程继续执行。</li><li>如果处于活动状态并且未退出同步代码块，<span class="p red">说明发生竞争</span>,直接升级到轻量级锁。</li></ul><p><strong>锁重偏向</strong><br>通过对撤销步骤的了解不难发现，只有在到达安全点后，偏向线程已经死亡或者退出同步代码块，加锁对象的markword中JavaThread和epoch才会被清空，直到下一个线程获得偏向锁，加锁对象重新偏向另一个线程。</p><p><strong>锁批量撤销</strong><br>JVM会以class为单位，为每个class分配一个偏向锁撤销计数器，每次class的实例被撤销偏向锁时计数器+1，当某个class的计数器达到阈值时(JVM参数控制)，JVM会将该class的所有实例批量撤销偏向锁，并且该class后续创建的所有实例都是不可偏向的(直接是轻量级锁)。</p><span class="p blue">批量撤销阈值: -XX:BiasedLockingBulkRevokeThreshold = 40</span><p><strong>锁批量重偏向</strong><br>重偏向操作需要等到安全点才可以触发，如果刚触发锁撤销操作的时候，偏向线程就执行完同步代码块，那么此时等待安全点是没有任何意义的，并且锁撤销也会占用一定的STW时间。由此可以看出频繁的锁撤销会对性能带来一定影响，为了解决这个问题，JVM引入了批量重偏向概念来减少锁撤销的频率。</p><p>与批量撤销的相似，批量重偏向也是在class的计数器达到一定阈值时触发，执行过程:</p><ul><li>当到达安全点时发现偏向次数到达阈值触发批量重偏向，会对class中的epoch进行+1运算得出epoch_new</li><li>jvm扫描所有该class的实例对象，并筛选出处于偏向锁状态的实例对象，把所有筛选对象的epoch改成epoch_new</li><li>退出安全点后，有线程需要尝试获取偏向锁，检查加锁对象的epoch与对应class的epoch是否一致</li><li>如果一致，根据JavaThread是否为自身ID决定撤销锁还是直接进入同步代码(还是原来的逻辑)</li><li>如果不一致说明偏向锁已经无效，不会因为加锁对象偏向其他线程而触发撤销操作，而是直接尝试CAS获取锁</li></ul><p>注:我猜测此时期望值不在是null而是重新获取加锁对象的markword，获取到锁之后还会把class的epoch归零，因为epoch就2位不可能一直递增。</p><span class="p blue">批量重偏向阈值: -XX:BiasedLockingBulkRebiasThreshold = 20</span><p><strong>锁撤销计数器重置</strong><br>即使在竞争很少发生的应用中，随着时间的流逝，各class的锁撤销计数器总有到达阈值的时候。比如某个class的所有实例对象一小时才触发一次锁撤销，那么默认40小时后会触发批量锁撤销，后续所有对象的创建全都是轻量级锁。这种竞争程度简直毛毛雨，根本没必要使用轻量级锁增加无意义的性能消耗。对此JVM增加了两次批量锁撤销事件触发时差的阈值判断，如果距离上次批量撤销时差小于等于阈值时差就执行批量锁撤销，否则仅仅将锁撤销计数重置为零。</p><span class="p blue">批量锁撤销时差阈值(毫秒): -XX:BiasedLockingBulkRebiasThreshold = 25000</span><p><strong>启用禁用</strong><br>偏向锁撤销的作用很明显了，根据线程对此临界代码的访问是否发生竞争，来决定将锁恢复到无锁状态还是升级到轻量级。没有发生竞争的情况下，偏向锁的逻辑仍然能保证很好的性能，一旦发生竞争，就需要更高级的锁来最大化性能。偏向锁在竞争稍微激烈的情况下其实没什么卵用，如果你觉得你的应用对于大多数锁的竞争都是比较频繁的，偏向锁完全没有存在的必要，可以设置JVM启动参数来禁用偏向锁(默认延迟打开):</p><span class="p blue">禁用偏向锁: -XX:-UseBiasedLocking</span><p><strong>可重入性</strong><br>偏向锁是在没有发生竞争的情况下才存在，线程拿到偏向锁后成为偏向线程，在没有发生偏向锁撤销情况下，后续访问是没有资源消耗的，可以直接执行临界代码，这就代表偏向锁阶段完全支持可重入。</p><p><strong>非公平性</strong><br>不存在竞争因此也不存在是否公平性可言。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>轻量级锁也是jdk1.6引入的一项锁优化，是在锁发生竞争但竞争不是特别激烈情况下的折中解决方案，降低重量级锁使用过程中的性能消耗。</p><p>我们写个测试类(使用 -XX:-UseBiasedLocking命令，禁用偏向锁):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Object lockObject &#x3D; new Object();</span><br><span class="line">    synchronized (lockObject)&#123;</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(lockObject).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果:<br><img src="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%8A%B6%E6%80%81%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF.jpg" class="lazyload" data-srcset="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%8A%B6%E6%80%81%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>轻量级锁的标记字段结构很简单，只存储锁标志、锁记录俩个信息，hashcode和age转移到Lock Record中进行存储。</p><p><strong>轻量级锁工作流程图:</strong><br><img src="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="lazyload" data-srcset="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><strong>自旋次数</strong><br>在自旋竞争锁过程中，如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体系统的性能。这个自旋次数在jdk1.5是写死的参数无法更改，到了jdk1.6版本可以通过jvm参数控制自旋次数(默认10)，jdk1.7版本后又去掉了此参数，因为这个时候的jvm已经相当成熟，会根据内部收集的性能日志自己判定自旋次数。</p><span class="p blue">轻量级锁自旋次数: -XX:PreBlockSpin=10</span><p><strong>锁释放</strong><br>持锁线程执行完释放锁后，将拷贝的markword作为期望值，使用CAS修改加锁对象的markword，可以理解为将hashcode、age等信息还回去。有可能此时已经膨胀到重量级锁，加锁对象的markword已经变更，这种情况下CAS必然失败，这时候直接执行重量级锁的唤醒逻辑。</p><p>解锁操作为什么要用CAS来操作呢? 这是为了防止在解锁的时候，锁由于竞争的激烈程度再次提高，已经升级到重量级锁并且把其他线程阻塞，这种情况下如果不唤醒阻塞的线程，这些线程将永远阻塞在这里。</p><p><strong>可重入性</strong><br>偏向线程执行过程中遇到锁升级信号(已经发出偏向锁撤销请求)，JVM会在该线程栈中分配一个<span class="p red">Lock Record</span>，并把加锁对象的markword拷贝进来，如果已经是轻量级锁情况下，线程访问临界代码前也会执行同样操作。这也就意味着持有轻量级锁过程中，加锁对象的hashcode、age等信息转移到了持锁线程的Lock Record中，持锁线程的Lock Record同样也会保存加锁对象markword的地址，两者是互相引用的关系，这样既能保证加锁对象的hashcode、GC年龄随时可以访问，也可以解决可重入的问题。</p><p><strong>非公平性</strong><br>顶多俩线程在竞争，一个在执行，一个在自旋等待，因此也没有是否公平性可言。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>轻量级锁膨胀之后，就升级为重量级锁了。重量级锁是依赖对象关联的monitor锁来实现的，每个java对象都有一个与之对应的monitor对象，随着java对象一起创建一起销毁。而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁。</p><p><strong>在HotSpot虚拟机中，Monitor是基于C++实现的，封装成ObjectMonitor对象，具体成员变量:</strong></p><table><thead><tr><th>属性名</th><th>默认值</th><th>属性描述</th></tr></thead><tbody><tr><td>_header</td><td>NULL</td><td>锁对象的原始对象头</td></tr><tr><td>_count</td><td>0</td><td>用来记录该线程获取锁的次数</td></tr><tr><td>_waiters</td><td>0</td><td>进入wait状态的线程数</td></tr><tr><td>_recursions</td><td>0</td><td>锁的重入次数</td></tr><tr><td>_object</td><td>NULL</td><td>关联的锁对象</td></tr><tr><td>_owner</td><td>NULL</td><td>指向持有ObjectMonitor对象的线程，锁释放后设置为null</td></tr><tr><td>_WaitSet</td><td>NULL</td><td>调用wait()方法后进入的wait集合</td></tr><tr><td>_WaitSetLock</td><td>0</td><td>操作WaitSet链表的锁</td></tr><tr><td>_Responsible</td><td>NULL</td><td>防止搁浅情况</td></tr><tr><td>_succ</td><td>NULL</td><td>假定继承线程</td></tr><tr><td>_cxq</td><td>NULL</td><td>被挂起线程等待重新竞争锁的单向链表，为了避免插入和取出元素的竞争，所以Owner会从列表尾部取元素</td></tr><tr><td>FreeNext</td><td>NULL</td><td>Free list linkage</td></tr><tr><td>_EntryList</td><td>NULL</td><td>处于block状态的线程集合，被notify唤醒后重新加入竞争也是进入此队列</td></tr><tr><td>_SpinFreq</td><td>NULL</td><td>自旋成功率</td></tr><tr><td>_SpinClock</td><td>0</td><td>自旋时钟</td></tr><tr><td>OwnerlsThread</td><td>0</td><td>表明当前owner原来持有轻量级锁</td></tr><tr><td>_previous_owner_tid</td><td>0</td><td>上一个获取锁的线程id</td></tr></tbody></table><p>写个重量级锁mode:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">    Object lockObject &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (lockObject) &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    &#x2F;&#x2F; ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (lockObject) &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    &#x2F;&#x2F; ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    System.out.println(ClassLayout.parseInstance(lockObject).toPrintable());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果:<br><img src="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%8A%B6%E6%80%81%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF.jpg" class="lazyload" data-srcset="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%8A%B6%E6%80%81%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><strong>阻塞过程</strong><br>monitor对象在轻量级锁膨胀后初始化，并且将状态设置为膨胀中(INFLATING)，在膨胀期间有线程访问直接进入忙等状态。当一个线程尝试获取锁并且获取失败，则将线程封装为ObjectWaiter插入到cxq的队列的队首，进入cxq队列的线程还会再次尝试自旋获取锁，如果还是失败则调用park函数挂起线程。<span class="p red">park函数涉及到内核态的切换，因此比较耗时，也是被称为'重'锁的原因。</span></p><p><strong>自旋目的</strong><br>争夺锁失败插入cxq队列后仍然会进行自旋的目的在于，防止同步块中代代码较少、执行比较快的情况下，频繁的park函数调用导致频繁的内核态的切换影响性能。关于自旋次数在JDK1.6之前默认10次，之后版本改成了<span class="p blue">适应性自旋</span>由JVM自己控制。</p><p><strong>防止搁浅</strong><br>当线程获得锁后，会去查询当前是否还有其他线程等待获取锁，如果没有则将_Responsible设置为自身，在进入cxq后自旋仍然没获取锁会再次判断_Responsible是否为自身，如果是则调用有时间限制的park方法，估计是考虑到特殊场景下所有线程都处于阻塞导致没有线程进行释放锁操作，出现搁浅情况。</p><p><strong>线程释放</strong><br>当锁被释放后，会从_cxq或_EntryList中挑选一个线程唤醒，被选中的线程为假定继承人赋值给_succ，即使_succ重新加入竞争也不能保证会获取到锁，所以_succ也只能称为<span class="p blue">假定继承人</span>。</p><p><strong>重量级锁工作流程图:</strong><br><img src="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="lazyload" data-srcset="/2020/03/07/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p><strong>可重入性</strong><br>monitor通过_owner属性判断线程有无权限进入同步代码块，再根据_recursions属性用来记录重入次数，进入临界代码时+1、退出时-1，由此可以保证重入性。</p><p><strong>非公平性</strong><br>jvm在唤醒线程时会根据内部参数QMode的值决定使用哪种唤醒策略，可能从_cxq中选取一个，也可能从_EntryList中选取一个，_cxq队列的线程也会因为策略被转移到_EntryList队列的首部或尾部。被选中的线程也不保证能拿到锁，因此synchronized是非公平的。</p><h2 id="GC标记"><a href="#GC标记" class="headerlink" title="GC标记"></a>GC标记</h2><p>如果设置finalize()或许还有一线生机，没设置就等死吧….</p><h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>synchronized是由JVM来实现的，因此锁是否支持降级完全取决于JVM设计者，本文所有技术点均来自HotSpot虚拟机。HotSpot虚拟机在进入安全点的时候，会去检查是否有空闲的monitor，如果有就试图进行降级。在轻量级锁释放锁的时候会将拷贝的markwordCAS修改回去，如果成功，是不是也代表降级为偏向锁了呢？这个问题没有找到答案，以后搞懂了再改。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程(六) 锁分类</title>
      <link href="2020/03/06/%E9%94%81%E5%88%86%E7%B1%BB/"/>
      <url>2020/03/06/%E9%94%81%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>java中的锁可谓是五花八门，各种锁功能相似又不同，有的是概念、有的是java接口、有的是实现类，让你很难找到明显的分界线去区分并记住他们。<span class="p red">所以学习锁首先要打消一种想法，就是一个锁只属于一个分类</span>，比如一个锁可以同时是乐观锁、可重入锁，公平锁，就像一个人可以是男人、程序员、健身爱好者。</p><h2 id="synchronized与Lock"><a href="#synchronized与Lock" class="headerlink" title="synchronized与Lock"></a>synchronized与Lock</h2><p>java代码中两种加锁方式 一种是用<strong>synchronized关键字</strong>，另一种是用<strong>Lock接口</strong>的实现类。形象地说，synchronized关键字是自动档，可以满足一切日常驾驶需求。但是如果你想要玩漂移或者各种骚操作，就需要手动档了——各种Lock的实现类，因为Lock的实现类可以通过设置不同的参数改变锁的作用达到灵活适应场景的作用，而synchronized是关键字，底层有jvm实现，很多参数都是写死的。</p><h2 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h2><p>锁的一种宏观分类方式是<strong>悲观锁</strong>和<strong>乐观锁</strong>。悲观锁与乐观锁并不是特指某个锁(Java中没有哪个Lock实现类就叫PessimisticLock或OptimisticLock)，而是在并发情况下的两种不同策略。</p><p>悲观锁(Pessimistic Lock)，就是很悲观，每次去拿数据的时候都认为别人会修改。所以每次在拿数据的时候都会上锁，这样别人想拿数据就被挡住，直到悲观锁被释放。比如上面说的synchronized与Lock。</p><p>乐观锁(Optimistic Lock), 就是很乐观，每次去拿数据的时候都认为别人不会修改。所以不会上锁，这里的上锁是指互斥性质的上锁，在说明白点就是我加锁了谁也别想碰，除非我释放锁，乐观锁采用的是类似CAS的方式，保证操作数据不会干扰到其他线程。</p><p>悲观锁<strong>阻塞事务</strong>，乐观锁<strong>回滚重试</strong>，它们各有优缺点，不要认为一种一定好于另一种。像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行重试，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>有一种锁叫自旋锁。所谓自旋，说白了就是一个** while(true) ** 无限循环。<br>这个自旋锁与Atomic类的while实现的自旋代码不是一回事，下一章AQS会详细讲</p><h2 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h2><p>前面提到synchronized关键字就像是汽车的自动档。一脚油门踩下去，synchronized会从无锁升级为偏向锁，再升级为轻量级锁，最后升级为重量级锁，就像自动换挡一样。那么自旋锁在哪里呢？这里的轻量级锁就是一种自旋锁。</p><p>初次执行到synchronized代码块的时候，锁对象变成偏向锁(通过CAS修改对象头里的锁标志位，说明白点就是锁记住了第一次和他发生关系的线程)，字面意思是“偏向于第一个获得它的线程”的锁，执行完同步代码块后，线程并不会<strong>主动释放偏向锁</strong>。第二次访问如果还是此线程，那么就没有加锁释放锁这一说，正常执行。</p><p>一旦有第二个线程加入锁竞争并发现锁是偏向锁，会去断线程A是否仍然存活。如果线程A仍然存活，将线程A暂停，此时偏向锁升级为轻量级锁，之后线程A继续执行，线程B自旋。但是如果判断结果是线程A不存在了，则线程B持有此偏向锁，锁不升级。</p><p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先比较当前锁标志位是否为“释放”，如果是则将其设置为“锁定”，比较并设置是原子性发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。</p><p>自旋锁避免不了的问题就是竞争特别激烈的情况下，其他线程只能在原地<strong>空耗CPU</strong>，执行不了任何有效的任务，这种现象叫做**忙等(busy-waiting)**。显然，此忙等是有限度的(有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改)。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁(依然是CAS修改锁标志位，但不修改持有锁的线程ID)。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起(而不是忙等)，等待将来被唤醒。在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。</p><h2 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁(递归锁)"></a>可重入锁(递归锁)</h2><p>可重入锁的字面意思是“可以重新进入的锁”，即允许同一个线程多次获取同一把锁。比如一个递归函数里有加锁操作，递归过程中这个锁会阻塞自己吗？如果不会，那么这个锁就是可重入锁(因为这个原因可重入锁也叫做递归锁)。</p><h2 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h2><p>如果多个线程申请一把公平锁，那么当锁释放的时候，先申请的先得到，非常公平。显然如果是非公平锁，后申请的线程可能先获取到锁，是随机或者按照其他优先级排序的。</p><p>对ReentrantLock类而言，通过构造函数传参可以指定该锁是否是公平锁，默认是非公平锁。一般情况下，非公平锁的吞吐量比公平锁大，如果没有特殊要求，优先使用非公平锁。对于synchronized而言，它也是一种非公平锁，但是并没有任何办法使其变成公平锁。</p><h2 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h2><p>这里的关键是理解什么是中断。Java并没有提供任何直接中断某线程的方法，只提供了中断机制。何谓“中断机制”？线程A向线程B发出“请你停止运行”的请求(线程B也可以自己给自己发送此请求)，但线程B并不会立刻停止运行，而是自行选择合适的时机以自己的方式响应中断，也可以直接忽略此中断。也就是说，<strong>Java的中断不能直接终止线程</strong>，而是需要被中断的线程自己决定怎么处理。这好比是父母叮嘱在外的子女要注意身体，但子女是否注意身体，怎么注意身体则完全取决于自己。</p><h2 id="读写锁、共享锁、互斥锁"><a href="#读写锁、共享锁、互斥锁" class="headerlink" title="读写锁、共享锁、互斥锁"></a>读写锁、共享锁、互斥锁</h2><p>读写锁其实是一对锁，一个读锁(共享锁)和一个写锁(互斥锁、排他锁)，Java提供了ReadWriteLock接口和实现类ReentrantReadWriteLock来实现读写锁。</p><ul><li>读锁：防止读的时候其他线程写，允许读的时候其他线程读</li><li>写锁：防止写的时候其他线程读或写</li></ul><h2 id="使用锁带来的问题"><a href="#使用锁带来的问题" class="headerlink" title="使用锁带来的问题"></a>使用锁带来的问题</h2><p>死锁、活锁、饥饿</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程(五) CAS</title>
      <link href="2020/03/05/CAS/"/>
      <url>2020/03/05/CAS/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS的全称是Compare and Swap(比较和交换)，是一种特殊的修改数据的方式，线程通过CAS修改数据时整个过程涉及到三个数据：要修改的内存数据V、执行CAS操作前读取V并将V的值复制到工作空间计作A(预期值)、修改后的数据B，执行CAS操作中当且仅当预期值A和内存值V相同时，将内存值V修改为B并返回true，否则视为修改失败返回false。<br><img src="/2020/03/05/CAS/%E6%9A%82%E6%97%A0" class="lazyload" data-srcset="/2020/03/05/CAS/%E6%9A%82%E6%97%A0" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><h2 id="Atomic对CAS的应用"><a href="#Atomic对CAS的应用" class="headerlink" title="Atomic对CAS的应用"></a>Atomic对CAS的应用</h2><p>Atomic包是Java.util.concurrent下的另一个专门为线程安全设计的Java包，包含多个原子操作类，我们以AtomicInteger为例看看java如何通过CAS实现原子性。</p><p>incrementAndGet方法，以原子方式将当前值增加1并返回增加后的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final int incrementAndGet() &#123;</span><br><span class="line">    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们发现incrementAndGet方法把这个操作委托给unsafe类的getAndAddInt方法处理，我们继续看getAndAddInt方法源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndAddInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">       int var5;</span><br><span class="line">       do &#123;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 读取AtomicInteger在内存中对应的值，并复制一份赋值给var5，作为期望值</span><br><span class="line">           var5 &#x3D; this.getIntVolatile(var1, var2);</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; 将AtomicInteger对象引用、偏移量、预期值、修改后的值交给compareAndSwapInt也就是CAS方法循环执行，直到true</span><br><span class="line">       &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">       return var5;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>代码中我们可以看到，真正的CAS修改操作是compareAndSwapInt方法，我们继续往下看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br></pre></td></tr></table></figure><p>到这里的时候我们发现compareAndSwapInt方法是被native修饰的，说明接下来的代码是使用C++实现的了。源码就不贴了，这个方法实际上是利用处理器提供的汇编指令<span class="p red">CMPXCHG</span>。当CPU执行此修改指令时发现带有CMPXCHG前缀，那么会采用CAS方式(比较并交换操作数)修改数据，并且保证比较、交换俩个步骤不会被上下文切换打断。当且仅当预期值var4与要修改的内存值相等时，将内存值修改为var5。</p><p>如果你细心的话会发现，在多核CPU的操作系统中仅仅保证CAS的俩个步骤不被上下文切换打断没什么卵用，如果俩个线程并行同时对某个AtomicInteger(0)执行incrementAndGet方法，怎么保证高速缓存中取出的期望值不是脏数据？怎么保证多个处理器不会同时执行到CAS的比较操作并且都返回true，继而同时修改内存值为1，最终导致结果应该是2却因为线程安全问题变为1？</p><p>我们回头看看AtomicInteger的其他源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">   private volatile int value;</span><br><span class="line"></span><br><span class="line">   public AtomicInteger(int initialValue) &#123;</span><br><span class="line">       value &#x3D; initialValue;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public AtomicInteger() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final int get() &#123;</span><br><span class="line">       return value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>AtomicInteger内部有个int类型的value属性，代表着自身的值，并且AtomicInteger读写操作都是围绕这个值进行的，并且这个类被volatile修饰的。到这里思路就清晰了，volatile修饰符保证了value值的可见性，线程不会出现读到脏数据的情况。</p><p>对于第二种情况百度的资料很少提及，所以也无法确定CPU到底如何解决这个问题。但是我在知乎上看到了俩个感觉还算靠谱的答案。首先被volatile修饰的变量会使用MESI协议确保同一时刻只有一个处理器修改值，并且把其他处理器此值的缓存设为无效，当第二个处理器想要修改值时发现无效，CAS操作失败，返回false，另一个答案则表示当多个处理器同时使用cmpxchg指令(也就是CAS)操作同一个数据时，总线会进行仲裁只有一个处理器执行CAS，其他处理器连比较操作都不会执行，直到上一个处理器执行完毕后总线再次仲裁并选中自己。</p><p>第一种答案强调使用MESI的失效机制解决问题，第二种答案则强调将CAS视为一个整体，在执行比较操作的时候就会利用MESI协议将数据修改为M状态。不同的CPU架构可能解决问题的方式也不同，总之CPU保证多处理器并行执行CAS不会出错，Java保证volatile+自旋CAS修改数据的原子性，以后搞懂了再更新。</p><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>Java在1.5版本引进了AtomicStampedReference类，采用版本号的机制解决这个操蛋的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>CAS是典型的乐观派操作，每次都迷之自信认为操作一定成功，但是在高并发比较严重的情况下会导致大量线程不断的循环，增大CPU的消耗。</li><li>CAS只能保证单个共享变量的原子操作，如果操作涉及多个共享变量，必须要排他锁解决</li><li>仅仅依靠CAS无法保证原子性，必须配合CPU缓存锁一起保证。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程(四) volatile关键字</title>
      <link href="2020/03/04/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2020/03/04/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>volatile是Java的一个修饰符，它在多线程编程开发中保证了共享变量的<span class="p red">可见性</span>和<span class="p red">有序性</span>。相对于各种排他锁，volatile在使用和执行成本上占用资源较少。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>那么volatile如何保证可见性和有序性呢？我们写一段单例模式的java代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">public class SingletonObject &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 单例对象</span><br><span class="line">    private static volatile SingletonObject instance;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取单例对象方法</span><br><span class="line">    public static SingletonObject get()&#123;</span><br><span class="line"></span><br><span class="line">        if(instance &#x3D;&#x3D; null)&#123;</span><br><span class="line">            instance &#x3D; new SingletonObject();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SingletonObject.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后用idea运行main方法并打印汇编代码，jvm参数：<br>-server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly<br>-XX:CompileCommand=compileonly,*SingletonObject.get (只打印SingletonObject的get方法)</p><p>运行打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># &#123;method&#125; &#123;0x0000000128e022b0&#125; &#39;get&#39; &#39;()Lcom&#x2F;test&#x2F;SingletonObject;&#39; in &#39;com&#x2F;test&#x2F;SingletonObject&#39;</span><br><span class="line">#           [sp+0x40]  (sp of caller)</span><br><span class="line"></span><br><span class="line">  省略代码.....</span><br><span class="line"></span><br><span class="line">  0x000000010af1fb54: movb   $0x0,(%rax,%rsi,1)</span><br><span class="line">  0x000000011b6f4e58: lock addl $0x0,(%rsp)     ;*putstatic instance</span><br><span class="line">                                              ; - com.test.SingletonObject::get@13 (line 12)</span><br><span class="line">  省略代码.....</span><br><span class="line"></span><br><span class="line">  0x000000010af1f701: mov    %r12b,(%r11,%r10,1)</span><br><span class="line">  0x000000011b6f4a05: lock addl $0x0,(%rsp)     ;*putstatic instance</span><br><span class="line">                                              ; - com.test.SingletonObject::get@13 (line 12)</span><br><span class="line">  省略代码.....</span><br></pre></td></tr></table></figure> <p>我们可以看到被volatile修饰的共享变量进行写操作的时候，会比普通公共变量的读写操作多一行lock addl $0x0,(%rsp)前缀的代码，lock前缀指令有俩个作用：</p><ul><li>使用总线锁或缓存一致性协议来保证数据的可见性。</li><li>不是内存屏障却能完成类似内存屏障的功能，阻止屏障两遍的指令重排序保证有序性。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>volatile的使用场景不是很多，常用在多线程下的状态标记量和双重检查等，也有很多地方配合CAS来实现无锁编程。因为volatile只能保证线程每次拿到的数据是最新的，对于数据的单纯查询没有任何问题(jvm自动保证基本数据类型和引用的取值赋值为原子操作，lock指令保证有序性和可见性)，但是对于i++、懒汉式单例模式等对变量操作依赖当前值的情况，就显得无能为力。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程(三) 生命周期和常用方法</title>
      <link href="2020/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>2020/03/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="线程状态以及转化"><a href="#线程状态以及转化" class="headerlink" title="线程状态以及转化"></a>线程状态以及转化</h2><h4 id="NEW-新建"><a href="#NEW-新建" class="headerlink" title="NEW(新建)"></a>NEW(新建)</h4><ul><li>使用new创建出线程后，进入新建状态</li><li>此时jvm为其分配内存以及其成员变量</li><li>除此之外没有任何特征，方法也不会被执行</li></ul><h4 id="RUNNABLE-就绪"><a href="#RUNNABLE-就绪" class="headerlink" title="RUNNABLE(就绪)"></a>RUNNABLE(就绪)</h4><ul><li>调用对象的start()方法，进入就绪状态</li><li>此时jvm会为其创建方法调用栈和程序计数器</li><li>线程拥有被CPU调度资格，开始疯狂争夺使用权</li></ul><h4 id="RUNNING-运行"><a href="#RUNNING-运行" class="headerlink" title="RUNNING(运行)"></a>RUNNING(运行)</h4><ul><li>抢到CPU使用权时，开始执行run()方法，进入运行状态</li><li>线程只有通过start()后争夺到CPU时间片的方式运行run()方法，才可以实现异步执行</li><li>如果直接调用run()方法运行，系统会当作普通方法，不会异步执行</li></ul><h4 id="BLOCKED-阻塞"><a href="#BLOCKED-阻塞" class="headerlink" title="BLOCKED(阻塞)"></a>BLOCKED(阻塞)</h4><ul><li>处于运行状态的线程在进入synchronized关键字修饰的方法或代码块时，进入阻塞状态</li><li>阻塞的过程就是线程在抢夺锁的过程，因此阻塞是被动的</li><li>阻塞在某个锁上的线程，在锁被释放后会主动去争取，争取到锁后回到运行状态，因此脱离阻塞状态是主动的</li></ul><h4 id="WAITING-等待"><a href="#WAITING-等待" class="headerlink" title="WAITING(等待)"></a>WAITING(等待)</h4><ul><li>调用wait()、join()方法时，进入等待状态</li><li>因此进入等待状态是主动的，需要有事件主动唤醒</li></ul><h4 id="TIMED-WAITING-等待"><a href="#TIMED-WAITING-等待" class="headerlink" title="TIMED_WAITING(等待)"></a>TIMED_WAITING(等待)</h4><ul><li>调用sleep(long)、wait(long)、join(long)方法时，进入超时等待状态</li><li>同等待状态，到达参数指定时间自动唤醒</li></ul><h4 id="TERMINATED-终止"><a href="#TERMINATED-终止" class="headerlink" title="TERMINATED(终止)"></a>TERMINATED(终止)</h4><ul><li>run()方法或call()方法运行完毕，线程正常结束</li><li>线程执行代码过程中抛出未捕获异常或直接ERROR</li><li>调用stop()方法，也是个奇葩的方法，不推荐使用</li></ul><p>附加状态转化图：</p><div class="note success"><p>类型转化。</p></div><h2 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive()"></a>isAlive()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final native boolean isAlive();</span><br></pre></td></tr></table></figure><p>判断当前线程是否活着，只有当线程进入RUNNABLE(就绪)或RUNNING(运行)状态才返回true。</p><h2 id="sleep-long-millis"><a href="#sleep-long-millis" class="headerlink" title="sleep(long millis)"></a>sleep(long millis)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static native void sleep(long millis) throws InterruptedException;</span><br></pre></td></tr></table></figure><p>Thread的静态方法，使当前线程放弃CPU时间片，在指定时间内不参与CPU竞争，在到达指定时间后变为runnable状态并重新加入CPU竞争。如果当前线程持有锁，在睡眠过程中不会放弃锁的<span class="p red">占有权</span></p><h2 id="join-long-millis"><a href="#join-long-millis" class="headerlink" title="join(long millis)"></a>join(long millis)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 无参方法，调用重载方法传入固定参数0</span><br><span class="line">public final void join() throws InterruptedException &#123;</span><br><span class="line">join(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 支持超时的join方法</span><br><span class="line">public final synchronized void join(long millis) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取当前时间戳</span><br><span class="line">    long base &#x3D; System.currentTimeMillis();</span><br><span class="line">    &#x2F;&#x2F; 记录已经延迟多久</span><br><span class="line">    long now &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 参数校验，不能小于0</span><br><span class="line">    if (millis &lt; 0) &#123;</span><br><span class="line">    throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 没有超时限制情况下</span><br><span class="line">    if (millis &#x3D;&#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 线程只有处于活着状态才进行处理</span><br><span class="line">        while (isAlive()) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 这里意味着调用此方法的线程直接被wait方法挂起，没有提供任何notify方法唤醒，只能被动的等待线程运行完毕后死亡</span><br><span class="line">        wait(0);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 线程只有处于活着状态才进行处理</span><br><span class="line">while (isAlive()) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 还需要延迟多久</span><br><span class="line">        long delay &#x3D; millis - now;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果已达到延迟时间限制，跳出循环</span><br><span class="line">        if (delay &lt;&#x3D; 0) &#123;</span><br><span class="line">        break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 挂起进入等待状态</span><br><span class="line">        wait(delay);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 执行到这里说明等待时间已到，重新计算已经延迟多久了，等待下一次进入while循环调用break</span><br><span class="line">now &#x3D; System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码可以看出来join是用的wait()实现的，wait方法是object的方法，作用是让调用这个Object.wait()的线程处于等待状态，除非其他线程调用这个Object.notify()唤醒，或者这个Object死亡阻塞状态才会变成可运行状态，如果join方法带参数，那就等到参数时间结束自动唤醒自己。</p><p>如果在一个线程执行中创建另外一个线程并使用join()，那么主线程会被挂起，等待子线程执行完在继续往下执行。说白了和执行过程中调用另一个方法没什么区别，无非就是有个超时时间限制，超过时间限制主线程就取消等待继续执行。使用isAlive()进行判断，也就意味着线程如果没有进入RUNNABLE(就绪)或RUNNING(运行)状态，join方法不会起任何作用。</p><p>join其实合理理解成是线程合并，当在一个线程调用另一个线程的join方法时，当前线程阻塞等待被调用join方法的线程执行完毕才能继续执行，所以join的好处能够保证线程的执行顺序，但是如果调用线程的join方法其实已经失去了并行的意义，虽然存在多个线程，但是本质上还是串行的，最后join的实现其实是基于等待通知机制(wait+notify)的。</p><h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static native void yield();</span><br></pre></td></tr></table></figure><p>Thread的静态方法，暂停当前正在执行的线程对象，并执行其他线程。被暂停的线程会让出CPU的使用权给其他线程获得运行机会，自身转化为RUNNABLE(就绪)状态，但是这么做并不一定能达到让出CPU资源的目的，因为让出CPU使用权的时候，自身回到可运行状态与其他同优先级线程一起再去竞争CPU时间片，如果这个线程是个欧皇还会被再次选中，出现这种情况也就意味着此次yield()方法并没有任何效果。</p><p>目前想不到什么应用场景，如果一个线程的优先级特别低，执行内容也不是很重要，又怕他被CPU调度的次数多，可以适当的调用此方法减少执行的次数，把CPU资源给其他重要的线程工作。</p><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void interrupt() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果调用中断的是线程自身，则不需要进行安全性判断</span><br><span class="line">    if (this !&#x3D; Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  </span><br><span class="line">    synchronized (blockerLock) &#123;</span><br><span class="line">        Interruptible b &#x3D; blocker;</span><br><span class="line">        if (b !&#x3D; null) &#123;</span><br><span class="line">            interrupt0();           &#x2F;&#x2F; 只是设置中断标志</span><br><span class="line">            b.interrupt(this);</span><br><span class="line">            return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程内部都维护了一个中断标志(默认false)，调用线程的interrupt()方法时会根据当前线程的中断标志和阻塞情况，判断是否需要抛出异常：</p><ul><li>如果中断标志为false，且没有被阻塞，修改中断标志为true。</li><li>如果中断标志为true，此时调用wait、sleep、join方法时会抛出InterruptedException异常，恢复中断标志为false。</li><li>如果已经被wait、sleep、join方法阻塞，调用interrupt()会抛出InterruptedException异常，恢复中断标志为false。</li></ul><p>这里提到的阻塞，只是因为wait、sleep、join方法导致线程被堵住无法继续执行，并不是线程七大状态的BLOCKED(阻塞)状态。BLOCKED(阻塞)状态只由synchronized导致，而且不能被打断，相同的，IO阻塞也不能被打断。</p><p>由此可以看出来interrupt()方法中断的不是线程的<span class="p red">运行</span>，而是中断线程的<span class="p red">阻塞状态</span>，并且采用抛异常的方式引起线程的注意，被中断线程可以通过try catch方式自己决定如何应对中断信号。</p><p>比如使用kafka采用while(true)的方式消费数据时，又希望在某个时刻终止这个线程，并且终止过程中要保证此刻正在处理的那条消息处理完毕后才能终止，可以采用interrupt()方法+wait、sleep、join的一种来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void run()&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建消费者</span><br><span class="line">Properties props &#x3D; createProperties(&quot;localhost:9092&quot;, &quot;groups&quot;);</span><br><span class="line">props.put(&quot;enable.auto.commit&quot;, &quot;false&quot;);</span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer &#x3D; new KafkaConsumer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置消费topic</span><br><span class="line">consumer.subscribe(Arrays.asList(&quot;topic-name&quot;));</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 每次拉取消息</span><br><span class="line">ConsumerRecords&lt;String, String&gt; records &#x3D; consumer.poll(100);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 循环处理</span><br><span class="line">for (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 消费逻辑..</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; wait或sleep或join阻塞1毫秒，试探线程有没有被中断</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.wait(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; 关闭消费者对象</span><br><span class="line">            consumer.close();</span><br><span class="line">            return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stop"><a href="#stop" class="headerlink" title="stop()"></a>stop()</h2><p>强制终止线程的运行，并立即释放掉此线程持有的锁，这些锁可能用来维护数据一致性的，所以此方法被废弃。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程(二) 并发编程三大特性</title>
      <link href="2020/03/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
      <url>2020/03/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><div class="note info"><p>可见性是指一个线程对共享变量的修改，其他线程可以立即感知到这个变化</p></div><p>计算机中程序的执行，本质上是线程指令在CPU处理器上的执行，并且在执行必然牵涉到数据的读和写，程序运行过程的临时数据都是存放在主内存(RAM)中，因此CPU在处理数据的时候也必然牵涉到和主内存的交互。处理器访问内存时，需要先获取内存总线的控制权，任何时刻只能有一个处理器获得内存总线的控制权，可以理解为同一时刻某个内存地址只可能被一个处理器访问。</p><p>随着硬件技术的不断发展，现在的CPU处理速度已经远远超过主内存的访问速度，如果任何时候对数据的操作都要和内存进行交互，会大大降低指令的执行速度，因此就有了CPU高速缓存：<br><img src="/2020/03/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/CPU%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.jpg" class="lazyload" data-srcset="/2020/03/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/CPU%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>高速缓存的产生大大减少了CPU直接访问主内存的频率，也减少了内存访问速度对CPU的拖累，提高了CPU的执行效率。如果是单核CPU的操作系统中，只有一个高速缓存，没有任何问题。但是多核CPU的诞生打破了这个规则，处理器对数据的修改在没有做任何措施的情况下，不会及时通知到其他处理器的缓存，这就导致其他处理器的数据是脏数据。</p><p>比如i++操作，编译成指令后大概有三步骤：</p><ul><li>将i=0从主内存复制到</li><li>对i进行加1运算</li><li>将运算后的值刷回主内存</li></ul><p>假设俩个线程对公共变量i=0执行i++操作，我们期望俩个线程都执行完毕后i的值变为2，由于操作系统配置是多核CPU，俩个线程分别在不同的CPU上并行执行，用时间线流程图模拟执行效果:<br><img src="/2020/03/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98.png" class="lazyload" data-srcset="/2020/03/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><span class="p blue">图中可以看出CPU-1计算完毕后还没来得及将数据i刷回主内存，另一个CPU就去主内存获取i值并且到的是脏数据，这导致i最终值并不是我们期望的结果。对此问题，早期的解决方案是总线加锁，一个处理器在总线上输出LOCK#信号，使得其他处理器对内存的操作请求都会被阻塞，该处理器独占共享内存。方法简单粗暴，就是锁定范围太大(整个共享内存)，导致CPU利用率急剧下降。</span><p>CPU如何保证可见性？<br>为了解决总线锁开销过大问题，CPU提出了缓存一致性解决方案，主要有Directory协议、Snoopy协议、MESI协议。这个说下MESI协议，这个协议只会对高速缓存中的某个数据加锁(如果数据不在缓存中，还是会总线加锁)，不会影响到内存中其他数据的读写。MESI协议将数据划分为四种状态，通过总线嗅探机制让所有处理器监听数据状态的变化，达到缓存一致的目的:</p><p><img src="/2020/03/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/MESI%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81.png" class="lazyload" data-srcset="/2020/03/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/MESI%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>我们重点关注一下修改缓存数据的情况，对于E状态的数据，只有自己在读，可以直接把数据设置为M状态，对于S状态的数据，说明有多个处理器在读，必须将其他处理器对此数据的缓存作废，然后才能把数据的状态设置为M。当其他处理器发现自己的缓存是I状态时，就去主内存再次读取，而MESI协议保证其他处理器去主内存读取此数据前，将修改后的数据从高速缓存刷回主内存，并把数据状态改为E。</p><p>高并发情况下可能出现俩个处理器同时修改变量，并同时向总线发出将各自的缓存行更改为M状态的情况，此时总线会采取裁决机制进行裁决，将其中一个置为M状态，另一个置为I状态，且I状态的缓存行修改无效。</p><p>Java自带的可见性操作：</p><ul><li>volatile关键字(采用MESI协议保证，如果数据不在缓存中就用总线锁)</li><li>synchronized关键字(同一时刻就一个线程操作，还有啥不可见的)</li><li>Lock相关类(跟synchronized一个套路)</li></ul><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><div class="note info"><p>原子性操作是指一个或多个操作，要么全部执行且在执行过程中不被任何因素打断，要么全部不执行。并且针对某个值的原子操作在被执行的过程中，CPU绝不会再去进行其他的针对该值的操作</p></div><p>java作为一门高级语言，一个可执行线程会被编译成多条指令序列交由CPU执行，既然是多条指令，在执行过程中就存在被上下文切换打断的可能。在多线程编程中如果有的操作不具有原子性，同样会导致运行结果与预期的不一致，比如i++操作：<br><img src="/2020/03/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/%E7%BA%BF%E7%A8%8B%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98.png" class="lazyload" data-srcset="/2020/03/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/%E7%BA%BF%E7%A8%8B%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><span class="p blue">同样的i++操作，可见性与原子性对线程安全强调的角度却不一样，可见性强调线程在修改完数据后未及时从缓存刷新到主内存，导致另一个线程获取脏数据，继而影响到最终计算结果，而原子性强调非原子操作在执行过程中被上下文打断，在未切回期间另一个线程对数据i进行了递增操作，导致数据最终出现错误。</span><p>CPU如何保证原子性？<br>首先，处理器自动保证单条指令、基本内存操作的原子性，因此中断只会发生在指令之间。在单核CPU中保证操作原子性非常简单，只要禁止CPU在原子操作过程中发生上下文切换，那么就可以保证多线程对某个公共变量的多步骤操作都是串行的。嗯，有点线程安全的味道了。到了多核CPU时代，仅仅保证原子操作的执行不被CPU打断已经没什么卵用了，因为多个线程可以并行执行修改一个公共变量，线程之间又出现了干扰。对此，CPU又提出了CAS来解决这个问题(CAS下一章会讲)。</p><p>Java自带的原子性操作：</p><ul><li>基本数据类型的赋值(long、double无法保证)</li><li>所有引用类型的赋值</li><li>synchronized关键字(采用jvm的monitor，monitor底层采用CPU的CAS)</li><li>Lock相关类(采用aqs，aqs底层采用CPU的CAS)</li><li>java.concurrent.Atomic包下所有类(采用CPU的CAS)</li></ul><span class="p red">注:CPU和Java(内存读写)的原子性与数据库的原子性还是有区别的，CPU和Java(内存读写)执行原子操作过程中发生中断的唯一可能就是断电，这时候所有内存数据全部消失，也就没讨论的意义了。而数据库的增删改操作涉及的都是持久化的磁盘数据，就算执行过程发生断电，持久化的数据仍然存在，因此数据库的原子操作增加了事务回滚概念，只要事务没提交，就相当于没执行。无论CPU还是Java还是数据库，都是强调整体的成败，不允许仅执行部分操作的存在。</span><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><div class="note info"><p>有序性是指程序按照写代码的顺序执行</p></div><p>处理器和编译器为了提高程序运行效率，可能会对输入代码进行优化，并且不保证程序中各个语句的执行先后顺序同代码中的顺序一致。当然，CPU和编译器是在遵循as-if-serial语意的前提下对指令重排，而不是随意重排。首先CPU保证调度线程过程中，单线程的执行结果不会受指令重排影响导致结果不一致，编译器保证编译过程中不会对有依赖关系的数据进行指令重排。由此看出多线程情况下还是会有问题：<br><img src="/2020/03/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/%E6%9A%82%E6%97%A0.jpg" class="lazyload" data-srcset="/2020/03/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/%E6%9A%82%E6%97%A0.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图片"></p><p>CPU如何保证有序性？<br>处理器主要通过内存屏障机制来解决有序性问题，如果不想让它重排，在两条指令中间加一道屏障。拿X86平台来说，有几种主要的内存屏障：</p><ul><li>lfence，是一种Load Barrier(读屏障)，在lfence指令前的所有读操作当必须在lfence指令后的所有读操作前完成</li><li>sfence, 是一种Store Barrier(写屏障)，在sfence指令前的所有写操作当必须在sfence指令后的所有写操作前完成</li><li>mfence, 是一种General Barrier(通用屏障)，在mfence指令前的所有读写操作当必须在mfence指令后的所有读写操作前完成</li><li>除了内存屏障，也可以使用原子指令，如x86上的”lock…”前缀</li></ul><p>Java自带的有序性操作：</p><ul><li>volatile关键字(内存屏障)</li><li>synchronized关键字(单线程操作，as-if-serial语意自动保证)</li><li>Lock相关类(单线程操作，as-if-serial语意自动保证)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原子性、可见性、有序性问题是一切线程安全问题的根源，单纯的保证操作具有某一种特性只能解决某一部分场景问题。Java提供了很多类以及修饰符，提供了不同维度的保证，底层也都是封装CPU提供的措施来实现。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程(一) 基本概念</title>
      <link href="2020/03/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>2020/03/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>操作系统进行资源分配和调度的基本单位，每一个进程都是一个应用程序的执行实例，比如我们启动的一个java项目就是一个jvm进程，操作系统为jvm分配运行内存等资源，进程中包含一个或多个线程，线程之间共享进程的资源(比如堆、栈、方法区等)。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>CPU运行的最小单位，线程之间共享进程的资源，也有自己的私有空间，比如虚拟机栈、本地方法栈、程序计数器。</p><h2 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h2><h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>CPU通过分配时间片来执行任务，当一个任务的时间片用完，就会切换到另一个任务。在切换之前会保存上一个任务的状态，当下次再切换到该任务，就会加载这个状态，任务从保存到再加载的过程就是一次上下文切换。</p><ul><li>切出：一个线程被剥夺处理器的使用权而被暂停运行</li><li>切入：一个线程被系统选中占用处理器开始或继续运行</li></ul><p>线程的上下文是什么？<br>对于CPU来说一个线程就是多条指令集合，线程的运行实质上是多条指令在CPU上的运行，而上下文是指线程私有空间的内容。比如虚拟机栈、本地方法栈保存了某一时刻线程局部变量的值，程序计数器保存了线程此刻执行到哪一条指令的位置。</p><p>导致上下文切换的原因？</p><ul><li>CPU分配的时间片用完了 </li><li>有个优先级更高的线程需要被执行</li><li>手动操作比如java线程的sleep、yield、wait、join、synchronized、lock等</li><li>读取数据库操作由于数据量较大引起IO阻塞,线程会被挂起直到读取完毕再次回归等待被CPU调度</li></ul><p>上下文切换的过程？<br>放发生切换的时候，CPU会把被挂起线程的上下文保存在程序计数器和寄存器中，程序计数器存储正在执行的指令序列的位置、寄存器存储工作变量，然后从高速缓存中清除掉被挂起线程的上下文，去加载新线程的上下文到高速缓存中。因此线程上下文的切换需要消耗CPU的资源。</p><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>单CPU操作系统中多个线程同时运行，实质上是交替占有CPU使用权的过程，同时运行只是CPU处理过快造成的错觉，这种现象可以称作为<span class="p red">线程并发运行</span>。</p><p>到了多CPU时代才实现真正意义上的多线程同时运行，比如4颗CPU的操作系统可以做到4个线程的同时运行，但是操作系统中可能有很多线程需要被执行，比如有16个线程在运行，那么平均4个线程仍然要争夺一个CPU的使用权，只是同一时刻必然有4个争夺到使用权，这种现象称作为<span class="p red">线程并行运行</span>。</p><p>由此可以看出，操作系统中CPU的数量对多线程编程非常重要。因此项目开发中要尽量参考所在服务器的CPU配置，作出适当的线程池参数以避免频繁的上下文切换带来的性能损耗。同样在选取机器配置上尽量考虑放置服务的线程特点，比如存放redis服务选用多处理器的CPU没有任何意义，redis永远只在一个处理器上面运行。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>在开发中使用过线程都知道，多线程编程需要面对线程安全问题，而线程安全问题归根结底就三个方面:可见性、原子性、有序性，下一章节会详细讲解这些问题。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
